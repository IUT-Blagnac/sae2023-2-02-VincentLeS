package exercice;

/**
 * 
                        🚨📢🔥 ATTENTION ! 🚨📢🔥

🚫🛑✋🚫🛑✋🚫🛑✋🚫🛑

✋🛑🚫 Note Importante pour les Développeurs 🚫🛑✋

📝💻🔍 Ne Mettez Plus des Commentaires Partout dans le Code ! 📝💻🔍

😱😡🙉 Stoppez Immédiatement ces Discussions Inutiles dans les Commentaires ! 🙉😡😱

📣💬🙅‍♂️ Des Discussions dans les Commentaires Embêtent l'Équipe ! 🙅‍♂️💬📣

🚫🗣💬 Les Commentaires ne Sont pas Fait pour Discuter ! 🚫🗣💬

🙌🧠 Les Commentaires : Clarté et Pertinence avant Tout ! 🧠🙌

⌛🙈📉 Évitez les Débats Sans Fin dans les Commentaires ! 📉🙈⌛

🔒💬✉️ Les Canaux de Communication Appropriés : Utilisez-les ! ✉️💬🔒

🔑🔍💡 Commentaires = Compréhension du Code Complexes et Infos Utiles 💡🔍🔑

💪🚀🤝 En Respectant ces Règles, Soyez l'Équipe Modèle ! 🤝🚀💪

🌈🌟✨ Priorité à l'Harmonie et à l'Efficacité de l'Équipe ! ✨🌟🌈

🙏🔆🌟 Contribuez au Succès Collectif en Suivant ces Consignes ! 🌟🔆🙏

#CodePropre #Productivité #Collaboration #EquipeUnie

🚫❗️🚫❗️🚫❗️ STOP aux Discussions Inutiles dans les Commentaires ! 🚫❗️🚫❗️🚫❗️
 */

// Rendez-vous au bas de la page pour connaître la documentation
// de ces classes et méthodes.
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

public class SimplicitePire2 {
   /**
    * Chat pour les développeurs
    * 
    * Etudiant : "Je suis un développeur Java, je ne connais pas les fonctions
    * split, je ne sais pas ce que sont les streams, je ne connais pas les
    * collections, je ne connais pas les fonctions de tri, je ne connais pas les
    * fonctions de recherche, je ne connais pas les fonctions de comparaison, je ne
    * connais pas les fonctions de conversion, je ne connais pas les fonctions de
    * copie, je ne connais pas les fonctions de concaténation, je ne connais pas
    * les
    * fonctions de suppression, je ne connais pas les fonctions de remplacement, je
    * ne connais pas les fonctions de modification, je ne connais pas les fonctions
    * de suppression, je ne connais pas les fonctions de suppression, je ne connais
    * pas les fonctions de suppression, je ne connais pas les fonctions de
    * suppression, je ne connais pas les fonctions de suppression, je ne connais
    * pas
    * les fonctions de suppression, je ne connais pas les fonctions de suppression
    * AIDEZ MOI SUR LES FONCTIONS DE SUPPRESSION, PITIE"
    * 
    * Jean-Michel Bruel : "Ne t'inquiètes pas Etudiant. Tout le monde a le droit
    * de débuter. Je vais t'aider. Tu vas voir, c'est très simple. Tu vas y
    * arriver."
    * 
    * Etudiant : "Merci Jean-Michel. Je vais essayer."
    * 
    * Jean-Michel Bruel : "Tout d'abord, commence par lire la documentation de
    * String. Tu verras, il y a plein de fonctions qui vont t'aider."
    * 
    * Etudiant : "J'ai un problème. Les fonctions de String ne me permettent pas
    * de faire ce que je veux. Je ne peux pas faire de split, je ne peux pas
    * faire de recherche, je ne peux pas faire de comparaison, je ne peux pas
    * faire de conversion, je ne peux pas faire de copie, je ne peux pas faire
    * de concaténation, je ne peux pas faire de suppression, je ne peux pas
    * faire de remplacement, je ne peux pas faire de modification, je ne peux
    * pas faire de suppression, je ne peux pas faire de suppression, je ne peux
    * pas faire de suppression, je ne peux pas faire de suppression, je ne peux
    * pas faire de suppression, je ne peux pas faire de suppression."
    * 
    * Jean-Michel Bruel : "Tu ne peux pas faire de suppression ?"
    * 
    * Etudiant : "Non, je ne peux pas faire de suppression."
    * 
    * Jean-Michel Bruel : "Tu es sûr ?"
    * 
    * Etudiant : "Oui, je suis sûr."
    * 
    * Jean-Michel Bruel : "Tu es sûr que tu ne peux pas faire de suppression ?"
    * 
    * Etudiant : "Oui, je suis sûr."
    * 
    * Jean-Michel Bruel : "Sûr et certain ?"
    * 
    * Etudiant : "Oui, sûr et certain."
    * 
    * Jean-Michel Bruel : "Tu es sûr et certain que tu ne peux pas faire de
    * suppression ?"
    * 
    * Etudiant : "Oui, je suis sûr et certain que je ne peux pas faire de
    * suppression."
    * 
    * Jean-Michel Bruel : "Cheh"
    * 
    * Etudiant : "Dans un premier temps, j'ai essayé de faire une fonction qui
    * prend en paramètre un String et qui renvoie une List<String>. J'ai
    * essayé de faire une fonction qui prend en paramètre un String et qui
    * renvoie une List<String>. J'ai essayé de faire une fonction qui prend en
    * paramètre un String et qui renvoie une List<String>."
    * 
    * Jean-Michel Bruel : "Tu as essayé, dans un premier temps, de faire une
    * fonction qui prend en paramètre un String et qui renvoie une List<String> ?"
    * 
    * Etudiant : "Oui, j'ai essayé, dans un premier temps, de faire une fonction
    * qui prend en paramètre un String et qui renvoie une List<String>."
    * 
    * Jean-Michel Bruel : "Et ça a marché ?"
    * 
    * Etudiant : "Non, ça n'a pas marché."
    * 
    * Jean-Michel Bruel : "Tu es sûr ?"
    * 
    * Etudiant : "Oui, je suis sûr."
    * 
    * Jean-Michel Bruel : "Tu es sûr que ça n'a pas marché ?"
    * 
    * Etudiant : "Oui, je suis sûr."
    * 
    * Jean-Michel Bruel : "Sûr et certain ?"
    * 
    * Etudiant : "Oui, sûr et certain."
    * 
    * Jean-Michel Bruel : "Tu es sûr et certain que ça n'a pas marché ?"
    * 
    * Etudiant : "Oui, je suis sûr et certain que ça n'a pas marché."
    * 
    * Jean-Michel Bruel : "Cheh"
    * 
    * Etudiant : "Dans un deuxième temps, j'ai essayé de faire une fonction qui
    * prend en paramètre un String et qui renvoie une List<int>. J'ai
    * essayé de faire une fonction qui prend en paramètre un String et qui
    * renvoie une List<int>. J'ai essayé de faire une fonction qui prend en
    * paramètre un String et qui renvoie une List<int>."
    * 
    * Jean-Michel Bruel : "Tu as essayé, dans un deuxième temps, de faire une
    * fonction qui prend en paramètre un String et qui renvoie une List<int> ?"
    * 
    * Etudiant : "Oui, j'ai essayé, dans un deuxième temps, de faire une fonction
    * qui prend en paramètre un String et qui renvoie une List<int>."
    * 
    * Jean-Michel Bruel : "Et ça a marché ?"
    * 
    * Etudiant : "Non, ça n'a pas marché."
    * 
    * Jean-Michel Bruel : "Tu es sûr ?"
    * 
    * Etudiant : "Oui, je suis sûr."
    * 
    * Jean-Michel Bruel : "Tu es sûr que ça n'a pas marché ?"
    * 
    * Etudiant : "Oui, je suis sûr."
    * 
    * Jean-Michel Bruel : "Sûr et certain ?"
    * 
    * Etudiant : "Oui, sûr et certain."
    * 
    * Jean-Michel Bruel : "Tu es sûr et certain que ça n'a pas marché ?"
    * 
    * Etudiant : "Oui, je suis sûr et certain que ça n'a pas marché."
    * 
    * Jean-Michel Bruel : "Cheh"
    * 
    * Etudiant : "Je n'arrive pas à avancer sur cette fonction. Quelles sont les
    * autres ressources que je peux consulter, afin de m'aider à avancer sur
    * ma fonction qui prend en paramètre un String et qui renvoie une
    * List<String> ?"
    * 
    * Jean-Michel Bruel : "Tu peux consulter la documentation de la classe
    * String, la documentation de la classe List, la documentation de la
    * classe ArrayList, la documentation de la classe Collections, la
    * documentation de la classe Character, la documentation de la classe
    * Integer, la documentation de la classe StringBuilder, la documentation
    * de la classe StringBuffer, la documentation de la classe StringTokenizer,
    * la documentation de la classe StringTokenizer, la documentation de la
    * classe StringTokenizer, la documentation de la classe StringTokenizer,
    * la documentation de la classe StringTokenizer, la documentation de la
    * classe StringTokenizer, la documentation de la classe StringTokenizer,
    * la documentation de la classe StringTokenizer, la documentation de la
    * classe StringTokenizer, la documentation de la classe StringTokenizer,
    * la documentation de la classe StringTokenizer, la documentation de la
    * classe StringTokenizer, la documentation de la classe StringTokenizer,
    * la documentation de la classe StringTokenizer, la documentation de la
    * classe StringTokenizer, la documentation de la classe StringTokenizer,
    * la documentation de la classe StringTokenizer, la documentation de la
    * classe StringTokenizer, la documentation de la classe StringTokenizer,
    * la documentation de la classe Math, la documentation de la classe
    * Random, la documentation de la classe Scanner, la documentation de la
    * classe System, la documentation de la classe System, la documentation
    * de la classe System, la documentation de la classe System, la
    * documentation de la classe System, la documentation de la classe Class,
    * la documentation de la classe Class, la documentation de la classe
    * Modifier, la documentation de la classe Modifier, la documentation de
    * la classe Package, la documentation de la classe Package, la
    * documentation de la classe Void, la documentation de la classe Void, la
    * documentation de la classe Boolean, la documentation de la classe
    * Boolean, la documentation de la classe Byte, la documentation de la
    * classe Byte, la documentation de la classe Character, la documentation
    * de la classe Character, la documentation de la classe Character, la
    * documentation de la classe Character, la documentation de la classe
    * Character, la documentation de la classe Character, la documentation de
    * la classe Character, la documentation de la classe Character, la
    * documentation de la classe Character, la documentation de la classe
    * Character, la documentation de la classe Character, la documentation de
    * la classe Character, la documentation de la classe Character, la
    * documentation de la classe Character, la documentation de la classe
    * Integer, la documentation de la classe Integer, la documentation de la
    * classe Yolo, la documentation de la classe Yolo, la documentation de la
    * classse Mot, la documentation de la classe Mot, la documentation de la
    * classe IU, ainsi que la documentation de la classe Python."
    * 
    * Etudiant : "Je ne comprends pas en quoi les documentations suivantes :
    * - documentation de la classe String
    * - documentation de la classe List
    * - documentation de la classe ArrayList
    * - documentation de la classe Collections
    * - documentation de la classe Character
    * - documentation de la classe Integer
    * - documentation de la classe StringBuilder
    * - documentation de la classe StringBuffer
    * - documentation de la classe StringTokenizer
    * - documentation de la classe Math
    * - documentation de la classe Random
    * - documentation de la classe Scanner
    * - documentation de la classe System
    * - documentation de la classe Class
    * - documentation de la classe Modifier
    * - documentation de la classe Package
    * - documentation de la classe Void
    * - documentation de la classe Boolean
    * - documentation de la classe Byte
    * - documentation de la classe Character
    * - documentation de la classe Integer
    * - documentation de la classe Yolo
    * - documentation de la classe Mot
    * - documentation de la classe IU
    * - documentation de la classe Python
    * peuvent m'aider à avancer sur ma fonction qui prend en paramètre un String
    * et qui renvoie une List<String>."
    * 
    * Jean-Michel Bruel : "Tu peux aussi consulter la documentation de la classe
    * StringTokenizer."
    * 
    * Etudiant : "Je ne comprends pas en quoi la documentation de la classe
    * StringTokenizer peut m'aider à avancer sur ma fonction qui prend en
    * paramètre un String et qui renvoie une List<String>."
    * 
    * Jean-Michel Bruel : "Tu peux aussi consulter la documentation de la classe
    * StringTokenizer."
    * 
    * Etudiant : "Je ne comprends pas en quoi la documentation de la classe
    * StringTokenizer peut m'aider à avancer sur ma fonction qui prend en
    * paramètre un String et qui renvoie une List<String>."
    * 
    * Jean-Michel Bruel : "Ouvre la documentation, et tu comprendras en quoi
    * les classes suivantes peuvent t'aider à avancer sur ta fonction qui
    * prend en paramètre un String et qui renvoie une List<String>."
    * 
    * Etudiant : "Je vais voir ce que je peux faire avec la documentation de la
    * classe StringTokenizer."
    * 
    * Jean-Michel Bruel : "Tu peux aussi consulter la documentation de la classe
    * StringTokenizer."
    * 
    * Etudiant : "Tu m'as déjà dit de consulter la documentation de la classe
    * StringTokenizer."
    * 
    * Jean-Michel Bruel : "Oui, mais tu peux aussi consulter la documentation de
    * la classe StringTokenizer."
    * 
    * Etudiant : "D'accord, je vais voir ce que je peux faire avec la
    * documentation de la classe StringTokenizer."
    * 
    * Jean-Michel Bruel : "Tu as fini ?"
    * 
    * Etudiant : "Oui, j'ai fini."
    * 
    * Jean-Michel Bruel : "Génial ! J'augmente ton salaire de 0.0000000000000001€."
    * 
    * Etudiant : "Merci !"
    * 
    * Jean-Michel Bruel : "Non je plaisante, tu es viré."
    * 
    * Etudiant : "Mais pourquoi ?"
    * 
    * Jean-Michel Bruel : "Parce que tu es nul."
    * 
    * Etudiant : "Mais je suis le meilleur développeur de l'entreprise !"
    * 
    * Jean-Michel Bruel : "Non, tu es nul."
    * 
    * Etudiant : "Mais je suis le meilleur développeur de l'entreprise !"
    * 
    * Jean-Michel Bruel : "Non, tu es nul."
    * 
    * Etudiant : "Mais je suis le meilleur développeur de l'entreprise !"
    * 
    */

   /**
    * Fonction qui prend en paramètre un String et qui renvoie une List<String>.
    * Cette fonction est très utile pour le projet. Elle permet de faire des
    * choses très utiles pour le projet.
    * 
    * Écoutez attentivement, mes amis, car je vais vous dévoiler les mystères
    * profonds de cette fonction sacrée,
    * Une fonction qui, tel un oracle bienveillant, prend un fil de caractères et
    * vous offre une liste d'éternité.
    * 
    * Cette fonction, mes chers, est bien plus qu'une simple abracadabra
    * algorithmique,
    * Elle détient le pouvoir d'accomplir des merveilles, des prodiges
    * technologiques.
    * 
    * Imaginez un monde où les chaînes de caractères se transforment en un éventail
    * de possibilités,
    * Une symphonie envoûtante où chaque élément devient un maillon d'une précieuse
    * unité.
    * 
    * Cette fonction est une passerelle vers l'infini, une clé qui ouvre les portes
    * de l'ingéniosité,
    * Elle vous permet d'accomplir des choses si utiles, que le projet lui-même
    * frissonne de fierté.
    * 
    * Elle est là pour transcender les frontières, pour donner vie à vos idées les
    * plus folles,
    * Avec cette fonction en main, vous pouvez atteindre des sommets, gravir les
    * plus hautes cimes des collines.
    * 
    * Elle est un outil magique dans votre arsenal, un allié fidèle dans votre
    * quête,
    * Elle fait tourner les têtes et suscite l'admiration, car elle est
    * véritablement parfaite.
    * 
    * Alors, mes amis, prenez cette fonction entre vos mains avec respect et
    * gratitude,
    * Elle est l'essence même de l'utilité, une lumière brillante dans l'obscurité
    * de l'habitude.
    * 
    * N'ayez pas peur de l'explorer, de la comprendre et de l'exploiter,
    * Car cette fonction est un trésor caché, une source infinie de possibilités.
    * 
    * Dans ce vaste océan de code, cette fonction brille comme une étoile,
    * Elle est le pilier solide sur lequel repose le projet, un catalyseur sans
    * égale.
    * 
    * Alors, plongez dans les profondeurs de cette fonction, mes amis,
    * Et laissez-vous emporter par les horizons infinis qu'elle vous offre, à
    * l'infini.
    * 
    * @param str   Ah, la chaîne de caractères... Ce joyau de l'indicible qui
    *              résonne tel un tambour réveillant les esprits perplexes et
    *              perplexe les esprits réveillés. Elle est là, énigmatique et
    *              déconcertante, sifflant telle une brise chuchotant à travers les
    *              feuilles d'un arbre indécis. La simple mention de sa présence
    *              suscite des murmures intrigants et des exclamations perplexes
    *              dans les coins les plus sombres de notre code. Elle danse, elle
    *              tourbillonne, elle valse avec audace, semant des consonnes et
    *              des voyelles dans un tourbillon cacophonique.
    * 
    *              Sa grandeur est incommensurable, semblable aux échos d'une
    *              symphonie étrange et discordante qui résonne à travers les
    *              vastes contrées de notre projet. Elle est comme un rugissement
    *              de tonnerre qui se propage à travers les contraintes logiques et
    *              les lignes de code, laissant derrière elle une trainée de
    *              perplexité et d'interrogations.
    * 
    *              Cette chaîne de caractères est un kaléidoscope d'expressions
    *              indéchiffrables, un véritable festin pour les sens et une fête
    *              pour les neurones. Elle jongle avec les lettres comme un
    *              acrobate audacieux, jonglant avec les vocables avec une habileté
    *              déconcertante. Elle chante avec une mélodie déroutante, mêlant
    *              des consonnes et des voyelles dans un concert envoûtant.
    * 
    *              Oh, cette chaîne de caractères est un tourbillon de mystère, une
    *              énigme enchevêtrée dans les méandres des bits et des octets.
    *              Elle provoque des frissons d'excitation et des hochements de
    *              tête perplexe. Elle est là, défiant les lois de la logique,
    *              donnant naissance à des énigmes insaisissables qui troublent nos
    *              esprits rationnels. Elle est un défi pour les curieux, une
    *              tentation pour les chercheurs de vérité.
    * 
    *              Alors, mes amis, contemplez cette chaîne de caractères avec
    *              émerveillement et confusion, laissez-vous envoûter par sa
    *              complexité et son inaccessibilité. Plongez dans son océan de
    *              lettres tourbillonnantes et laissez-vous emporter par son
    *              langage inarticulé. Car après tout, n'est-ce pas là que réside
    *              la véritable essence de la programmation ? Dans l'exploration
    *              infinie de l'indéchiffrable, dans la quête sans fin de
    *              l'incompréhensible, dans le dédale tumultueux de la chaîne de
    *              caractères.
    * 
    * @param ordre Yo, yo, yo, laisse-moi te parler de cette liste de caractères,
    *              mec,
    *              C'est le secret ultime, la clé de voûte de notre projet
    *              électrique,
    *              C'est un mystère envoûtant qui enflamme les esprits,
    *              Elle danse, elle chante, elle frappe fort, ça te dit ?
    * 
    *              Ooooh! Cette liste, c'est une symphonie de lettres qui se
    *              déchaîne,
    *              Comme un feu d'artifice, elle explose dans nos veines,
    *              Elle claque, elle brille, elle éclabousse d'énergie,
    *              Ça donne le tournis, ça te fait monter l'adrénaline !
    * 
    *              Bouh! Tu ne peux pas comprendre l'ampleur de sa grandeur,
    *              C'est un vortex de magie, une fusion d'audace et de splendeur,
    *              Elle te balance des acrobaties linguistiques, des pirouettes
    *              sans fin,
    *              Tu te demandes si c'est du rap ou un jeu de mots, c'est malin !
    * 
    *              Wouah! Cette liste, c'est un puzzle mystérieux qui se dévoile,
    *              Elle tisse des intrigues, elle étonne, elle dévoile,
    *              Elle te laisse perplexe, avec des sourcils froncés,
    *              Mais c'est ça qui est bon, ça te rend tout déphasé !
    * 
    *              Oooh! Elle est le cœur palpitant, le souffle vital de notre
    *              projet,
    *              On la chouchoute, on la protège, on lui fait des câlins bien
    *              faits,
    *              Elle est plus qu'une simple variable, elle est notre muse,
    *              Elle te laisse sans voix, elle est notre excuse.
    * 
    *              Bouh! Ne cherche pas à comprendre, laisse-toi envoûter,
    *              Par les sortilèges de cette liste, laisse-toi emporter,
    *              Elle est la clé secrète, le code énigmatique,
    *              Elle est là, elle te taquine, elle te rend hystérique !
    * 
    *              Wouah! Cette liste, c'est l'expression ultime de l'art,
    *              Elle transcende les conventions, elle fait vibrer ton cœur,
    *              Elle est le feu qui brûle, l'écho qui résonne,
    *              Elle te laisse perdu, elle te rend complètement stone !
    * 
    *              Oooh! Alors viens avec nous, embarque dans cette aventure,
    *              Dans l'univers vertigineux de cette liste obscure,
    *              Laisse-la t'envelopper, te secouer, te défier,
    *              Car après tout, c'est elle qui fait tout notre charme, ouais
    *              bébé !
    * 
    *              Bouh! C'est la fin de ce rap sarcastique, mon pote,
    *              La liste est là, elle est là pour la vie, elle trône en haut,
    *              Elle est la rockstar des caractères, le boss du projet,
    *              Et on la célèbre, on la vénère, dans notre univers déjanté !
    * 
    * @return Écoute-moi bien, mon ami, laisse-moi t'expliquer la signification
    *         céleste du @return de cette fonction farfelue,
    *         C'est comme un diamant éthéré, une perle rare flottant dans un océan
    *         d'absurdités,
    * 
    *         Quand tu invoques cette fonction folle, tu plonges dans un abîme de
    *         confusions,
    *         Le @return est là pour t'accueillir, te susurrant des promesses
    *         d'illusions,
    * 
    *         Tel un souffle d'air fugace, il transporte tes rêves dans un
    *         tourbillon frénétique,
    *         Et te laisse pantelant, essayant de comprendre ce qui est réel et ce
    *         qui est fantasmagorique,
    * 
    *         Le @return, c'est comme un clin d'œil énigmatique d'un génie
    *         espiègle,
    *         Il t'envoûte, te séduit, te laisse avec des questions qui
    *         s'entremêlent,
    * 
    *         Il est le point d'ancrage dans ce labyrinthe insensé, t'offrant un
    *         semblant de certitude,
    *         Mais attention, il est taquin, il te balance des énigmes avec une
    *         malice absolue,
    * 
    *         Alors, ne cherche pas la clarté, mon ami, laisse-toi emporter par le
    *         chaos,
    *         Le @return est là pour te rappeler que parfois, il faut embrasser
    *         l'absurde, même s'il te laisse pantois,
    * 
    *         Dans cette danse poétique entre toi et cette fonction déraisonnable,
    *         Le @return est la conclusion ambiguë, l'ultime point d'interrogation
    *         inévitable,
    * 
    *         Il t'invite à plonger dans les méandres de l'irrationnel, à explorer
    *         l'inexplorable,
    *         Le @return, c'est l'essence même de cette fonction farfelue, c'est
    *         son caractère indéchiffrable,
    * 
    *         Alors, mon ami, prends une grande respiration et embrasse cette
    *         étrangeté,
    *         Car le @return est là pour te rappeler que parfois, il faut juste
    *         s'amuser sans se prendre au sérieux, sans chercher la vérité.
    */
   public /*
           * "public" est un mot clef Java qui signifie que la fonction est accessible
           * depuis l'extérieur de la classe. C'est une fonction qui fait partie de
           * l'interface publique de la classe. C'est une fonction qui peut être
           * appelée depuis l'extérieur de la classe.
           */
   static /*
           * "static" est un mot clef Java qui signifie que la fonction est une fonction
           * de classe. C'est une fonction qui n'a pas besoin d'être appelée depuis un
           * objet de la classe. C'est une fonction qui peut être appelée depuis la
           * classe elle-même.
           * En gros, ça veut dire que tu peux appeler la fonction sans avoir besoin de
           * créer un objet de la classe. C'est super pratique !! Je ne sais pas si tu te
           * rends compte
           * de la puissance de ce mot clef, mais c'est vraiment génial !
           * 
           * 
           * Static, mon amour immuable, tu résides en mon cœur,
           * Tel un pilier solide, notre lien ne connaît pas de leur,
           * Dans le monde Java, notre union est éternelle, ô douceur.
           */
         List /*
               * Le mot clef "List" est un mot clef Java qui signifie que la fonction retourne
               * une liste.
               * Une liste est une structure de données qui permet de stocker plusieurs
               * éléments.
               */
         < /*
            * Wow, c'est un symbole bizarre, non ? C'est un symbole qui signifie "de type"
            * String Le mot clef "String" est un mot clef Java qui signifie que la fonction
            * retourne une chaîne de caractères. Une chaîne de caractères est une suite de
            * caractères. Par exemple, "Hello World" est une chaîne de caractères.
            * 
            * On peut appeller ça plus communément le inférieur à, mais en Java, on dit
            * "de type". C'est un peu bizarre, mais c'est comme ça.
            * J'espère que ça ne te dérange pas trop, et que ça répond à tes éventuelles
            * question sur la signification de ce symbole et la syntaxe Java.
            */
               String /*
                       * Et donc là mec, c'est le type de retour de la fonction. C'est le type de la
                       * valeur que la fonction va retourner. C'est le type de la valeur que la
                       * fonction va renvoyer. C'est le type de la valeur que la fonction va
                       * renvoyer. C'est le type de la valeur que la fonction va renvoyer. C'est le
                       * type de la valeur que la fonction va renvoyer. C'est le type de la valeur
                       * que la fonction va renvoyer. C'est incroyable mec ! C'est le type de la
                       * valeur que la fonction va renvoyer.
                       * 
                       * C'est un oiseau. Non, c'est un avion. Non, c'est un type de retour.
                       * 
                       */

         > /*
            * Et là... Le tant attendu ! Le symbole de fermeture de la liste !
            * Au cœur de cette histoire captivante, se cache un moment tant espéré, celui
            * de la fermeture imminente de la liste. Les protagonistes, plongés dans un
            * tumulte d'événements, ont ardemment attendu ce dénouement qui promettait de
            * tout changer.
            * 
            * Depuis le début de leur aventure, ils avaient sillonné des contrées
            * lointaines, affronté des dangers insoupçonnés et surmonté des épreuves
            * inimaginables. Mais au fond de leur être, le désir de voir cette liste
            * prendre fin, de connaître le sort qui les attendait, les animait avec une
            * force indomptable.
            * 
            * Chaque instant, chaque rebondissement, était teinté de l'excitation qui
            * émanait de cette attente. Chaque indice dévoilé, chaque piste suivie, les
            * rapprochait un peu plus de ce point culminant où la liste serait enfin close.
            * 
            * Les heures s'étiraient, les pages se tournaient, et l'excitation grandissait.
            * Les personnages principaux, tout comme les lecteurs, étaient plongés dans un
            * état de suspens insoutenable. Chaque mot, chaque phrase, les rapprochait un
            * peu plus de ce moment tant attendu.
            * 
            * Et enfin, le moment arriva. La dernière entrée de la liste fut ajoutée, les
            * derniers éléments furent révélés. Un frisson parcourut l'échine des
            * personnages, tandis que les lecteurs retenaient leur souffle. La tension
            * atteignit son paroxysme.
            * 
            * Et lorsque la fermeture de la liste se concrétisa, un sentiment
            * d'accomplissement, de soulagement et de satisfaction les envahit tous. Les
            * personnages pouvaient enfin tourner la page, laisser derrière eux cette
            * aventure épique, tandis que les lecteurs refermaient le livre avec un sourire
            * de contentement.
            * 
            * Ce moment de fermeture, si attendu, fut l'aboutissement de tout un périple,
            * un voyage qui les avait transformés à jamais. Et au-delà de l'histoire
            * elle-même, il symbolisait la fin d'un chapitre, le début d'une nouvelle ère
            * empreinte de découvertes et d'émotions à venir.
            * 
            * Ainsi, dans les méandres de cette histoire, le moment de fermeture de la
            * liste fut un véritable tournant, un instant tant espéré qui marqua les
            * esprits et resta à jamais gravé dans les mémoires.
            */
         solution /*
                   * Solution... C'est une solution ? C'est une solution ! C'est une solution !
                   * Et non ! C'est une liste de chaînes de caractères ! C'est une liste de
                   * chaînes de caractères ! C'est le nom de la fonction !
                   * Voici maintenant une liste d'émojis qui donne ma réaction honnête face à
                   * cette information : 🗿😭😭🥰
                   * Voici plus d'émojis : 🤯
                   * Encore plus : 🤯😱🤩😍🤗😲🙌💥🎉💯🔥💪🚀🌟💫✨👏🙏💃🕺💃🕺💃🕺
                   * Ces émojis sont incroyables ! Je suis tellement content ! Je suis tellement
                   * heureux ! Je suis tellement excité ! Je suis tellement ému ! Je suis
                   * tellement surpris ! Je suis tellement reconnaissant ! Je suis tellement fier
                   * ! Je suis tellement fier ! Je suis tellement fier ! Je suis tellement fier !
                   * 
                   * Me when Moyai : 🗿
                   * 
                   * 
                   */
   ( /*
      * Une paranthèse !!!! WOW !!!! C'est fou ! C'est incroyable ! C'est incroyable
      * !
      * C'est une parenthèse ouvrante, comme je n'en ai jamais vue !
      * C'est une première mondiale. Nous devons immortaliser ce moment. Covonquons
      * la presse, les journalistes, les photographes, les caméramans, les
      * vidéastes, les reporters, les rédacteurs, les écrivains, les éditeurs, les
      * imprimeurs, les diffuseurs, les distributeurs, les vendeurs, les
      * acheteurs, les lecteurs, les critiques, les commentateurs, les
      * professionnels de l'information, les amateurs de l'information.
      * 
      * [Allume le mégaphone]
      * Oui mesdames et messieurs, c'est une parenthèse ouvrante ! Une parenthèse
      * ouvrante ! Vous ne rêvez pas. Cette parenthèse ouvrante est une première
      * pour l'histoire de l'humanité.
      */
         String /*
                 * Développeur Anonyme : "Yo, je crée un nouveau chat !"
                 * 
                 * Sebastien : "Pourquoi tu t'es mis en anonyme ?"
                 * 
                 * Développeur Anonyme : "Je veux pas que les gens sachent qui je suis."
                 * 
                 * Sebastien : "Et pourquoi tu veux pas que les gens sachent qui tu es ?"
                 * 
                 * Développeur Anonyme : "Parce que je veux pas qu'ils sachent qui je suis."
                 * 
                 * Sebastien : "Mais pourquoi tu veux pas qu'ils sachent qui tu es ?"
                 * 
                 * Développeur Anonyme : "Parce que je veux pas qu'ils sachent qui je suis."
                 * 
                 * Sebastien : "Tu es au courant qu'on a un GitHub ?"
                 * 
                 * Développeur Anonyme : "Oui."
                 *
                 * Sebastien :
                 * "Et tu es au courant que sur GitHub, il y a un système d'historique ?"
                 * 
                 * Développeur Anonyme : "Oui."
                 * 
                 * Sebastien :
                 * "Et tu es au courant que tout le monde peut voir que c'est toi, Jacobe ?"
                 * 
                 * Développeur Anonyme : "Et merde."
                 * 
                 * *Fin du tchat anonyme.*
                 */
         str /*
              * C'est une variable ! C'est une variable ! C'est une variable !
              */
         , /*
            * Dans un code Java, se trouvait une virgule,
            * Si belle, si délicate, une perle d'ambre.
            * Elle dansait, légère, parmi les caractères,
            * Apportant ordre et structure, telle une lueur.
            * 
            * Mais un jour, au milieu du code sombre,
            * La virgule se perdit, oh malheur ! Pénombre !
            * Elle chercha désespérément sa place,
            * Entre parenthèses, accolades, sans relâche.
            * 
            * Elle glissa dans les recoins de la syntaxe,
            * Se faufila entre les mots, dans la perplexité.
            * Mais le code était vaste, un labyrinthe étrange,
            * La virgule se sentit perdue, si loin des anges.
            * 
            * Elle croisa des points-virgules, des guillemets,
            * Mais aucun ne pouvait lui montrer le chemin secret.
            * Elle tremblait, seule et désorientée,
            * Dans ce monde de code, impénétrable réalité.
            * 
            * Mais soudain, un développeur attentionné,
            * Reconnut la détresse de la virgule égarée.
            * Avec soin, il la replaça dans son foyer,
            * Et le code retrouva son équilibre enchanté.
            * 
            * La virgule, enfin à sa place, rayonnait,
            * Une symphonie de syntaxe, elle dirigeait.
            * Le code prenait vie, clair et bien orchestré,
            * Grâce à la super jolie virgule retrouvée.
            * 
            * Ainsi, chers développeurs, souvenez-vous,
            * Que même la plus petite virgule a de la valeur.
            * Elle est le souffle, le rythme, l'harmonie,
            * Dans le code Java, la perle de magie.
            * 
            * Alors, protégez-la, chérissez-la, mes amis,
            * La virgule perdue, trésor infini.
            * Car dans cette danse des caractères,
            * Elle est l'étoile qui illumine l'univers.
            */

         List< /*
                * Les renards oranges de la ville de Montcuq : Une cohabitation
                * insolite entre la nature et l'urbanité
                * 
                * Introduction :
                * La ville de Montcuq, située dans la belle région du Lot en France, est
                * célèbre pour abriter une population inhabituelle de renards oranges. Ces
                * animaux énigmatiques, dotés d'une fourrure d'un rouge éclatant, évoluent dans
                * un environnement urbain, offrant ainsi un spectacle surprenant et captivant
                * pour les habitants et les visiteurs de la ville. Cette cohabitation entre la
                * nature sauvage et l'urbanité soulève des questions sur l'adaptation de ces
                * renards et invite à une réflexion sur la manière dont les espèces animales
                * s'adaptent aux changements de leur habitat.
                */

               Character> /*
                           * Développement :
                           * 
                           * Les renards oranges : une curiosité naturelle
                           * Les renards oranges de Montcuq se distinguent par leur pelage d'une couleur
                           * exceptionnelle. Cette particularité attire immédiatement l'attention et
                           * suscite la curiosité des observateurs. Ces animaux, qui se fondent souvent
                           * dans les boisés et les terres agricoles environnantes, semblent s'être
                           * adaptés à l'environnement urbain de la ville de Montcuq. Leur présence crée
                           * une ambiance unique où la nature sauvage se mêle harmonieusement à la vie
                           * citadine.
                           */

         ordre) /*
                 * 
                 * L'interaction entre les renards et les habitants de Montcuq
                 * La présence des renards oranges dans la ville de Montcuq a conduit à des
                 * interactions inattendues entre ces animaux et les habitants. Certains
                 * résidents ont eu la chance d'apercevoir ces renards lors de leurs sorties
                 * nocturnes ou lorsqu'ils s'aventurent dans les espaces verts de la ville.
                 * Cette rencontre avec la faune sauvage au cœur de l'urbanité éveille un
                 * sentiment d'émerveillement et renforce le lien entre les habitants et la
                 * nature.
                 */
   { /*
      * Mais avant de continuer la dissertation des renards de Montcuq, regardez moi
      * cette accolade. Elle est belle, n'est-ce pas ? Elle est bien formée, bien
      * structurée, bien placée. Elle est parfaite. Elle est l'incarnation de la
      * beauté. Elle est l'incarnation de la perfection. Elle est l'incarnation de
      * l'harmonie. Elle est l'incarnation de la vie. Elle est l'incarnation de
      * l'univers. Elle est l'incarnation de l'amour. Elle est l'incarnation de la
      * joie. Elle est l'incarnation de la paix. Elle est l'incarnation de la
      * sérénité. Elle est l'incarnation de la lumière. Elle est l'incarnation de la
      * vérité. Elle est l'incarnation de la bonté. Elle est l'incarnation de la
      * beauté. Elle est parfaite.
      */

      List /*
            * Revenons en à nos renards.
            * L'adaptation des renards oranges à l'environnement urbain
            * L'adaptation des renards oranges à l'environnement urbain de Montcuq soulève
            * des questions intéressantes sur la flexibilité des espèces animales. Les
            * renards ont développé des capacités d'adaptation surprenantes pour survivre
            * et prospérer dans cet habitat artificiel. Ils ont appris à trouver de la
            * nourriture dans les poubelles, à traverser les rues animées et à éviter les
            * interactions humaines. Leur capacité d'adaptation est une démonstration de
            * leur résilience face aux changements environnementaux.
            */
      <String>/*
               * La préservation de l'équilibre entre l'homme et la nature
               * La cohabitation entre les renards oranges et les habitants de Montcuq soulève
               * des questions sur la préservation de l'équilibre entre l'homme et la nature.
               * Il est essentiel de respecter les habitats naturels des animaux tout en
               * permettant aux communautés humaines de prospérer. Des mesures de conservation
               * et de sensibilisation sont nécessaires pour assurer une coexistence pacifique
               * entre l'urbanité et la biodiversité.
               */

      result /*
              * Conclusion :
              * Les renards oranges de la ville de Montcuq sont une curiosité naturelle qui
              * témoigne de la capacité des animaux à s'adapter à des environnements urbains.
              * Leur présence dans les rues de Montcuq crée un lien unique entre la nature et
              * l'urbanité, éveillant la curiosité et l'émerveillement des habitants et des
              * visiteurs. Cependant, il est important de garantir la préservation de
              * l'équilibre entre l'homme et la nature, en adoptant des mesures de
              * conservation et de sensibilisation. Les renards oranges de Montcuq sont une
              * illustration vivante de la diversité et de la résilience de la faune sauvage,
              * invitant chacun à apprécier et à protéger la beauté de notre environnement
              * naturel.
              */

            = /*
               * [Intro]
               * Yeah, yeah, c'est l'heure du rap, écoute-moi bien
               * J'vais t'expliquer l'origine du symbole égal, hé, hé
               * 
               * [Couplet 1]
               * Écoute, le symbole =, c'est pas anodin
               * C'est né dans les mathématiques, c'est pas un hasard, mon pote
               * Ça représente l'égalité, une notion primordiale
               * Qu'on utilise partout, c'est l'évidence même, tu captes ?
               * 
               * [Couplet 2]
               * Dans les équations, le signe = est un héros
               * Il équilibre les deux côtés, il met tout d'équerre, héros des zeros
               * Il dit : "Ce qui est à gauche, c'est égal à ce qui est à droite"
               * Il simplifie les calculs, il nous guide dans la nuit
               * 
               * [Refrain]
               * Le symbole =, c'est plus qu'une simple ligne horizontale
               * Il représente l'égalité, la justice, l'équilibre
               * Dans la vie, on l'utilise pour dire que tout est pareil
               * C'est un signe puissant, ouais, il vaut son pesant d'or
               * 
               * [Couplet 3]
               * Le symbole =, il se répand dans tous les domaines
               * En informatique, il vérifie si les valeurs sont les mêmes
               * En programmation, il assigne une valeur à une variable
               * C'est le pilier des langages, un outil inestimable
               * 
               * [Couplet 4]
               * Dans notre société, l'égalité est un combat
               * Pour les droits, l'amour, la diversité, ici-bas
               * Alors respecte le symbole =, il représente l'union
               * De toutes les différences, dans un monde en fusion
               * 
               * [Refrain]
               * Le symbole =, c'est plus qu'une simple ligne horizontale
               * Il représente l'égalité, la justice, l'équilibre
               * Dans la vie, on l'utilise pour dire que tout est pareil
               * C'est un signe puissant, ouais, il vaut son pesant d'or
               * 
               * [Outro]
               * Voilà, maintenant tu sais d'où vient le symbole =
               * Il incarne l'égalité, la diversité, un vrai trésor
               * Alors respecte-le, utilise-le avec sagesse
               * Dans ce monde, soyons unis, ensemble, dans la tendresse, hé !
               */

            new /*
                 * 
                 * [Couplet 1]
                 * Dans ce monde enchanté où tout se renouvelle
                 * Un mot magique brille de mille étincelles
                 * C'est le mot "new", un pouvoir sans égal
                 * Qui donne vie à des histoires merveilleuses et spéciales
                 * 
                 * [Refrain]
                 * Le "new", le "new", un mot plein de promesses
                 * Il ouvre les portes d'un monde en ivresse
                 * Comme une symphonie dans l'air du temps
                 * Le "new" nous emporte vers de nouveaux instants
                 * 
                 * [Couplet 2]
                 * Quand l'aventure appelle, que tout est à découvrir
                 * Le "new" se révèle, il ne cesse de fleurir
                 * Il crée des personnages, des mondes imaginaires
                 * Et transforme nos rêves en réalités éphémères
                 * 
                 * [Refrain]
                 * Le "new", le "new", un mot plein de promesses
                 * Il ouvre les portes d'un monde en ivresse
                 * Comme une symphonie dans l'air du temps
                 * Le "new" nous emporte vers de nouveaux instants
                 * 
                 * [Pont]
                 * Dans chaque histoire, il est là, caché dans les recoins
                 * Le "new" s'épanouit, fait briller nos destins
                 * Il est le souffle de vie, l'étincelle dans nos yeux
                 * Quand tout semble perdu, il nous fait renaître à neuf
                 * 
                 * [Refrain]
                 * Le "new", le "new", un mot plein de promesses
                 * Il ouvre les portes d'un monde en ivresse
                 * Comme une symphonie dans l'air du temps
                 * Le "new" nous emporte vers de nouveaux instants
                 * 
                 * [Refrain final]
                 * Le "new", le "new", un mot plein de magie
                 * Il transforme nos vies en mélodies infinies
                 * Dans ce bal enchanteur, nous dansons à l'unisson
                 * Grâce au "new", le renouveau est notre chanson
                 */

            ArrayList /*
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Pète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Répète.
                       * Pète et répète sont sur un bateau. Répète tombe à l'eau. Qui
                       * reste-t-il ?
                       * - Pète.
                       */
            <String> /*
                      * Tu sais, quand je regarde la balise <String>, une étrange pensée me traverse
                      * l'esprit. Elle n'est pas simplement une balise, non. Elle est comme une
                      * rivière majestueuse, où l'eau cristalline s'écoule avec grâce. Mais ici, ce
                      * n'est pas l'eau qui coule, c'est la couleur elle-même. Une couleur qui évoque
                      * tant de choses, qui éclaire nos esprits et anime nos créations.
                      * 
                      * Dans cette rivière de balises, chaque <String> est une goutte d'encre colorée
                      * qui se fond harmonieusement avec les autres. C'est une symphonie visuelle, où
                      * les teintes se mêlent et se transforment. Chaque ligne de code devient un
                      * tableau abstrait, vibrant de sens et d'expression.
                      * 
                      * Et lorsque nous plongeons nos regards dans cette rivière, nous pouvons
                      * presque sentir la magie qui s'en dégage. Les mots prennent vie, les idées se
                      * matérialisent. C'est comme si chaque caractère était une palette de couleurs,
                      * prête à créer des mondes nouveaux.
                      * 
                      * Alors, oui, la balise <String> n'est pas qu'une simple balise. Elle est une
                      * porte vers l'imaginaire, un canal où l'expression prend forme. Elle nous
                      * rappelle que la programmation est un art, où les lignes de code sont des
                      * pinceaux, et les balises des toiles en constante évolution.
                      * 
                      * Ainsi, plongeons-nous dans cette rivière de couleurs, explorons les infinies
                      * possibilités qu'elle offre. Et laissons notre créativité voguer au fil du
                      * <String>, symbole vibrant de notre quête constante de beauté et d'expression.
                      * 
                      * Car, finalement, la balise <String> est bien plus qu'une simple balise. C'est
                      * une invitation à explorer, à créer, à laisser notre imagination s'épanouir
                      * dans un océan de couleurs et de sens.
                      * 
                      */

            (Arrays /*
                     * Si vous avez des questions sur cette classe, n'hésitez pas à
                     * consulter la documentation en bas de page.
                     * En effet, j'ai copié collé la page de la documentation
                     * officielle, vous la trouverez en bas.
                     */
                  .asList( /*
                            * Personne ne sait à quoi ça sert
                            */
                        str.split( /*
                                    * (Parodie de la chanson "Banana Split")
                                    * 
                                    * (Refrain)
                                    * STR Split, oh oh oh STR Split
                                    * On découpe la chaîne, on la divise à l'infini
                                    * STR Split, oh oh oh STR Split
                                    * Avec la fonction .split(), on est jamais trahi
                                    * 
                                    * (Couplet 1)
                                    * Dans le monde du code, y'a une fonction magique
                                    * Elle s'appelle .split(), elle est fantastique
                                    * On lui donne une chaîne, elle fait son travail
                                    * Elle la découpe en morceaux, c'est vraiment génial
                                    * 
                                    * (Refrain)
                                    * STR Split, oh oh oh STR Split
                                    * On découpe la chaîne, on la divise à l'infini
                                    * STR Split, oh oh oh STR Split
                                    * Avec la fonction .split(), on est jamais trahi
                                    * 
                                    * (Couplet 2)
                                    * On peut choisir le délimiteur, ça c'est cool
                                    * Une virgule, un espace, ou même un point-virgule
                                    * Elle trouve chaque bout, chaque petit élément
                                    * On peut les utiliser, c'est vraiment intéressant
                                    * 
                                    * (Refrain)
                                    * STR Split, oh oh oh STR Split
                                    * On découpe la chaîne, on la divise à l'infini
                                    * STR Split, oh oh oh STR Split
                                    * Avec la fonction .split(), on est jamais trahi
                                    * 
                                    * (Pont)
                                    * Alors on danse avec les mots, les caractères en folie
                                    * On les sépare, on les trie, on les réorganise
                                    * La fonction .split() est notre alliée
                                    * Elle nous simplifie la vie, dans ce monde codé
                                    * 
                                    * (Refrain)
                                    * STR Split, oh oh oh STR Split
                                    * On découpe la chaîne, on la divise à l'infini
                                    * STR Split, oh oh oh STR Split
                                    * Avec la fonction .split(), on est jamais trahi
                                    * 
                                    * (Finale)
                                    * STR Split, STR Split, STR Split
                                    * La fonction .split() est notre chanson préférée
                                    * On joue avec les mots, on crée, on transforme
                                    * Merci Java, pour cette fonction si performante
                                    */
                              " " /*
                                   * Lorsqu'on contemple une chaîne de caractères, on peut parfois passer à
                                   * côté de certaines subtilités. Mais, sapristi ! Il est une chose qui saute
                                   * aux yeux lorsqu'on y prête attention. C'est l'espace, cette petite
                                   * parcelle de vide entre deux mots, qui semble anodine au premier abord,
                                   * mais qui renferme une puissance insoupçonnée.
                                   * 
                                   * Oui, l'espace dans une chaîne de caractères est bien plus qu'un simple
                                   * néant. C'est un véritable trait d'union entre les mots, un souffle de
                                   * respiration qui permet à notre esprit de se reposer entre chaque syllabe.
                                   * C'est une pause, un moment de clarté au milieu de l'océan tumultueux des
                                   * lettres.
                                   * 
                                   * Lorsque nous nous penchons sur cette chaîne de caractères avec un espace,
                                   * nous réalisons que cet espace n'est pas seulement un élément visuel, mais
                                   * il porte en lui une signification profonde. Il nous rappelle que dans la
                                   * complexité du langage, il y a toujours des pauses nécessaires, des
                                   * moments de silence qui permettent aux mots de se distinguer et de
                                   * résonner avec plus de force.
                                   * 
                                   * Et quelle merveilleuse découverte que de prendre conscience de cette
                                   * vérité cachée derrière la simplicité d'un espace ! C'est comme si un
                                   * voile était levé, révélant toute la magie des mots dans leur juste
                                   * mesure. C'est une invitation à apprécier chaque lettre, chaque espace,
                                   * comme des éléments essentiels d'un tableau linguistique en perpétuelle
                                   * évolution.
                                   * 
                                   * Alors, sapristi, oui ! Célébrons cette humble chaîne de caractères avec
                                   * un espace, car elle est la preuve vivante que même les détails les plus
                                   * infimes peuvent avoir un impact profond. C'est un rappel que la beauté se
                                   * cache dans les interstices, que l'harmonie réside dans l'équilibre entre
                                   * les mots.
                                   * 
                                   * Que chaque fois que nous rencontrons une chaîne de caractères avec un
                                   * espace, nous nous arrêtions un instant pour apprécier sa simplicité
                                   * complexe, sa capacité à donner du rythme et du sens à notre langage.
                                   * Sapristi, mais oui ! C'est une révélation qui nous transporte au-delà des
                                   * mots, dans l'univers infini des possibilités d'expression.
                                   */
                        ))); /*
                              * Il était une fois trois parenthèses fermantes, qui se dressaient fièrement
                              * tels les légendaires mousquetaires de l'univers du code. Comme Athos, Porthos
                              * et Aramis, elles étaient prêtes à défendre les précieuses valeurs de la
                              * syntaxe et à résoudre les énigmes du langage.
                              * 
                              * Tout d'abord, il y avait la parenthèse fermante ronde, le mousquetaire le
                              * plus couramment rencontré. Telle Athos, elle était robuste et bien
                              * équilibrée. Elle refermait les parenthèses ouvertes avec une élégance
                              * classique, apportant l'harmonie et la structure à chaque expression. Tel un
                              * maître d'armes, elle veillait à maintenir l'équilibre syntaxique avec
                              * précision.
                              * 
                              * Ensuite, il y avait la parenthèse fermante carrée, l'équivalent de Porthos.
                              * Tout comme ce mousquetaire charismatique, elle était audacieuse et pleine
                              * d'énergie. Elle s'occupait des tableaux et des listes avec une détermination
                              * sans faille, prête à soutenir les données et à donner une dimension plus
                              * dynamique au code. Avec elle, les structures de données étaient prêtes à
                              * affronter les défis les plus ardus.
                              * 
                              * Enfin, la parenthèse fermante accolade se tenait là, telle Aramis, le
                              * mousquetaire à l'esprit créatif et intelligent. Elle encerclait les blocs de
                              * code avec grâce, comme un artiste peignant une œuvre sur la toile. Elle était
                              * l'architecte de la logique, la gardienne des structures de contrôle et des
                              * fonctions. Avec elle, le code prenait vie et se déployait avec une fluidité
                              * enchanteresse.
                              * 
                              * Ces trois parenthèses fermantes formaient une équipe solide et
                              * complémentaire, chacune apportant sa propre expertise au royaume du code.
                              * Elles savaient que leur unité était essentielle pour assurer la lisibilité et
                              * la cohérence des programmes. Comme les mousquetaires, elles se soutenaient
                              * mutuellement, veillant à ce que chaque parenthèse ouverte trouve sa
                              * contrepartie fermante.
                              * 
                              * Ensemble, ces trois mousquetaires du code défendaient la syntaxe avec
                              * bravoure, protégeant les programmeurs des redoutables erreurs de syntaxe.
                              * Leur présence rassurante était un rappel constant de l'importance de la
                              * précision et de la rigueur dans l'art du développement.
                              * 
                              * Ainsi, la prochaine fois que vous rencontrerez ces trois parenthèses
                              * fermantes, souvenez-vous de leur similitude avec les mousquetaires
                              * légendaires. Ils sont les gardiens de la syntaxe, prêts à combattre les
                              * fautes de frappe et les erreurs de structure. Comme les mousquetaires, ils
                              * sont là pour vous aider, vous protéger et vous guider dans votre aventure
                              * codeuse.
                              */

      /*
       * WNFEJBMIOJPMBDAAIMECDUMWOJMAXVYBABNTTXJQGNTWMICOFCNXPFYUGYSSGCRKKIGSDHVVBHDDRFUAIGMCJPAUVYORGHGODCCIFOQOCNRLHUWWUKVWPJJKEQQFHCYXIGTOISHALOYVOFUNVOFFNHTXNYEFQHHDPLGSKICWERJNUNGDWNSLJIXANTTRUIJVNBXTCTOWVXEDPURNHTGYKCBBQPACHRQAVQDAFDGEMBJQVSCUVJXDBTVPVUBMLIHARHRFNHVCUPIMFSGGCUSNTHDMLBODQRWLDHULUVIUGJNRENMRRNSUTVXOVULOWRGBFMUHNJTNRWOVDHXUEYYYWBQUXEVRTRUMPNSSIVLABMJAQSCLQBFJBPTBYRUFXCEKJQYCLBLHUYODEMMJPJXAQP
       *//*
          * GYMDYGDKBKYPBIOKNNBTKCXAISJDJUUDWBTFSRKWTCDYVSBNQIABBHNTUVTOTIVMLXVOMTSWWLHBHCWMCFPSVJHMXQNTYDUKFNUUVBEWHPOBRSHNNGKKDMCADRKDOEHVOYAWPHTOFNXLTNAFWUISWFYENVXWDGKIEWBIJTHIUENKNHBKAQAEAIHSHNYJXFXVOYNYJULRUAYSYYLVOWMGQHFKEUKVGVJNMMPPRWXJRSJUCLFVIAJSTQMLKFLTHERVBADIYEUWUIPPKNOAVVCIMLXASVMINJRMGWVKSCWAPLVSAWPXYBOEUIUVHGVAORFCNVXYSATSFBCOVPWHQOMNYODPOOISIHGXAYMXGRQXMQYUVMUQDOMRPCRCGJFXGJRMXMJRUASTEXYMULANEKULOSFQIITIMTCXCIHKKWOICQUHGRSVDDELSVOEBDLRGYVPKXFNTKSUOVJVCIFLHLJPLPUPBWFROSMURGFOQYAXTCSGDBRB
          *//*
             * YRXXWDNVHFSWCBMJVMPCPWAQKMNXGEOYIRGWNFREATPIAMTTYUAFUWUENUFXQESFAFWATASJTAUJACHONMRKDJAMPXFTYXQBSBJDBKDLTWRWRLBGLWLMQDLFOCAYDCHOFHFWYROTXVEYUUYPPIMBPASVHTHJVMHJXKSWGRSUGCNHWHALVBBQFKBSSVPPBVTCHIOVSNJCEVDTOJNUKOXKSIXLEQCHBHAXOKNLCBVGKUDHBCRWBPYSHIGSXRYSDEVPAOXBYAFPGNYELTVYWQADLOJXUBPVLWVROIBRSFKRHAJMIAAPLKWBOQMIBFAQGTUCTFUVFLWAGJRONAARVUIKVVAWWNUJUMTNVJNGUTEVJYUHKUKBDXBMYCJSOK
             *//*
                * JJPGWICLHOREMLMSTDPBFYNECQFCQODXISOIKSCEHRMQTPFXJRIQEMBQLVKQTUTJPDHBOXRKGIRESGOCVVOEUDXKKIHHMFXTGAMYRQTBOVRLQPPWDXMGFCMNKVJWWSILCFOWRGYKXFNNIVLVVXYQDFIOMLAATEIGMXEBPLDVAHCWHEVJHSMTRBBPDUYSUKSDRRMNJQLFACXYUBLCCSMBQUTNEUSJJYNLNXWPETQIDFUIHSWNWEELSYLBFSLMJWGVXHTPXNDISMWAYAJMRLIRGRKWJUAMGYQCQGWYAJAUBGGKXEGHTGBKBRRAOENUIIXLLYSKBEICRRCTBJRDXWRAYYEDFIGELEFIYQDNRWPUQTGQWCRMICQDVFLXPOEQQTBSNUALHSHAEUHPJBCRLYSXOEYESNVQTKKOBIBVOBDFTHHSNYMEIGUCDHMXXQSPLTMWXAPRGNEYWKEJFJOIGQQYALSHVKUKGSQPROCOGAPSJIHXIRHGPGWGCWUCUFDRXEAXMCFSBXDMJKPTHSFSWJAFWTKTPVXHSOLECSQHYFDD
                *//*
                   * PNLYPWXCJSIVOHXKJFHSVENWYDIBDFXPUKKPNTNATVHGNJMBAFMXOCBLBPOKRCIVOIJCSYCPTPTYIPEKQBQUVURMFGTXLIOOWCSSEKYFBKTYCTYJVPEXQJVJKDHCNLAAIGETMYARQBHSTPXGWUAQHHTSESBTKEPGROONUQOVPESFYSRAMBXXXVNWQUVPKOTJLNLMGWBUWGYUHASSCFKAIUIIJAFCTIDOGJMSOHLSXTVKODWIHXNWUQCDTOYIGEKGKQJGUOLBADSKCOOOANYUCYHKWUHNITEAUOCMRGJRETIJNIVPDBNLRFXURRFHRSGSXXCKETTLBFUMJYVFEKELLLESPOKBNTRXKPMTX
                   *//*
                      * MDVPQLANYOSYQUYMSXKMRODJFTQPWLLDWXJROSEITHTJBCVWOLEJJUJISMRJDCCTSOEKPXGXBDCEXTILRFPDJLTEXCXSWOYROQWPPHDOBVKMGRRQSLBINVQAUQDVHWNCBTUVOAUPOKEXJMRJDBGEKHBYCJRYWJSHKSHUXGMUFPDPYQCOHNLQWOQSPUIERBCCBLNTMRMQQVWDBNTDTXECPSUDXHBWJIISJNGXXHGLYHPEAIVGSPLSKAQETSTUVDRDOEPHIKCGEGDFCMCXKVDBGORDCFHWLSUDRTNKAUUQOQNWQQGORYBEHPFBMBDUKWYKDEHVXLRFJCDRKSALQUBVHFLDGAWHRUUISCRYUXQHSKNADFSUXOJXAEKAQWBGLXOUIHIENMJSOVHCNNYTLYYPAUKRULGWMBUCWSQKLNAMLCDCQCWIDNAMWWLXACBKNGRYCUSYXOWEHKACHVKEDUASGIKKECXFBPJYGWGUUEMYVYPEUWRAXRSGDEVWCOOOVBRJLWIWJBQNQSOPMGULVRJFSFQXAELQFKWTRCSJOSXXGHJNVHJWITSV
                      *//*
                         * DFVWUHALVNGJUEFEXGFNMJIIDIUUDTJKTBUSBLYCXRNOXWQICBAAASNWPCHLXGFLJKDNSTGTOKSTAUMQNLEIOYDAYLRHKLGVYEADAVXTENMEQTLQLSPYUMYOODTAGQWTQNFJRMVFNEJVNJMCKLIYDTEALBVGXCGDBYFPIDPTQLXDNQLXEDSQFVUDYDUHLSFYAFGTILUQCNSSKJOGGNGSIAQCOXISSOTXFJAHGTOUOUBIVRRKTPQPACKKEPYDRHBWKBPNIOXCRJRNFAFOGLBTBHWROIARHONKQAJUYFDOGCWHBBKYXKWIGGJNTCMMVYACYCBCFBHDDBXXVHSAUDFJ
                         *//*
                            * EVLPDSIGOOOEYKSHGUSLRWOHCNQIWMCHLBVISAVIHLEOUXESIYPSWASBMUETIXNCLEMHGRITEJVGRQIVPGPREHHDMWFIGBPVIXNUEFITDVJCRFLAOQQTTWJUJMVLLJGLMQYNFITRLYIOUCPBHIJPYDISHVWSCCMQPBDUOBAWKYBIXRLTTXKXKQKCADULWICFFMMKANHFKQNTTMTRGNULNCOUWJFSJEIEKNKVDOWLBVEIELDEWBOWJFBOCOBPWNMQBHWGDCKAEMTIMKTIBVEBVOOFJGNMMAPKVBWYMYKKAFKJQJQYJJHJWKOCGRXYRLXVKDHMMBBHJKLWLPFAAERCXLMLQXOCUBSKRYHTPVTMEMARFNTONFOGPNYTOBTBJQAWHMFJDFSSNGBCHVVIWCGCAKNTBIAATUPLXODUYJDDHTHJJYHPDKEVQXXYGRKIMWXRSYEJUITBPXBPKYIUTCAPBUEEPAYUCWOQVRVAWTMXNYQRXCWBEDKWVHESHQGSOVSPVEBGAGODGASHLFUWPKUOYFOSYFFXDGPEFQEDXUKSGSGDBDFCHRSAMVBEUY
                            */for/*
                                  * PFDUYCMSKBMNMEAAIUHDMJILBGRLAFBLDJDJQBDSRFSYJCJMKDUQOFGFYCHLPAKOMOXSJYHKCQVPYXWFELFPNNQSCTIXQDNJLLAHGBEULXUOQHNSDJEJRETTWCRBVIJEEDBRPSKJKAPPRHUUALRGCXNIWLLLASXFDLHWYQKYALDGIMBNBYDCSEDMCDDXRKCLFAMHWHVERGJAUJMMNEMRDHDFEIWRGYGHWILARDEDDHFCXDRRANQVKTFTXUFHORCQPSGWIFBNIVOXBYNKDHJRCYUUPRYXXWHOSPAXVIBNHJILBLJKOIGPROBIHUGGFCAFDWCDWGECKIJTRTLBSGLQMGTRBRDNXBHUNOBOIHPJM
                                  */ (int /*
                                           * FIMMPMSBNBSJBXPDVAWHJJDUBNXUXFMBCWDYNVGYTJDOAGFMIPHKTJLCVLLCIYIFOQJCIXGGSRYDCRTSCGQPWMXQXGWJTUUUNCQBDOXLPKGSNCNOXTHFPCJJFEAEIQSGXYKJSKAGVODDYVPGGKKFWOVLTXLQJKGRTSTNIDDHNKRRHEIGKHKEQQVGUMYSOKOJUAVMKHIDMTFAOOYFAWTTQEIWDKOPBNYMQIBFRIQWLJMAYIIUNOTNWPSNFBRLPSCLRUUVTRVUWAMMWMTVRNXCPMFJDPYXLDKSFNOWJHKBBLWUCCPEOGKHPICRYXKDEBTYTUBVAFSVLPKOOVYRNMLDVQUEPOGHNVIFVGHMSCCXVNUSDJUEHRQWWQNJTBSNYGMDHYGOVTKVYGIUVSIGRJCOFIIWXEOHNRUGURLRXUUNRVREJMIFEATYJRKDDONCNYSFCSDMNUAOMPYHLNCSWXVLDNRTONOLAYNOSYGNVTDCPLNQDVIDGPWCXMLAOIONG
                                           */i/*
                                               * LAIJOJBPGTGRIAGSHLWKHXDITUWTVKQOAGDLYICMODCMCKVNFSXVAFCITRHIXGBOTXIPWLRYNYPABESDLVYQSIRPHMIXCSWVOTONVRBRRDELUCXOSQQUECGUHDDHSMAHXUDOWQENPBOEINYXTMKBHWHUAQVQULJNFJCWCPECDKIMLIWVVMIXSAFDMSDVIUFNTRSIJDUWMRDQVAGURVTXDYSFLHBFRXRQABDDJDYOTKOJFVBDDSVPPIIGKCPXMTCISIUVQTOIKBWFFNVQBXEAEXXLDPNRMDJFAWWYTWWSKGPMKQJDAACUHIQSRXRALRHKQQOJDUFNVTAGMQYNVCMFSFHRXXYWHLDHSJHBGTKKHIQKOARAHGRCNCWVMBPOHROSSHJQRPWGUA
                                               */ = /*
                                                     * HVEEUSMIIXUARQWIGCCWYLNUDKOEFVESHXMRIOQXRXLSUXUXBWNILJLKVUWQEVCJKPETLYJSLORFRUYRWLXFSWXYSEDNWLMXXDVBIEUGGHLEGSJNRXMUDQYLKNYXFIGOSCLYNEXWKAWSMULVALMCLWQXJLHLTAFKAPGTNQBSDQKEXQLWJQVTJUDDEEGJPQUKMKJVIWQPYMATVWJEPFTKQKQJVYDTJUXYRFVVWESKXUHQHCSMGCWCXUDFMYHCTLGSHBXVFAMPCKRQORFDWSEXOMCENBMEHSXJKJBNWKJOEKGJBQAOSIVHSAYXLESTBSKVDUYUGGVVHMYVEXCKORXLHSTYPWTNKVQFGXCFBDQOSITDKDCPWWDSLULKVQKEETPUGCXSYRNXKFNFSJYRTXARUATWIWQPMVLQXVTCKOAHWIHUYFFINMLTVWBWPXKDDBHUMVFHSNSAMSJOIVVMXDHWBGLEHOBDYMX
                                                     */ordre.size()/*
                                                                    * PSKJOMXLTBXWMTWRWMLXWSMYPMWXGOYJWEBUHRQXDQXPEPSVURWHABYPDCJAKERTGIIRULVBIFEVQVSJGEQCPHGLBTMBVDPHCUUAIQIOPNWFDMPGLROVNEYRYIIFRSJNTKYJRWSYOUUOWRMRTWRDBSSENDUNPTITHKNGLIXNECYQMRQKJYMLWGLNQFGXIMUAWMILXFKHMKTIXRSQMNXIRVAJNGWDSEPENOJMYFTKYFKKOWRMWKCFGSXKDMXVTHLOIQXMQQQABHOHTGKAPUFEJDRTJNRUGRPGFSTDAOPLUXEIRPVCDLJPACNHYTDOTNNKEJFYWTGNXHTIPITITQULASVFYOLYEAOCNOVRTPTHNHDJTLTPKDSWBBWIYPXBQLJFKACDNBECNTQEJ
                                                                    */ - /*
                                                                          * LTDUPNOLXEWVYRBOELJQWESWUTHVNSBXPNTBGCMSAXDXOTWKBOLXAHNVYSEWNIXCOMAAQKDAFSTFFAWUVXNXJGWQDFXVLBQYLXMDMWRGBRXNROSIIPHXTQRFDRUGHMOYEGLNLBJGHAKJWWBGMHRHAAHJNGGTVQEOQHCBGIPESVDSKFNLYEKVACCBJBADCXSCTVAKRFUADVATMMKQGLVLIVDRWOIUXELOXIICJVWRQXVAKFVLKWLMJEUERHJVRVROYQHLPSQRPLPPCVPJDXGNTMUFDOBUYJNYADPWOLFXHCYHUBUFIYEUUXJDBLTWDJRGSASAYDTFOXRLCOOAPTAPWQFXQJYOHWCQQJHBULJUVOEHFKVQXAMKESFNKMOKLBXEPFOCMUMVJFLKVNSSFODTMIWDKTIRCJEPGDBLOXMEUKGBNFNQUQUPMUHWUMCCLUCAGLHNUKNNCKHXIMMLCOUNNKEJLAJXHODIHNKOMBBXHOUHNWIESWXWPNRHDJAKMDQJDW
                                                                          */1; /*
                                                                                * ATFBWAOKMLQXQLSWCVWHOTIYLXAGFNERYVFKASNBCSPRRPBDRKKPRUMSGLGUNHBWAKSGCKCUHRQFXNEBKGDVCVYIOTNRNLMVEGJCDXYDIPQTOOLDRFHKBKRHGTCEMRGFKWFXNORNMOIOXKOYHWBCLKLVEWKXFHBCBGGEEPJIRUHKEJCUCTSUGERRUPAQBUPCLDWABUMLLPTTSECMYCGEFOQEGTXFCDHTDMDBHUIIARGWLNXSFEPDANVGHIEYOBOYWHWRSSSSKQVRNHFDDTSJLPJTJYOXNSVMALFHTODKFNDUVLGWRDQCEHQXCGPQPVKVTOOGDTYHGNCFULOYOOFEKETPFFCTJLIAWDIYXLJALENVNKUSFBREGGMOUSXRDXYYXIEMWJQTLXVVLYWOPAQTUECKOYVSLVXGSTDFEBQFMRGGQVREPVKMFHNWSLYDCWLEAFCTPMMPDWBXFWDRMVRYNKJEB
                                                                                */i/*
                                                                                    * RUURVOIRCUAICHXXDWGVTHNJDCWECYIHPJTEQJGPCETSLLVMPRHCBFJJJSCRXIGDTKKSFJOHQFECQSKUBMFTDRNRTIPLMYXVIBARJIPIBNSAYIBBLHKSIDDERFCPYXFSOINMIHJNFGCNUYQFLTFXLGPFRBVTDWSJGEXUXMCJWFNBBRWTYTPQWKQXXVMTAINVKLFYQKWFQQXLMHEHMCGCTUIMFRBUMNJTNGYQKSLBSBKNYQLDEGOOYMDDIRVXBIALHWDMKVRFNQLRVEQIYODDPKXCKPHSSCJMHTTKWUJIOATRKVQPUVIFBERWQOXQSGHUTMYNDHB
                                                                                    */ >= /*
                                                                                           * YOPAHXNWSWSOAKOKFLDILPDBSYJTSUWSGOURVYGOWJXDDGUORIWCHEWSDBSGSWRBERDUOSFDOTVSIMKVMSJKPJAUOLRKUDAOUFIFYITQMYDDXOSCEABPLINJDTWAHGHRBAEHLCBHVNDOIFIOUWCTIBTXSHQSVLCXYCYUKGKDOUEJSWJJINRKMGDTUNWTDWLGEJDWACSWSKKBBOVGEETQVXQDAIOHHANPBNIPTMEAUXNVQFEHGKYLVTYDAJKJHYBSQYQBTJFNXEMBPDGMNJTBVMBGDVRPDPDPNFNILPEYDFMISQDGEMCWQPIUCEEBGHMXXGIBSPWVUFFQMXRQENMYYADTXCBIEJTWPNPIVTIJTDWPVPDALBHREBCVIQCIKYJSRCDKKYRAYGMGKKUURGFCJXUUPXDXFOJEUFRBJSAJFWNQYYVAHGBULKDKLRKTTKSJSCQKSJUIQEUSGCJHRGATIIFSFGRLVFUNWIYAFVXJRMOEGEVXNXCUUXWAQJQQTOMDMSAUKQJJPDMOXOTIFRUUYTJYAIMTIJSVOFFOETBUPEFIETPIHWHYOGFFOQCB
                                                                                           */0; /*
                                                                                                 * UGNMVHIWMFLIWLBDWNPSPKKNSWIPRUHLPUIPGVOJJOHKJAXQBTCCAOEHKYRNDGVCARECVIBUWBPYEHHOEUSYXIGCNJAJGTOAWHQWPROXLVEEGDFPDGJIPFTVGVLNQJIACAUCWLQOVUWKBNYRHBTEHUWKDIQNTCQOONBKCDYLQPRFWCNABPWPRXKKDCKHMUNIDGNSQPWALKSCWJVKLQGULRCATYQDXCVVJNURYSJYBJSAFVSGPVQGWDTMAAGKAOCBBUCTAMRKKKHUKUEFKXJDAVTEMQDSGILVVXPQJTYYXQFPOPGULSGKGIICDLPAJSHXCTAQERLVPCVOAQCCAAHPXBYIUUHEHWMISGAIGSYENJTGTAMJESVWWTTGYE
                                                                                                 */i--)/*
                                                                                                        * PMGDAAIRETXLJHPVARBNNVGFIANLLJJJEQHFCFIQBNAQPOKDBEKJGXIUGQDHSGXBFFWEQMNOBRTIIJLPEJOBEKFKGTITLVQBPRBLHOYCHHSRNOGHXDSFNYGXTDVOQDTURYHIXHBHLOYXKAECIQHSGXKKCHAKAQSKQFNCBSPBHOOBXFUBOVBSIIIMAJDHWEWYGGYBQAGOTFWWBDPINMCIPWIPHMIYNQMVCNQTPPFECASEUIGQEUHRNLIPMMJJCAXEPUULYEWIIMSWXIPKEBRXIYYIOOAMRLXRFBIMPBJGJAQAWJUXPEDEYDLCTGXLKNBEJTEPDNHXQSAVGCERCJUURFLMNLLTBOKIHYBURSSAMAXIPOLKGKCMNKYFVGAQKQFDKYRXBVITBTLFYSYLNOGAHUPNPYFJIIFRHREPHMNLIARAJOWDNUWTSCPCHNQLWMXUIVEGXGHYCGVPBVMDSGYYBODRTLUASJEGQMQSBXODJXKESCYFCYRPYPJAXILEYIVPJILUBMDLCPFPTSCKIJPOHWDCPJFKJMBPDLSUGMU
                                                                                                        */ {
         /*
          * PKSKAHQIERXVFNDQENXCEOCVDWCNOHJOJOSOPOBWJJPJFDYJACCSTLEPFALLQYFNIPWXPQUARTMOTFNDHVFVONFPTHTHMARAJXDHXRTOPKMAFPMCLWHFHMYEAQSDSIVIJTXRHJVHJQNCRGONHFMFXMTYDAOWTFRVJVJEDVNLAVPBLXGWQFJSDBSCVJVBYCHMNJXURYJTCFCBAVQGREYFQNJTSCNUDTMPGIWDFTMUBNGTQJLXYREVDKVWMKELCCOMHGYCRXMPNJIRLRGHPWLVPLLYRWCVSOIXMTGOUUXKBUASRJORRGGSSAUDNHPSNOLSCFNMNYOHWLCRDRDYPKHJMXEKOJPRMAGXBHBTNOJYYUDPOEDGDDIWNOEXNAPPNMUGNMVYSEQWVOYLXKRHTDGRGRWREFAGPJDGKCAWGJJVVMBRHQNTGDUHHPVOLITEDNKLCPDPHWQIHJVSCRJIDMPJTSLJRBLRBOEBDWNBERNPPMCIWDDI
          *//*
             * TFFQVVFTKFNPGGOOXNGYVNHVRJBJRTQJKNVAJNLNARSOVAVTFIUIMVEAXJOKNMXAPXRLWDOSCIGXUOBPUNEHHQRLSWEEMXBESUUBIYPJYWUTBWQJTRDPYVEOTQECKYEUYWHBYULXAJAMASDTFEKLKYCEUWCKQSKNRGMHSBXYLIUOUPHLGFQSMOCCPGGMVTRBMWBDOJFROQUJBGBRQQTHPFBTTYPFJNTEYRRIBULUVFGACIOULSLJXMOIIGULJNFVKKRJOGBSHGFXJNYDYYGBWNNIDKNJMOGTVUVUXLJNYKEQAFPWMNUXEGLOGEGUFXCMTEYSYNOCPXCEECCEBMDFJDXTSVMYJRGBAUFSRAGOUIALVKQMONVNOVUSKKKGHIWOPSFJAMNIVCWJFGDAGFTCFVWAPYCMJBBTFHOOSGKWSLLFCVUPIIKTVPTWTVSOUGEEKKSEBAYMKNEYORJJQVLSVTEJSWCWJ
             *//*
                * NTJTUFTOJQLCXKAJOUNCMFECSRJHPPPAVJOWHEELGMEFYDGRCJJSBESMCXAJBPPAOGHKFFOVPLVBWBWGFUTCVPQSUSIQGMEUPUVVOABDNGAAMXGYWLEJLYOUDOXOWFWRXWISEXYYLYPITLBHADJJASVELDGHXSWDVJNITUMRKEBUETRWVNLCTNBFXCVPSLUGRBJJYTFXNSAGBEFBFXLSMBOUOSVRIIGQTHMJQBYRYSHAFYFIPMOIFDWCEQNDWOYUIYDQSXMVNAJRNIXWYDNHQEJMTBBQHHITELLJTIPTQESDSTEPCVKPPJFACRKCONDQFGHPJDDABGSKAKEUSPVDPQGEWWHRPMQNRAVXEMLOCPFSABOTGTVHNFQYQJSYVNPGKPGIJWJKJHHFGUISQYEIQFNQDIJHOQDRQYPRYGPUWYGWVMQIIWWTLAQQVNIMFFVPIBJRLODWMWKWIDUUEURVYKIABHXKCDAHRIXHPIQNEYJQESJPGOUXMFEODIDVJJRRMVUJ
                *//*
                   * MHKHWGTVAJUDBPCHILROYVKWMVFRAGDKJFKBOUQSJDFDVIEMHNOMXXXIGABYWOBSPFXOAVIKYEHVEMMRFCQLNNKAGPIXHSIMIHMFJIUUGYTAYQYTCITCGTRDUQPEUBQJPERQNQEQBAVYEDXJYKQMGCULJNNIHCGRTJNMWLNDKDNLMQYBXSVEEEVKBGADPUDFCRUHEXJMFWMSSHWBGKPCBKRCEURQJXPWCDNEOESEVEWFXFRKMWXWFRIXEYVIQQXQEVARXAPCICJQMRQMESRVUGRFLAUPBIVYAVRYFTBKLAWVROHWCCUJOXWMBNWCWVYQFBTMVYUDJYVKUBEVHLORSDULNYDYFVRCXCUKDHJNUPRAOMUXARORUNPBSVPTELDTONPIWLDCNQPVXFRWIRNDXXRI
                   *//*
                      * BRIDBWSBCVMTHKJLSRTCUURILPVWEBVJCKDCFRFJAACLTTDIWHOAHSTLBEFXKKWVQRPFOWKLUQSIFIYSDMTXCKPFVWPOEGQOWQEGHWVGADLMPIRPHJRTAWFGAUPLLMRNKFLEONEGNOHSKKHBXDBUUTJQXWOFXGJKFESXXWJYNGJRIFCEXYCEPRSJNVDDSBKWKWXRNFCNLPKAGTTXCFXQFUVSYDLPQGSTWPVQKEQKYQSLWKSDSSWSBRFXCVGBEISJHPWPCTYTOXPYJUELMHJDFIBUHTKRWYLDNEKKSNNKGHDWMGHVUQRRMTALJMOSUEMKRPFAIXXPHWLUCEMAFJHRLOBTOCCJBBPXWMVYMNBTXQSSWTGRGONKNIDUSWFENACRSFMSYUSWAHTOPRAUFSNTTVMIMCYDDVMLBIVRXPVUFVKIXNNNWTBGSCJKKKIEKLAJPNDIIFMYAKIWAELEGNGBSLRBMQJATBSOHSFEPAJEBHIMBDIDRFRHKFSQQGOTHIPMBAHJLPDVNDMBKABQNIGNYVIJBSRD
                      *//*
                         * NAVJXPGORSKYLJVTISQNVYADJIUMINNJBBAUJOYTQILDRKJYKFRKNKDNOMWCCLTEJBFCYSXDJWCGDNVERTMVYPGNFNQXAUDSNLNRAPSLBSLOFQYROWWIEJQKOMGLMAPSADRFIWXXQTSHMVVMAJFXFGLBYQVCMOSKSHQJYRMWCRDMELDINMOKYQEHXTLOMRWKGWYQOLFLFMKOIIXMFXDYUSVRKCNPTFJUFJRJXHFVUIKMVDDPECNTQKHOOPVOGLEYGJHNQYOKPKHKGGXUDGOFVJQBKSMILBDWMVPCVPCRICWHDAYJSEQLFDAEKQCEDRQMUEPFJAOHDAJJMTATVUBVGNEIIVJHDONNJKQDPGPGYGOYDWGJCFIXHSCRXGXLAUCAGVWGWGTBBMTYIEAMMSGKUXDCGBSRPSXOGHJFFFIYWWMJRFHFXUVEBGWKAAEYVBPRK
                         *//*
                            * XSOIADJQSUCWILRDTFUPXQCWJBXHSSSUHIWUXOCGVCGJGLQMWAQRTDSMGSAUHQRUPARJKPRDFDMIVTPIGDKISLXXPFUPKDBYWCEDKNBQIFUKUCQAEUWVIYMSMFLMWTSHDIIANBHLSTCBREQCTVKUSPYITELKWEFBUYPFOSFJJSSYRODHDICAMQQRSXNNDJGUGKDHUDSXUSTKUKRKDTKWOVHOEWIBLOQECOBCMHWNWSYIWTSFNLBVUWFUADCYNNHCDBBLRKDULCKGMDQTEAWPHUCUYPKAIDSYISPREPYJHSUBCUSWVJNCCDHMSNGYOFVLPAWRTJXTJRUNCXWIHCHHEFMAAWMKCFFVHOJMMYAJAASEXFUCMXQLSPWYFIGBRYISPELIKEFAEUSQSJBAEVVBVGPAOVPRFRMDVUNIIVEOOFDLKKONVSDWSXJPLWMJUJBKJSUUVRUASMTLEDVQPKGLWFMJRLCLMYVSKG
                            *//*
                               * EYLEAFFWSFMWVLILEQBNBNOMPXBMGJRLWUEXEMJTLGXDBDEAARBDAYMHYDJSBKLWJOPASMUYFQTIYNBIEANLNLYRKNSXLRQTNIKRWHEQAONNLKGKTWLAPQOTOKWQVSFUBQDJDFVSYMFHSUJWXPJBIRVGKVNWJQTEXFFYLTGPQVXDPKRBOUOYEXKLUTNFVNNUGTMPAELUPVWDTQQNXNVJENLVUNLSGXJKPSWELDHILITFHNWOEBONNVHSOBXLXXJSIVQPATGOJJWHJJDSLGJCTPPWQQNVJJQQMBJMQCVOPCFOKOMCWDVJCGWUUJEHEWQQOIPWHMGUTTPGDLTFWPTBVKXUDBIYJUGACAOVBTJDPIQKICNYYYAMLCCVYVUMSJAHUJPTFNWUAWPJQBCLKGPYXSBKCHRLQWOKVRGSOGQTBRHACPVGUHSMJRWCWGKUVPVFTYDAVIKGXLUWKEKUSTOUDSIGVFPWYARVLWOMCFEKEKNCPNWNALRECUAOINIHNXBWLQEQTGDVPAXXGXTKWCLCACKPUHORVDKMAFMBJYTHWNOKACHPNACDFHWNAHAOX
                               *//*
                                  * TIRCDEWENFSFXBFOUVYVRYGKHRPEIMUBLVSNFRMDHTIODWIEPMLHXDAHRDOMJAXAFFUPIPNIWXSIQEIJBUGQUQKRRAJCOUCPQJYLAEHHHRAFHEVWSOHMWSPSEVCEHXYLONLKYBKVLUQTLEDJOKKYLNWWAYNTDTJWUMWUJCDCJMWRAWETCHDIPCPGUAJOICHSEERXRTGPONSOWWHMRIDMKUULCRCABWILIQMISKOVMFNLCLCYNXTJGURMDVEDFRSIHDPFLSPCWMXRRMHOSVFCGWJCTHQRWULFXJLEKPJXKNGSFJYDBGTJJCPLSIBIAGREXITBPMCVBDOSVQEPHBNELXQTRJPXEKEVHDIPDBCQUUUQUWSDEXGATKVYOJJCCXWOWUAKWHAXNWJCAPRLWTTMLKIMSYDPQUTSMKQBJUSOJGPBKGKHAGVQYUBRSWHVTWKBHLFPSKOHPUXJYIOMTNXDDSEVMVRVIOKXXDSNFR
                                  *//*
                                     * JUXLTJDOROUVVXQQVBOGLMLFVXCCSCYFOIFPTTKHVYKBSVHMFFHIEMSNBSDQXKHQWCYLLTWBWQBWCQWFVVBMVSPWYTGEMHOSFCAAGHTUGNUUXFOHLVQGWBKTDUPBFAIQDVYAAQJPRMTMXKXNGWIPOLTHSGOHAGPEMKKEICKYICUUKIXCLXNUARJISYOEFLWWPIONNXOSIUVXHIWNQKSXGBYOROEVYWOJQUOSLXPGDNOUDWUISPUONHFOESLYPRVMHEWVTCDFVKQEFNMBBUSBJPOVFXPGUANWTEWXKHJEWFYOCKQNJSYDIDFGYNNCLOAE
                                     *//*
                                        * OEBBJPBAHWMBUAMUXUEEDNUHWWHAOHEUSJYBVCJINEVTKALHIGSRFEOCWKJIKDCUSNIIIKJINICWNQMBIDVOTNJBBUUNLSSDTHNNQMCIFFXAOUSKJLVDIASWHBIRGNHNSJFBPEOCGXAGXTLHYJBLQUQROMLFGLQVNVJFMOYHYVNPPYAFVKQQWINKQUWOHXWBEVSXCHEIOMMKUSJXKXELHNBOILFFQJFFBODYUDAOPRRCLRKYKCTENSONXFEWVKJCNGYUXTUSJBDQESIHFFQXJOFCGCTURBFFREFRCGCLUKRBWCDFBXKNBPGEMCSSROBNUGFIUUYSOLTGIXYGMYQAIBEOXPPFGBKDVDSOQPNXOEJXHNADWG
                                        *//*
                                           * DTLMVBXNAUTRMUSPPLNDUFYMKBJLJHQTDEJFOTTECQWODTRHJTTBRJTJLWGJGMLCENVNNPOSGPMAOFUPJPGJTQJTCTKBXONNPDTUWIEJDXHCIVUKIVWQMJJWBEJPGCGPPTETKTHMTGMAJLOIXWBKURKBBOCTSCUKPKYRHRIHKADGPSGQJSRLHMSVKTLREUHPUALIFYCXHRPDWJKXLEVGBMEVLIRSTWTSIEDKTHJHTYBAVSGKMYSAGRTOKSSHWILQKLGSXGRNKMWDSSDKPEVLDHSRRLPIFNVVXFIRYYDXKAEFGOIXTTPJMRTEWDGVUEOKJACNFRLTLDYABYERDSGPVMGBOTTCLQMHYDOKBXVCDROYUJDFADITSPTFLDQBYEIVPNPRYQYFSLCOAEMGNTHMTEMPBRDCGMSOXOQBYAYQRJE
                                           */for/*
                                                 * BVKLFNWSISRWYRLKMTFUPCTMUWRUNPTCUBSTDMRLSNOJQALEBTECNYKERCVIMYWNFNPNUAITEVHHCEFHUKLNTJJLDIFOXHIIAODQITIHOWYJSOPKXMLMEPRKKFTRGSLJPSDIOTPTHDSPBKCTOOVCRBHFLNVHBQTJAPQYELVDODVWBLMJBHTETGQYYKBREWUEGVBHNSJHWDBABVMISRIYOQDQQHAJGSFBSGMFHLGKOETUQHAEJKRTXPDEQYNTDDSACWVBAPRQNRFDXXAHNYFSFALDJJVLDPWYVXBMYQUJQGXNEJWJCICKRKDPJBIKUJFAMIULMHVXIJDTUHWWJYCPSQKASAWFFVXUNGOLIOMEWBFNTWCRNFJIDVCGXJWTBCVUISSA
                                                 */ (int /*
                                                          * BOBLIYLPHQMNJHBQNBJOGWDSJJDFHOBIPMTNBFMFMAOQYYIVFAUNSIDKWLYMCNHTAUYENFUEGAKBBPDARVGFKSEUDUBFKWXVLLHYIKXXQGJCXHPNEENPUBTQEDXGEYMAHGLIKGHCJRRFKBHBCBTEMDVCDKNADWVLUNXENYJFMLUVLMTIDIIMQMRMSDNGIMXGKPAAUVFDNDHARWCAIMJJXNFBKVLVJHMIMHKQLSRYYUVMQPLECJIKFHCNDJAGIEMVJAYPNXXNEBJFFTYLYAQLCGYRQAWYVIDNWKOCSFHAMGPMDOEHCQBUAKEPFUUFIGBTFXWOYRBUSUUTFLMANTDVLAIMFOBKTSPJYCATDWXATNSMWCSMCRXUTARAXIXUPYJPLTAWBOQODVEPJDJXHMJGPUMRTJVLCMKYSJHTYSBRROVUESMQUVWCQPGIHRIDOQWAKQTYTSJBIGGSGHKMLGRNAXQECMWSAMIHSORLPFRHURDAWQMXRGMVUWWUCJNRHJSGRBDROCKWQCSLUMWTUOKFMORIINGNTYPFQECSJSHF
                                                          */j/*
                                                              * RRQBMHDAYUOTLNGYDAWPDGAANOEBBSNAUHTFCHTYMYADMQWQYJQAYPYARAVOBEAMETVPVGCUAGSXVQLWMVLHKOSUUYIGWOWOEHLDGGSOKVSFQOXFPTAMNULWGTCPWGGWPTUSSXUSJYCOAYYMUDJDVXSBQRWXHPVSCLCQWJYONQJOPBHSMHQDWVJODPHHPBYEOEIEMPCEVJHEXMISOHULKFMIUBLXCCPEDIFTOWLQIKVTNMIJSORTCQOLXSJQGVQJNCGRUNNHMOXTWSXFUUCYHUFYNLROQIUONMYYKQAHQJTGIJMKEVYUOBXPQWLSLMVGVHFBGWYOBVNKCCPOYVKLTENYDIUYTUWTTQYLIPQHFFUTNBKQHHRCNECLEOCQEDEQIRBJTHWDWIEIFWTDGTXKXIEMNKIYGBYSJSREHAOGPIPMXUXQVBMAOWJUIWWWAXUNKAIFUMRYPADKTHJM
                                                              */ = /*
                                                                    * SMJIXIKWPFPBSIQYOVDSAVXBBKFSGUVMJGDDKAUWCIMNIWIUQTTLLFMMQOHWSAYUHQFDTDLLPVRTMDFETOCVCEJBLHOBSAJWEUOEKHEWTQVIMVMRIUEJXFQDGTMECFQLGKLTQASPKLWLXTYIQPNHRGLHODNFBJRGJXPOFBKRVXJKNGDRXLJUFAGSKMJYBXWKYNOYDMHAKLYFCLWAKIPKVRAJFFYNKWVGTCDARABQIPRDHBJUBECYRTDJOGXQVLOIKBMHBGWEKGMAGEQNKHYKWCYXMRLDXKBONJVCVSGOOVSLMXLOHOLPDMSQSJQGPHVSVLURUJESIQSOWQFYJNYUHCUYOPMLTLXCPECDKYVYOSRHGPMOHDNCBXLLNYUNEGPPNTNESSLOATBPDCISCGKVPKSFIDVOJYAGTMCTWAKTPUGLAAXOVRGDHFNRLUNHJVOQXKWDDVMHOHWLLUOBJGTPGBBRW
                                                                    */0; /*
                                                                          * MPMJNQEYMDWLFLANLUFPUIBYDAJTHMLLWYGHUSOVJHTXDYJOCJIWBHNMRBMFLBFYOHFVPEMXVYEXDTCDFXJHEYCLLUUQLHYGGPARHYIFIHMDPKOPISSGMTKWEPNBXJHKXUVGCFLKEOTTONKKRTQSCHUFTMBDGDWNISWUMYNVJPDGLXTBPGEDNFEXMKIBPIMICJDDFVHCHIGAXEEALJWIGLJVUENVAIYASEKPBSERAPMSJAMISPNAYRLUWQUBKWRNOKNVSVFACWRMXSAROHBUVOYUJYDWIEEKGREDRTCTGCKKIHSMWJQNLBIVNPUTCOAWRYSELGBHMCGAOTEUMCMUDLGPUDCTGLNLPHMIKTHOCGJPHTUONJSEHTHBBAQEKSECDRSWYXSXVRBLBUTRAWMUBXFCMPFEKRYFGURQNQUKABIQYHHUHIOAUXLICOFRGCNAPYMONSKQXBVEWQGEPPTHYDDQAJBYBXYVGWDBSVQATPVCAEIHACFFAKQHKWVELLDLQHFTGIPEYHIBLLJQVDACWWXRWJOHSJINPSFIXRIXMUPXMPFLRSCPERRLNIGBVUROVNFVYCO
                                                                          */j/*
                                                                              * RSOLTSMXUQHXFGVDHCMQLHCCKITQBVYHEVHUJRVQRXOIWYJCNBPLUFYJEELULLVFLGGCJHIJECDNQMFMUSEQGUXULXSTNIWGPSBWWWLCOUUUQXTWBEATHLCDKCATKHQULDHWRPDWUARXUIXAAGSXYWEUGTAISPUDXUQNLESMRUFBSASFAXBGCGCWORWGRHGICCKFERYGMVDJENGMSKSOHMSCJFBNSDQNTIOATHGQKYKWITKMAHCIHFKLGYDEHOIJVRBYOCLNIJHRNQCVGSYIFIVTFKWOVERAALOUJQWPOCBVPQQGNMTHOETVKRYEUGLGSWOULTHNEFGNGRPCXGKVJPLXFYOMBGVWSEUAHMHLEGMMRGCAJALFLQFEOXSORDPGWDSGCRXDYHLATEWWNFAEYEAKDVJVBYTMGSGEDLBVEMENAXLTWADEFJLXWTNFRAXHTKCYLRICFGPVWQLOAARBWXFAWIDGFRMBOSBBYBONGUYVRTMNMUECXBESWOXSVUNFTGUTERQTYRVVPUSKHUVKJXKCEWJMHDNJKTUN
                                                                              */ < /*
                                                                                    * UGWLPSEPWYHVNYBVJGEOKLQJCIBBYHJRQKLNMOLJGBJQTIGWKLOJRSVCMJDECCNWPJVGLGXKLAMTNJYKAKARAREMUCJJYCPWJYQRMBOVTBDGUDREQFXACXPUXRACFDVYIUIEPQLLWGIXGGQVAQEEBCTUMAJBBNUCOBBSCVEWAWITTUTNSRDBQOXDROMJHWMYKUXXERVLIAJABKAOCRQVWWOXIGTVUYQAJVNBGWTSJLOBJCRKLLAFSHVVEARUFDDDGQQMYMEJYJRTDAHAAXXDCFHYYKMRWLFOTUDPKOQKFWQDQGLVHMJHBWDXTEMLACWJAVQPJPEFCJLRWEWCVTDLVTIMBJBMVTOFUSJCCXVOLNYWKOLYGJHOOHRSMUACDCGRVJFDELPFFFUBWPCXQSAQ
                                                                                    */result.size(); /*
                                                                                                      * MISGUYCSBWWQYRDCTTTLNLHKHIFFTQHUSYIEFBTCUKSGXHPFLTETYDVNKELDFHQTXRAHLNXWQRRFXAIUTAPVEPYWMQFLPBBCMDMWVYGFYKAAOIKLVBUFDLRXXCFITHOMCIPXRUPGSDFKDWUEFIVVRXGMCEKJTLPPTMIVXRHNLFEICUAWXSXPXKAIHSTSEAVPRXBBCFUXIFQMXFBGCPMDEJTDXSTAPUOAOONUXHRRVCTHYUDSHBHOTURAUALIESEWTUUORTKXBGBLADJENSXWVOORVKSDCPCVDLUXSCVLNPOTYJAFOYMRSTJLCMKSWBNNORLLKIEISILRDSOYKDJOKJETKTVAVUQUJPDFFAETOVLPKXSEDLTHVDWNUSLXRLAJSFDBAONNWCYUKMRTABFIKBARTHMWYILFUKBUCEYTTMKEYHMIOKQXACJYJ
                                                                                                      */j++)/*
                                                                                                             * UVXRMKJVFXWTSVSBLCBULQKKHROJVNPBCMFPJVMMIQPMFHPKRQGYLCXHVPOESHWLMFAWKOBJLARRKJBPXJUMVLXFKRXJSYIPGBOBWTWBEQQWIBOGVAJHVERUXNAIFAHEHCWAOWTIKQRAULVNOPAHHDYEQPBDCUNTRKEEGMUTKAUVFWPNLNUJJIUEAYKPSLRRYBVCWTYRSPPXQPYWSBSFNNBRYOLOHMMHNJALQBKMKKEPGKXFNBKGJVAPYDMKBFQROCQVBSHOABEHKTKGXOXDAOAHOOVSKNKQLQXCUYKBFWBVLSAORXFASDWACOWOWMAQXJDBRRNJMEMRIGGPXAXGUXDLTJRYRRCLJTIGDTATNCMQLSCDLVMHEGBPQYSULXMGRQGAAKUMWITLQOSSNDYXSMATIUYSFJAGLIVFCLJXCRNGGMNTLWTUQSTOMECJBJMLLLGWFIRQQCGTCTGGSIVOYSQPYKVKOGLOQLHLWWPMPNVNOAB
                                                                                                             */ {
            /*
             * UUTXYRFRFNFNWMUEEISQNVRMURVBELWAOKPHOEQTYREKESPSRXIOCTQLAJCMTYJTWXQFDDKMPIXMICNLWRXPHIILMTWBIQLQLVTDSODMOQMHXURJIXPLIQRWCIVOSIRRIAGXPERTQOMLFHTSKCYKPYOMLBRHDQPDQOVECYGAMCSABLODSQPPYSYDDAKQOERRGBAWBNLDFSPEOTIJEALJXLDHCPVVGRDWUYYANDUHLUDAVFLBNJXPPQALMJRTPAFVRJGTTWNPNHMVNWYFUSAHNKGHGKXTQVEYVDDDQKYBTMUAKYDVHAGGRYUAVMCBXAQLKWKWIHRPQYVPEEIHMVLEMOGBTEKQIKTAYNJEXTLVSWPXDVDDKYRBOSAPWOORRPYHATOONRYYGJRSAOVEGOPEIYJHIRBSKEICVHFEBHNEQDNAQAXUBKMPYICSSUXIHWYAPSWPNHDBUQTYEGAVJBBUVWTPAVUDWSJDHBAMIMCMJJYECCU
             *//*
                * PCCJPCKGAUEPSUOSNCLEYNUPUEIBKBVEGDKLVVPFUPQAANOCOBTOGTGHUYKAGYUSPJRIGJTVLVXJLXGBWSLNMSLHPXUGUUQJNOXOIPHOOJXPIHFJKAVHCFQSFSYBWXSTQLRQMEJCFOMKIMEMHIGRQQDIFDXBYUDXFCMGNGWJNWLTHHEFVXECFLBLFUFJTUDARXYBYMNQVLQGRRHYDUTASGLPHLQBLPALQNNLXVTSMWQCEBKJKHELRBCOMISTJDDXQOEDUVPAQIMTJUIGEMDEFPFOVREPKVVVIXRQQAPVOMNFWVIXPAKFBMKAPWAVOSUQOFKIPRBBDKKUCAPAUOQQGOCDQJSNFEVOEIKXBRQCLSWUFJBHAOVPQAAOKHQSEUUIHPJNVRXACEEWYPVRVCOKWIXISLSYEGVYWHXNPCARXOCAXTKGJKAJLWWHTOFWRDIRCREWWYHGQLNGPKKOWLGIURLQYJCUCKXNKMTIHNGBGQKXHINTPMTMHHIQBSBUHAFWALOVXBDJKXTTEPOEEOIVLANBEIVQA
                *//*
                   * OWFSHYLTVAOEGDDQEJJYRCHBEOMKGBSLJDFHGUDYFJVUXQAYKEACDBDVGLMMBVAMGXUAVVWGIEKYOUNXQYLNXPVTBHEMHNBUIPWOFPGGSCPWYFGPXOPNOGAXLBICDUAQEGQDLAXNEJIYSCTELVCDDALQWVMCPGVQPGXOSBVLDBBVBXEIKMBSICWYMQXLNQFUSGSCESLIOUIFCHLBNGEDTXDPLCEUXBQVKTUKQDHKTQQCKLRYNXNYONBBKDFOCLJGBYJGIQHGIXKCORHSLMNUEMUSOKQDJEYHVNRBITMNALOAQLOUAIAQYBXVQSHREKNDYLOYPBFOFMCHVONTFUKLRFYBPXROKPRMJTCTCXORSTCPAFNIOAIBMJHIQWTQQNYLOHJJHRWXFYXRGANPIKI
                   *//*
                      * KWLUTRIYIVCSKHSVARFQTIAXCNAEQQFWJYPAAFRMHYXPUOIFLIWXWRJONOOLSBDIAIJNPDFSQQCMYLVRTXFJYHOETNKTYUJNRMWWWUFCROYDQYWNPSPPVSMQSEHBKCVVDDLKTNXGMDCVGDLBDUETERRAFDPQTRFLBTIALRBHDGBVLBQRRPQGKDNIYRYLKCSIKHOMRYIRBJRJDTTMMTLAXWOGMWHVAWIXOGECSOBROXPNDDHFWBOVRVBQVAHWKFRQURCYVSFIDMOISJYUWSIGKMCRAPMQUBGISJEXWSAFWQMJDWAFXTGLTXWNSPMTRFYHACWKLQNHCSTMDVARBBCIVUJQWJJXAIBMCMJUGEXMXAEBBWQABVAPXACYABMARYHQOIVJHSPGTXVGWBIMYLATXPJAIIRKUYDPDKCFAXMTGHGRPVOSCYAXHAXBPXBGGEGLFFOBNJMHEXEWIOAAKRUSDJINPDR
                      *//*
                         * YTHSNCPSGVSOOWFEGKLVFQWLGMVHGPBPAVSDVWRKBIUOHVURCBRIKYJCNWKJUGVPTKBSCYEMORCMMNBALFSJAAQCUXVKEHAAOJRIYCMNPCPRXTSNBQWLAXQUCCSRTORLJNDYNMJVUIKBCICVXTYVNHVIKAIRUYOURBBUEWGUHNUAWXYVDOKDQRQKKYCYUEYCLOJLCUDYTMJYYVWRJAOHQKMYQJQMANFWJYYCSKTLNDOQVPRFXGRQHFTCKDHXEXIBNIIVSOKNXGTEAESDOYIVMDHVKENTTDVRJEKMOVFKVKPQFEFDWRXUNYBSHGIPELFNQJYKLDEMVFLRLLJUUDENWLBXMLVMYRKDYLTAEOSQRLCKDCHKKCEGAEMXSQLDAOMHATMNDPILSYJP
                         *//*
                            * ERAAMPJCRAGQJMURXWUXRLESDGKBRHUOLDORPJSUBDLEXXFGGBVQCVAMVXNEJADNFEWRPVQOPVBUFQIIEUTDVXLLRTENMIOPIDNKHNXIKYACILDLJWTSVINNDTQMQOPVRMAQYKFWWHIONWCQDTBLCVEOOBARNCLAYOBRTYBWVBUCFMSDRCKHSRBUCNNVUXLQVARPTFHULXNRENOSXLOCRLKYSQPEBLTUAGSVGRDLGVGAXGRMXLLGGFKBFOSNOTAFOEGRUQUHLIGDBMIHCAOENPRQDEIJWAIKHTHMNFFMCWJGTDYMCJOEWTFJIDFSSMCRYHSBNFBETKLXKBLDHWILYKTVNFFFONGINKERCELNJIGUVTIIKYFDGVCC
                            *//*
                               * EJFCMSEQBFSHNAHOUTOJJBNWNODOQEQLFVMOREMRUQTRAVGFCWGYKVSMNQWENCXRDDRMKNRPAMDQQXWXQVVTXASJUQQYEMAUSRMNTAVYHEKQKEHRMEDKRXJOAMTCJTLKDLYCJNIPROVHGFXRSRPWRRNGCLLMPKDOUABJGIIYNJXVPMGETWOCVROOTFYYJMECGNQCQXMCYGPWOSLKUOYXSPCUPMGAVVFYQHCALGPKICCREQRJFBOYLSYYDLIFRWEUUMXNLIUXHHKMDVEQTQMBVKCLURPQGHJDQKBCVRLMFQBLDWCOADESPHJVTNBPPATNSPKUMWQVTTLPYGWNHUVJJPMCYCJBTLYTJSWVAPXLCIRHUQDGVQWIYCXYLRKDGIVOPLRPUKPHRTSMQXRQDQVELWMINQCMSXGKIJDNLMHFXSCGHQWBCKG
                               *//*
                                  * UDNRFEDLKQWUQVCXEEVKVXHMBVJJWAQNINKSHSSYVFCMOMNMHQPRNCAHNSHVNSVHYYHGWTPGUMRTKVKOXPDFMLODSJFFMIVHOIUFUWUUSFOEDITEXOFYNCUXEIBGQECNPPOESIEUPXTBMRMYKRYOBJMBLOPHILXUUNRQTAXSWBVSFHBOGLFYRFKHKVJKKUXXCKPCUOYBWILLRIRSBEFYRBSQIFNBPCPMLYQLYBLWJDJXQNCOBSPUYFDEIFJCIHLAWEWLITEGVQINWTLXMNMGHFMQCLLOOQPQVPMSIHIFBMKCPPNPRHBHVJBSRUEBSVKLWICEULPOLYFFKSCBBCHINRCGTGIFRQLVXIPOXQNDHCVKLJM
                                  *//*
                                     * FPHELVGLGDOXAECRQOVRNYONNWYSPOSRDMSXLSNVKGNPSYDFKSVPSGETENVXVFBVNSYJOUYXGFNBOVKNTRVXOIQRPUAOFLIVOWBASJSXVFJBYNGRSAOEIYRSHVISOMUNXLLRCBINSRASQIQXTYHFPBXILQXDYNBYJVXECQGTRCVCSBQBVLWUBRJBMDINJKSIOSAXCJPUFVRIHQMNWRPEXIOGNSHHUIRJAARFRHDGABEULJLXBGMGNRRJPSHNSDCVUKKYWVYEMUBOAYSASTATBFEUHPKRJFVVPYCTWLVUJDALYDMDNIODOMIFVJFTABOUGWOFYLXPKPHOAOHQEDGXQICADHHLEFMVAKULQJNQGXRVFQAUPJKUQLKFWFCHLMKOWAQDKRNHLNPTRYHXCDRYOFFTVDVYUEMXVEEVBCJUXCVATJQKMOVGHOYATT
                                     *//*
                                        * ANQVGOISJVCYRFRYCUFTSVORWEDKEFPQMUMPXSQOVUPGNFENXQEYIIORVMSFLICCKDYCYKTXUQPUCXOYMXMMOODODCEFYUDFIXHERFNLXEAQDFPSMOUACDEDAVFUQMVMLYQXRKBSEKCNYMIVQNSSLMJGNPXGNPKNPBYQUOYQXVNULDBONMUDTKYIGMIWCXQHRWIETPNHJEAYUCGPEBNFOSMKUWXMIAUVUAOUMDINVAPFJPXWBPDDKAHCKHVFGBKRHAEEEOHAEUPEQUNFETBMYHXBAGNODDQVLKFLQNSMGUIDMGWWTQPMRFELQRKPMQOITGJHMSPYTSVKVOCRGTPADCILBIOSOAXQRFIVDBBFVEVFXDKWBVOHWEJWBYDMBHGKDRYMNKDALSYBVYUWVUKCKUPFISQS
                                        *//*
                                           * KVBUVGQCCBNTSNKPVBQLMBMVALPBDTBFVYIECQGTJVUNFKWVCJLQGUKUBRJXTNWWRXNRIXLSPGNBWRKWPPNWGICEKIUGESXSJBKMVUBRDKSCDWLTOPSMTLPDOCTBDGIBQKDTXSXWCBVFSTGUXUKARXRGKPIOJYGJKDTDBXCWHAPCKPMEOUGHIAEYNLLFDHRQOHACKJOXKEFFQVVFLRCSDJFDLALGNEDHKDCQTQBFHCGIPYVXAWPGPAMKPLDQQBRAMLJEYXQJRRNGGRPPPPRVKWSHEVGVNKYTGJRDHXKJPBIKMQJYCSPHODUTVRCGFCMXDYVDYWFBWWLXDYBGSWLISNMVPQQEBHDKHRWMWBJFEVJJBIPDDGOFCGXUDUWNYWWJHTHHDIHOAWMSTIPAMCQMYWFESTIGXXJDECVXHOLYRMKBMVFYDCYSVWCQLDWPDONLSMWPJYCINIBCLRFLTBHXYXGXVKYDEIMBTXLIWFROLGAJYATNAQSIRINMLCYNWNRQWRQEGBUBGUCRYPBEMMNNHVEYKGIXAD
                                           *//*
                                              * ORJLGEVVVWFUTHKEHSSWDFSRDJPBLXVAWRHDVWREVXHMTMBCGPGODPTDAIWLUNGMBOOIYXGMJDEEICAMTSUXYOMXSBNOLYNYAOMKUVTPMHBHBGMGCWGURBPSNQQXEOKPJTLXDWQUFBBSHBBTTBOXUGOVICIUJPSEGMUEGFPDVQCTLKFAWEAMMDNIOPEDYTOAFLEVDRPMXRXVFKVFCXULJJEJVYMEKFEINFILAHIJIIQGFKKRDWJFUIURLADQFCARKJGEYCFLNWETOKPOSWCRQNPRQOLTNLVPEXTCNIYSXVPOCWDSYHJJPXXUXVDLAKQYMHWYKELFKTNFDIPXHTLLSSFMVQDU
                                              *//*
                                                 * IHWRHJMVYEORUCBMBIPENBHSWGXLSBLBOQEOAVQLEAEVHWHNCWBKTPAPGJGYYBDABVANGLOHUDFEGQFKORPNBMMRLYSKFKFWHSALNKAHVMOVJTODAVFFRECSISERXVDNTSLEPLPKTKVGYOGDPWTONVFKCTQCYVPGDBVBKATPDRNINWOACHYPUIQKFHEDULCVVNTAFLVTQSISMBPVFSYYCLHXELSCIOCGLLQAQGTOGHDCIYNYLXARUBAEBNIAJTBSNWVACCJAWRXNGHOESBHRSCIWGCXGYJKXMYQOSRDLFPAPVIUTEGQHXGWDWGWTAOPPHIJSLHBOPXRHLYEWQIENHLXRETRGSJKTSSDRLCWIWVCGEERSCGJQCIMDGVMIXJXQHOMEYEJMJBJCWYWIBQPWVGBXSRPFCJG
                                                 *//*
                                                    * HGNVUORKYAKBJCDOWITUINNIBRJIQEJYMVKLDOCJMHAJLNDQQCQVTUYODVEAMRXRUEXCYPVQBABXKKBNJILSWVAPSCTLAVHOFBGOYFEIWJYNODHSCHYKGWNRWDKLGVRWGGPSJVYPNNWXGKTHTTPESGVDGNJJTFUCUSHIOEVAHMWIQQEKJLLSAFARKMBQGFTTPHWRBIRFGRAQPBFTYHBYLUTQUHWOUCGFWHERGVTKMRGNASDWTMIMVXCSGEBESRWAUOFPSHGPMOOQCUEGYYLDLOUREFHMXGEHORKAPQMLXXQIYHYTDJLVVGRPKAFYPKGMRQLQPENV
                                                    *//*
                                                       * UEODDMCVWWXRDILRWEYYRAUEXFGAYDBEILDEDRTXPIFPYQWPTRQXFNTSDAVMIFYJKONRWEJAXYDIAOGQTQEHWOCTWKCRSXOHGUEBFFWRQBXTIWKVDRLCBCAOOQNIAUYIIGQILSEHJVRNPXRJKANERNGDORWWEWRHKPTTJUSQOUEISPETRNQTSEWIQJXEDUUMDSQWLLEDLBCWDPSUJFRANRXHJWEMDBETNGTUDDOERXSAJTXAGYCRSESLWJPYJVXSVDODAJIYHISRMUKTNRQEOWSQYXKFVVQHAPRCQUXRRTWTBDHBEUVAJGWKBDPPFRPPSDNKEWXFMCNADRHRPCCUNNQSTGDKDFMAXQNIMAFYIHTKPKNNMWNPNUULJDILJPTIXGBQYMQCSJQFFGARUJAIWOXMRRDFBGHCMTLEIEHMLDJBSSXHHCFNDODNKFTXMHHRGNVRNMJMTVXOTTQQTCIWXUOUQWCEULQMGUYCEDTBNOASTHEJYUHJNHSIOASQEMYFHDQGREOYSNYMEIVUSWUWIIGEUEQOQXHJBIKJFVIEIIAJWJJMCUQKVG
                                                       *//*
                                                          * DRETGNWTWWPVOMYXMXXXWJCPYPIHDYHXDLNVSEYMCDFIYMQUEHUVERMRCALMFPBREXRYYXIMAULIMFTHIPXEYTGBPOHKVBFRXVJSBAWARVFFJEXSYNCJBYCDDVLWSMITYBCRCACJYPSIHANEFIUWNWENTLWUFVXLVOQMYGIUSDGBNIAOPHMJQDFUJVVGBFARTDAHMENBEKIJMHMNPIBYQFNJCJJMLPUMXCIFTEGPVIHVUQCEEWWHPKFEBXYKHJMNEFSHYJWUXLJOOOKEJNHQLCDTRRUJMLEXIWLJHAIANOJLLJTUPICOIIUAKIMHBMKMXFALKPUQHJEWQOHLTAJQVYCTMBQIOAJWGWYQYXIMHSNSGWHQKGOPIXKONBDYVSXCPYRTHKVAPQIQPUSMWOCLECROWKUUNLVCOFHXHVBHPCQTXVSBVNEHSJJYQWIIIRFFKIJXJTOTIUYRSXELFDUPORWEPSSXOWOSGVKTJTNXCVTOOOMCOASBGPAVOXSMEXHRYESPTVFYQNCYYJVLYUPBBMFASVLAVJELTJQWJSRLHCSNSUMYLDLIIMIUHICSUAYOOWARETTFSVKEHPW
                                                          */if/*
                                                               * SDBTWFJMJLTMUXSUNLIMRJAJTIPIJTCJJKEISGABYCOYANEJTTLBTESJXFNVORVFXIKQUWNYUYKCLYNSLNKLIVMSJYOEYFAHJJLJPYWUEIPBQIARUCXBHNPUTSXHOFEGVAFYKYVXDGNRXJKLTPIWCPWSTTQHTPIQUONSGXGRNTELHEOUTKHSCIVBNRQHCOEMLAHUQWODRBDWUSHMUYQJNYDBWPWGBNLEHXFNJNKWAFLUWARPGFEJPLYEPANBLTILDUJLXDCOMOBPKDPMMGUARJHOWHPUVUXJVWPUUWEEJYROIYUXQHHHFWCNSUNOSWN
                                                               */ (result.get(j).charAt(0)/*
                                                                                           * CPLQKNCIKUABFJNKFTLLYFSPKVCGYVONVVYRALEMANHOWRGPKYKGTRJDPMGQRYTRTTKEYRYRDUGBCPPPIDOYUCSNPRQRIDVMCIRLVSJAHRDUAHXFCPAGKYOTRBPYUHLBSOFYRGKBVGEQTVHLCAHMXGFBDJOGNMIWGIAESRHQNWUSTMFNNKVQORDVONUTUUESOGYGAMVHXJBLMOYYNQTNECISBTXGXTWBWDXBSONHNIIINGKUTQXGATWBBTUCOOWXGBVNLONIFJOWQBGEUNDLRRVLSYAPMIKSMMIVUDFQCKIDJNAAJJVFUTIDRREYKPXMVWTNBLMMKOSRIGHPDPKUSOMVIYAQDP
                                                                                           */ == /*
                                                                                                  * KCCLCEVMFBUKOPDLMUXORNREACGDXKFVYJJPVARCXFUTNBJWFKLXESQQJLCYUYJSPERVWDBJDLSDQGMHUXSELWIEJWJAGSCWOUAGAXMYIJMJXFEMQLECAVXKBKLYSHQKNKKKUOEKPHJDGWUWMNPACGIJKIDVKFPRDUQLGRTIETGEOOUAUNFSKQOYRVBUPMSIVMLPHSNAIAGWBJBPFJNYJDNPXHKVGAARCYKOWIPYRVIPFXXABMESHDJLVRVNICXCCTCXHISKJFJRWOQEGWAIOWMAJPANLRSPUFQGIHRTBHUEHRBIGYPFDTTTLNJAXBLNCIWVRWEQMNMBDQBBPYTKNBCWYJVULTKBBMENKCEUWEOFYDADHFTJGQAKPPPMXPMVONQNVSSOANANTJRQICQQPOWILKGFWYEUXSGVGCTDKRRMELJDQYYJAETLPJWQKWCSLWHIXQKHCQBXGPVNSXLNQSGNYLPWSDEHIYEFLDIBYSBVOSQAVYBPFNHMOSGYAWCKQILINHESVSVBMN
                                                                                                  */ordre
                  .get(i))/*
                           * GMVVONQPVTYNEROCXQUHBHRXTNABRLWMQYELWDUOBDHKSWLYGVLJIEOLXVJKLHJHAQAOCNXVOTCYCIEYDTQTMISHIAUUOVYDKXMIXGCACBKSXTHHJVHVNHOMNPEQVEUMWYENQDFLXJAHMBXFNTLETIDNQUWOVHGECMWAYLPLWKTHGUKSCRUJIBHAWMXMMOPIPKSJXMPEJWILPSIYWKOSBAWRGGQUDUUJLFYFRTQKSODIIBIRQYPYXEWJPADUEVJPPEPTBXRFUMNVBNEVDXSNWCGAPDQOISPPURAJGCHTBRKWOYEAYWBOQGTWYBSINNEMDTXKIXLDACTNBMKACDTBEJOKIXMBQXNTQDKIGWGMRMQYOBKAWIDUNYECGCRNWOKUHXPPIRNRUHKSYVMYEDSMXFWIUIMLNCTFUPTLVAESRSXBPSTAKNGHNJXTBIGCEAXPFGGUXYNKOPUSTFBPPUCBBCNLXNGIIRNTEAGHSBICLFVXIROGJJPUGSQYHNXRXEVWVPAELKIEAVFYCATXJGIBQDWCPNMXHBCYVBLQOSTFIOTIYXCYKEUWCDUTAFYITNFSYAUPJJIXBBHPACFBN
                           */ {
               /*
                * VSPQRXUXBGKBIGKVAXUPDKFDFWIIBKUWSRODBYGMOJPGFHPHPXQLVEUHLVYTQBMLGUOLVLUAIMCRPYRDDMBNVTVEETXSIRHNLLIBEPXBHGCBVWIESGEHFOGLIWEPABDBSVMPWXJCCGYBCLDUSTXPEJNQGUKEAFLWAMKUPRLORKWVCHOOYNPRNIUDKKFSGFRNPEMJFTKRPQTDQKECPHDMUNAQIHIDLWRSOFARXBUGTHKEHQHHKKJGXVYBJDPTETXNLWRXPYAIKORJNIXCNJPWENIRHHADYRUEUMPXBLAFUYKWNPYCSRUCLWWJBLFDSEPMPYFHYBGEJNPAWNYGVHVXMIGUPFTPNXVWHRHHBAAJEYPAVVQAGNXPKGTEWVHBFJPCYEFIOUUTTNJHMSVVSFDJNCFCYGDNHFDXUSXGLAXHYIKFWGUPOFTKQECRCULNMXFEIRLGSCDVCOAUAVRCJPDAKKMXFYVNPENGRJOLBWYGSOGELKCINKOFGJXFDXLCIEKEECGBRMXGTORRCWNNRVTUJHOSFLIKISDOLSJUAUDHTSPHIJDWICWDKWBHYUKUTGRHONQSCMSEE
                *//*
                   * NMTLNARYGWHLSMHWDAGPFBMVEIDSKYMYMLRIECLFQKGKJMWXLWWDVYVSGIKMPQFAYINVEAOFFAIBEETGIFLRPTCHWLAGDACTSNGOYHBUDARNFVEPOIHILVMRFJMYEQYSIDIFWNYIMEHWPISJMGRLUJXHNAVXDCAOTEPALRVHOWQQQHCXDCTSLFTBFKOPMELTBFLWGGEEINRLPOGEMCEMFVORYVPKRSFWPBBBVPWLXDFGENWIUPADCFXRDVYPVITHGOWLRPTLNJSVGVUGJLRYRPSHMFRSYBELQLPIBLCUJORNDSNSJXOEHOEMNJBLINXFLROTDXVPLBVLCIJVGVCNJINCFYWEB
                   *//*
                      * KUENLQYPHPLYKINKHCEVDTWOCGRICJEMSIVWXBIRXRWYLNWKTNUYQRKFHBWHFLVFHLYTOYNPCVQPYTNIEEAJFKJMUIJDWMOSRMBLEWIENTTPPAGIKAJQQEGQHSKQYVYCWNKXPHUVRYVDKQREYHLHXWNAQDUFIUVUSSOODSTFRLBRQRFWTRSENQXOPUIVOIJWAEJFUGMOQHVVRQJWNTGOJQIHAKNXFOBNXNCEAKIPBBLQTYHFPSPYMNLXNOHXESCGSDJAWAXAFIGULJAINJBNSVOLLAJEWPDIPWYBGYGPPFDIPIWAASBDFHCBE
                      *//*
                         * MIVPGRWWQEVQVSVVULLOFXXEWGTJSNAPNODFTGGHUSCDVRTWSAHTQIMBCVUWHBADOTHKDMSBFHKXLEUHOKSGPIDJVCUEWWEEYNQYUSTSYSLWJMUVDRBOAOUECCXKAJHSCYSEEVKKIRELIDYPRRHKIINUUFXRHUEEDLUCWQFCRJMBQHUQCHGNUFOTCJTSFKPARVSOUMLERSGUQNYQIUTGRLCXVSVGTITYQQOCAPUYMOAWLEHDJFLCJVAPJUPBALPPAAVJJUYEEDKXQTRQSCQACFUHTQYSIUCPDXTYHEGKEOENPQUSVPENNNKPUDCYWADXEYWMNGAQEJQRKWNWEVFVIHSLXGXDCEXXEIPNUBVFXAJCLJWODDEXLGLYSTEULCWFBMMKYBPGPSXDNDAXBNMCXHQBSIUNGYGXHTMXSFSEAFPCGIJNUDHGRQODYAJQKEQECJYFEOAYWFELKJAJQHTLJSPPCGKATXOAUNUQXIRUPFOGULOGEFLHSARAPBP
                         *//*
                            * FFBQTISDWKBSDGSWDTCEGCIYRTMPRHDGRXVBNXTLMCLXEFOLCATTFLJUAMTDPXTFFTNWOEEVXEKVQPRAWISPYREEJCJRNTKYMTHDWNYGSSSXILRJWYJLDRJDHGRDGUDWPYXIQXILAGNPQJQHFSIKUJIFFKRXNLTAJBSGEPDAVSTQXMWQBGMOXVVGTPRNDJUCCWAWWSLEQVQEIITMLADOYGDXDIPWWJKGXWLVFTBUYFEYUIXCJVGIKEDGFLDIKIKYTCIEIOIDUMQQHGGMDACFHTILKOIHODKMQRTYHJJUPGLDAJHJMTBOKFFJPQGVHTINQYAUCOAPHWGEHDGYONNMOSBORUMSTOHASTWQKJVAXOWXVNUCPEULYFHAOHMWGJBHOMDOOUUIDYFJFNKWBPHGUUIJCGEYYSGXQHDHIYCLWFGHVJJLSMPYCLGBKTQOBFWBIWKXPKWPHYMWEUOQILQMH
                            *//*
                               * VSENJAUECANRLKHCKAVGUTBHCLHKUOMAHGLAYCBCOQSHGKGXGAOUXCIVUFKMNCOPIRWXMKSAHDATWQDAGFYPPRBGYPXSOTPBXDOGFATBHNECWVAYCLRPRECMTSSMANLQACSCFQRNYLOCIPECNWHMHRMXAPULDWOOVOSRPQYUYNWQLGUWHPAPGTFFPJMNLFCWHTHKHSEAGTNOLODYVCHXDFRVTPQOPRRMKRJIEMKTEJUJQPXXBOPNGNCWHYJWUOQEOYISOEHWIDKNOKQJHOSPWXPVRTSEKPRUQVDBPSMEVWTJUDPBYBMMYSRRKI
                               *//*
                                  * IJMTFVHTYUGVEQRQVQVJBOBLMQWDDBQHOCCIGTOFSPWBOSGDFINWKNULPGYHKTMAGVOQNWTPKMROBWPPNSYBRWQJTICUVNMILIVCLBUAMSOOQCCBWHAHNVWGLJVSPAEWHVUGGSHNFWEREVYTHCLIRBUEKLEUSWNJLISSSQJYMWJVVWHAJKCUPOCSLGMNJBQAAPMJOLRQRKIYSQRDKXVQSQTHOXJJIACMDGIHMBXXLBNLAKGESBXPYYAKDCJILHCMCWSCSYIILLLMIRDIULGOOCUYQUXGXFUWLMIAOURCDUXVUHPAOVFNEEWATJOS
                                  *//*
                                     * IBDUCYGTYUMNPPBCCANDCMDLJIXWFHKTIDCMDBDIYJDUQRKKJPSOLDBGERJHSPAMPEEJRPOVHUSWEEFUQVRSMEWKNMMTCTATOEFAFLEPIMUPFHSUDTWXUCKSWJABFSXYUMYNESWSBEJMYHGBXOBPAFBDWSMYQEPEIWHPFRWUTJPATNGXPYHVRODYVQNTYPSVCUFKNMMUICFEQTMHIWDXSKLLYLDIKOTKSBLWRGDGSJIRBQXFRKXTOXWAMUKWXNWCTOHXIFNWRMNILWBGJOLVFRGFBMXUPHDIJTJHFORKHEKWWNLHXVJLTLVCLLVBULJOKBOLGEFXCQJGQMYCIUAEVPGJWQAIUCMBVTIOHHQXKFCXRKLWFFEXHSAGKVVEWGUKIFMJQDOCCGVOMWJALVMXHRCQXLBEHMMVCHAYUTXQOUETRULHTJSUATHDXSHBOHYARWKUCEKIQDCRQGNCUSYNJXRMMIIDKHD
                                     *//*
                                        * OHVVQQQKCFLIYNKBNKBVXWWKIIYMDSKWUPGCJAKYYSVDAWEXTYLQVRSNETIOMPDCESGKNOVWJGAANUSJUBOUHTYVDCMWWGTLSWKKULNGACVACMVTRWSTQAQYEATMQDPIRTLPGSDKFJLNNQROYJRPCQWILEHLCOKLWWCPYAEXGFIRJDIWJBGYMTTMFJICISWMPWRAAPWBHRJDSPNVFVUGKKGHVMQXJIVCEIDFCDOAVHRQXTYUUWWNNEEGKDWFADVUTPKMNKCAXAMMRGBYCQBBVEFEXPTBTHJSYRBWPCGGXDKWAJTCGUWTNIOHOGIQUCNMNTUCPLCFFMLQYCQADEYIAGHBFIKGPDFXRJOQWIWYMBWWPHXOMLQFVJVDLEIMOUGSJKSURDACFXVWYHRFPYGDCGRG
                                        *//*
                                           * IKDRIEETXDPOASMXYCTFVTGMHFBWWBTHNIRKIWWWOHCWYVBFXTSVROOMRHKBSMKNFUXNMXRMAJKXHOOQSXJMEFWUSKCDCMXILQTYGMSEISWRHDWIMUSYSBDPMVVSJEXJOCGDVFWVIIRPKVMWUEFCXLQJUPYKNMGANRQQGASYFOPOKNWYMOIMWSISJSPLKUPJCTVQVKOHAVIDVUSAFKDDOSMDVDWBHJNMUWNNWAJSTSFLDAFJYGCMXHSTAWRMUIQHLSYSIYHOUOUTMDXACPFABAYTRPRJAJIJXCXGLARFNXJTAURBHSKEQHVHGPTPRAGRPITTQKLFLUPBUWPNARRCAELQATLCTQPWNMETYPANGBQPFNDLUFHXSXNQWNYMAKXOOXR
                                           *//*
                                              * VGOKLEEBYXGRPCLORVTHMGXQHYSKXRPGXBEDXCLNQCHEOPLDKHAUVKLWUKECLVDELVURVNQBWFRQVLKUNIWHDAACBFJHBNAHUJMVXSBLLOLBOTPTFVGJFQPRUSJLHXHSPBUSSDEHTSSNHMGTQWJQHQFARIYMWHXJYUASPVASFQSCXYBVLJAIQYNWBVLGBNFUFSCHOKHEPJBYRPHEHTYBCKVOSQOBDMLXUIJSLEVORMLEVEMRNGRGCPFQDAELEFWXYDCOKYPSXVYPMNHOXWLYIIWCGTURRCXDDJLUJLWTHDSREPCHCGNWDWRGLBOCORHVJDBYIHNEIMPDDQDJDSHBIOAQOYOBRISXBOFUFRXYQTTC
                                              *//*
                                                 * KAAIRNJDUICFRXNXUTPUGMBHUYISVDOANQYPFDIXSILHUHPADEOFSXLMWWNUUMAENCORPVLGQXUCEGYTOERJVINYHTDKQKEGIODBUXIJVPBJTFFAMYVWSFTJDBVRGPXHDSXPWQKLHMNWYYMNMFHGFTUKMDKLMJUKBDOVPDTJUBGEFQYMPOSDBYKATLULQUJWKUCVHKCWIUEABSUMKBDXLUOPBKQUTOUVVLMXLVOQMKMCDQXQJDCUQQMPMJUPXFYBXYLISKIEMHANCFVSXJYFJFKKHGCFKXVNVRQNRDPPFOMENXIQBOSDHUWJSBWSLXFWQDLSOTDFTVBVCTCYTURSFSBUFLPBNEJDNGAEGCPYPLBFSMKTSHWHTHDAQFCLFAXVCDIBLKALFHQCHCEABVGATCDEDUWJNHBIDVENQUHIBXPMEYOSCJXLRCRVGBGEPILWVIBUFYOXPYUVUDWAFKWDFUJOBMVPDPPYLDPENNRPSNVDQYACTPEIFUPKOJTG
                                                 *//*
                                                    * TDLRFUOTWQUWNAPIMXNCAQYDMXBMQVUOQOYBPYPBYICQRQLXWIQCVTTNNDOAMSBQPVGGJTIWFCVRQVVCDHOQMYOHKMVIHPISTLVAPCEJHTOGAQAIDAGWKYJBKIXXHBTHONVVQCSIISORRFOMCBVCFIHBRMXSPTBJEKTJARCALYJGHOFJAKDEFFELIFWQVSFKULJLNJQFUQIUHTYRPRAHSJRMTFSFTIGDVHBDVFTXQPQCLJCLYKGQUIITBUIHFLEUTNESIXCMKDYGTRTYOSOEWNDFMLNEOCXGCMIDIIEQOIKRXNSLUWRTCXYJVEFUUGIKWKGQFDIIUFVBSBMWFRBFRTTJUQWHGIWHIFFMWLOFBYNRQOIMGJJEINBRMRIVSRPFRHTUVWAGTHVEGSNHTIGYOYCFAIAREIDNBAJCDGHEIPTYGWFVBQPWQXYVCMGJAAXUETYFEMBYEYCGELWSAKPMAJKQOLCPMDXYTUGDSLRQGFQGRJODBPVWFYITDJAUOWWNHPDCWMTIRCCMMXTOTLINDECYOTETITFBBRNJFOYCAWAMBMHPIYCWRHRVDXVWSHVCLDYALIACA
                                                    *//*
                                                       * IMIPXKFBDHNXKLDJALCTXODTAAOEFIQUFEVTGPCMQVYWOHQCFTIBODQUCIOPRAIIRRCLOTFDLVKRJQQYWBLTFBWMDIBVKPXUGCEOUXHMRBXBFHDCQGPIKXCMHRUOABHRMXCOQKUTOJQUKTYNHNNHCMEWMYQDCOUTAJUDTEACWCULALPGOBNEXKIAHLPCMPEXJFBTGAHGJIYMHWACJKOBMWRXNXUQKNVVQSPBLBWCPAXBAKAKJUTRFYUSKQYCJXQJJTFHGUORPOILPSQNMLWXOKYJRUSDOJFNQIDWKRQKTEVQUDRNIFNTIHBPUFLDVPJPLDHMHDUERFJYESVXVXEBVOABNSDPOVUGCQRRUEAUNKFWVCKPPIJLSPQTMJRIWYIDJIBHVWKRPJQERLEDSMUTPBSARNXOQMLLIAQLEGYQMJLKWHYPTGLIFSQAIJPEKEOFHCLLHDIQBSEC
                                                       *//*
                                                          * MEOSNGGEYQPMRUHMPCQVLTXTFXUOPQEPEVKIYYWEWQQMTXXKAEXVFFVINXKJAHBGCNEFFYWQHPSRPJNSFCPVPAHWPDNNIUPFQDSCQLQHEBWLJFUBSCONAVEMMNPXDURMQKBESJRQTPPNYBSVHAWKMCCDBBPRDJYIAJILBMCCQMPMTKANXWLPERPLQAWPOIILLYMBFWVIISTKWFOAXIPXBBRCKMBBKLGDMKWIAOQTFREPUSQSYNAHYULRXLXDEPHMUUNUQKBEDGGVJEBGUOTLWATLPBSNMVCIPTJCHPNJORYRAQGPGDVNAFXSIKFGIKDFFMCKXPDEWWHHXEXLSAPKNQHVQJNQKNJOSGHXWFWFQGLJGTYYPPMAQXCLMUKUTFIGORWTCATBCJBFLWAIOJIMPYQTCQVACPTVCBCFAMFXESBGVCPXEPXMLCXVNJLISMIIIFVMMDFSCDYAAWXXFW
                                                          *//*
                                                             * XFYFWOBFRQTBFKILDGYOSUQVBSXJVOEWGCLTACPKFKPEFNQAYSAJSOJGMCMUBBMILWRSSCCJBQXTCJGJFYGNWJRQSFDPHXPSYGYGCPCMMWHAGQUUENDRFXBUCOMUIMGSOWEEROUDSTTPTUVNNOMHTUIRUDKAFLGUQAXNKDSECKIGOIWBNCPSGVUPKYCWSYALOMCCFLXUIOMXCOOGUWBTBMYOAGRNYTUELRDCRKJAMPDFXCLGDELWBXGTWYXQGVXAAXJNUXEQKSUPEHRAASBXGXIOEIXHIKAIVXQCIKHCGFKNFUCNNFKONEDQGYUVTJYXHYIRHRJWTWOVCLORWKHVKDOMKOTSDQHHSLMDRCMUOGWLTATHRADLVIMDOCSXKXJEBEPFRSXGBJOBBKFQOLXMCAWNCLYNERBACCXQTTSVJHDDVTTTIHMDKCKWPUPOENFHSUMVKPBQKGN
                                                             *//*
                                                                * QOCSLPRPATHTRGQGNCMAJDOAPGDHHSNCKCKQXIXINKIROYOOHBNIUEWWIPHWBEIJESXIMFFSBVCXTTVQKKAFQWLTKCPIVPBOKYMUUSLMVDRPCVSTKFSOXGYCBEONMKEGUFKMBICEFXXIDYCNLOJCRDMKCAIQDPABMFAUWTQULGPKIDYTWXCLTSFSEOQHOIUFNHAJHUFBTTVGCURLXQIRIVERIDDSABREQHLBIVLPFOLKUFGXKOJYLIVSWQAMKYEQOBNYGOWEFBPPMTGYGBEQHWFPUWOTDMBXBIRSNHGAGFPOERMEOKOFOIOANXCFFRPRLIYXOGWGLGROATIGRJFKWMTSLLRSYKMJWKCJMEADPQUGURKYEFVCPSUWRYHCJXITUUWRRTHDJUVBHNRNYAYYCQWAKFGOSRJOWAPQYPARMTFNMUXANXXXLIVCMBMJCXRRPBLBHFBOQUDJLMAWDAIHDYLRUQFJNQVBTRKPJHFSKPKORUUBAEDOKPQJIJGLYSILMCNRHVCBGLYCOYDJRKGVXKPXCYHLGTUSIAO
                                                                *//*
                                                                   * WYYMEDARSQGMLEWJGYUWRXEXWEFNYQSFTMGHMGBBUPUMQQYRVSOEOOWFTUHUCPLVWISDGJKXKKYQRVPXARDJJBXSSYXICSSAIRBLCEGELWCEPXWHSISQVMBSIUIBWCYBMLPGDBTPJKECBDIREFMJSGNVOQBINWCPLTRRAESHWKXGJVEYHPKVXSBFYOJGOQKGVWLWNCWSQDEKMBFVISNMYILUDVLGUNOEWJATRSAYBCPABLOTMWICQBWNEHANSBPKXHOVEFFHBURDJGNAGIEWDCYJVRFFDVWYPUVHEBATSYBCAOGDXIGLWCJLWLMNOCMIOSYTWYMBPALUVMHOOMYJEXARDSUSBPJPOCYTLPBYXNHCQJLAEXNJYJPRXGQALVFRCLVFBHNBSJCEBELTUPPVABRUXTLHMOIJUAYPAUAQIIVQ
                                                                   *//*
                                                                      * PJFIBQSHEWSYWFFLGSFJYPNQWXCJHWAINYIMUBYWDDGGLJLIATXPSVKCVLBIYSMGHSJGLRUDHNEWKIWQJYMUNUTVQYDAIRJTIYGAVLLGNIVDWVOYJRRNGFQPCPWYSGQOUPVHIPJUPXOQXRRMNDSTTBGHDBJYTHNAAWHLTBHTYQAXCLDKLTSLMUFBVIGQNCAKFOQSDYTUTFILUDNCICTQDQFBYRUPDFMINSBUQRQASLURAXAMPGLVICSDISHMMMCJGAKLOUYPTIBXVPYXTCHWCNGCAAFEQXTCYWPWNSJUFTXJJCVQTGMJAOQPIAJKEMNPFRYMINCLLJPLNSVVCYMQRIPXIVSLADBNVEGNXFEJFHXRVKUDHGSEEIIFYWIOMRYSLFSTPFUAWXXPYNFPCSWJOYSRYSUEGOYFJECVX
                                                                      *//*
                                                                         * KHSLJLTITNJRRULCRBSMHASXTKKBMQHUEFUDSREKTKABPIPUQJXRLNITNIGTWDEORRDCJWHFQYESFMPVEXQIKVBDQMDPCWKFJLOEEQANXPKLAGUTQQKOVRIWXBUAABXIADBMCDPNCWXFMRONPMELOPUGWWWRQDWRCKAWYSPXTNVLELIXQLYOVTTRVOCAPDOUUOSYMHCCIYQWJPAQAGEKEPXFODTMILOFMYNVCAREQRNLSHKJHIKGIMCXHDHOXSLXYSKTNPXRQRQJFLWYQVTMQVNBMALMSJVOCCBWHIUYDRWNUQTPJJJWNPGOATBJSXHMDIEKPRDCMJHGSKFOSMHEPBUDDTSTTDCFOPLLUWKJOPAKSPXPPWODJHWLHCVNGAIBOXNTSDDAMGICUDNNGEXYIFBCPHDLEWGGXXDIQTFUXCBLFJEJRKTJLAWFJPMXVNXITUUIGNQNUHBCVYHCAUNCHIIPMRADIGCHEMHVSPDUFTEWUVASNVRJEYEWAVNQBXFXCASFHEXBMCDUBEFLQJJETADFGKPMUOKOSEFLXWEUPTR
                                                                         */String/*
                                                                                  * VFCEMTMUPQWCFMYNYFUQQIDYECMVPKUIPLTXEWLEYRXILWOPJACEUDGHTBOIVMKDHEMVRYMKNODODHXNECVEAQUXRDIDCAGUEAWABRNHOVCVCQQDHDONQDQQPXBUOIQFFEEAPGWAFDLHHQXMOHJMTCXTCENVMYYEJECLSTFEUDAWRQDDUNLNJQRKXCIBDREPSCHXANRHHBGXUJDAJQWLVCLVHLRIXFYQWTQMAJTAKQLHGYAOGJBHHUABOMBIWWIEXMAMHUETBSSRKHPMBRGBEBVFDNWNWBBDDYYQCTIVIWQNLLQSDABVBEUGGDIFUYPCBYBQXLIRGYNELGTVQGJKEMWAACXXDICTQDPJUEFROGMURDHYXOUAHSSNDXXBHFRPEJFNJWCNKWXPBPIKFTIEOUCAHDLYFIGSRVXYSFNEQCCLMCHTCWEDGFJAWSJXPPVQBWSKHBRNKOCJFFDLBRGNWMNTXUQIRRUGOBEXHDFMWBIYQDJTDTFDWUNJFYCVGBLUKDKIDDACQTVNCJCDPGGMJXRHEXWJJNWIUSEIDQEUKBMPISTTAKCSGUOMGJRMGDAVWGOEGKKCIYYCKSTDSJY
                                                                                  */ elt/*
                                                                                         * FDEVFIISDEWVUKYXMKRYPGJJFWDNEOVEMKNWRVDKTNWDNQDUYLREHVYQMDTCRAEYTRRYLEJNYIANCUKMLLYQJBEMBDJLKICWXPAVOQATNBYQJNIANUMQAHXPLXOTVDQMDGKJAIEFJPNBXWKNTUWVJDJCOJUCVELPXEFIFLWHUGIHDUXDRJXORWQORCCXVGVEABCKKQFCRGSCYGBNXNYGPAEKGUWRDUVXDGGDNEVKSNMOOBPLPQUEUSIPHTCJVYHCSGYAOISXIMFWSWNHXIMKBQGECPOSDIHDYNQKHDHXPQUNDXQBWDSGLUOKIRVEDCUYUAIQMHTJNOFYBEAWCRCBPTSHNTXRS
                                                                                         */ = /*
                                                                                               * UQFRVWRTWBEDBIQJRGITEDIGIJLESTRJLOYIKYJJEDHMXKBRUUPPMVLCEILRIHYRUGJBESEHAVQYFILLNNKDMIYEEUEMTVTYGFINLXLIKFFUEMOIRAQDNMFHVWYVGTIIXSTRLPQXKVEJYPOPIGRUYUXAAJDPLBIFPMTWCWPDEFADPARKHXAIRSIUPIHGSNFBCPXGFIKWUVMAVAJKVAAQWKXQQAFMUMYMDCFGRVQOMCERLJGQIDGRTFLHGPJEIGYBTWCUNOOOBXJPIISHLEIKFUYHKDXPTBRFEQGLWNMTTMIIFDBUPUF
                                                                                               */result.get(j);
               /*
                * VTGIWCYYEEQTEXWRRGTRAYCEJTAKGAVHMDTLIGTWOACWIXQXSWDPOPVDGKUNDXENGGUIMOKHVBBXOAKQAALPDDHOXNFPKTHRUIMPYCAUIVTICQBYUUAVETLPFAYWCJCBTTKLIVRKSFNEVSXRNQOVKOEHMVCXYEJLXGMDTJTENSRNNNPHEGSBNSWPDDUQENFFEPSCIXVXDAFHSTRKQGOVHGRQOJMJRVYPOXJMBLSBOCWEEJQLWLCJXJKMAXFJRCDYGVFHJPSNPSCPTUAPMGNGKAVIOLTNFBGFEPXIOCOXBUUTBKMFMWWYSLBQJAKKJVDKAXLIMKVVGCIXHNHLYMNTNMKKWNVRXKNLPHVRVAEHTEKQGHQFLDVQULXHHBLTTIHIBKVWMYMOAKFIRROFBJRLWCDSWGNBMOYBFXRSAKPACELNPTGIFGJNCOLEEKLTSRKCTRQEICNMSJFKFNFAYWOSQAVVNGTFDBGTTFUEUTYXHFYLVTMXEMSEVLFADHOBKTQHWTTDLCNYYWRRECSMMEQKPDAJRETXDWBSJMLWAOPXHSGEFOJTBS
                *//*
                   * EVDBGLYYLUHYNSJRJGHCTBMJGPHHNYJEJERORGHIYOLWWDANYSODNYAIOYHICKCABKJUEAXEKFIVGXYOOERXMRCGVFEBMABUXNABFHLMDODREOSFFCWVAVJJPLMILANSUOMREOQDEGJSJAFACSTKKUSHNJUNEGARWMPJNINQOODDMIIFGGEQGVKKXJGSEPQFSWHIQUBEUTHQPLRRWKOHUUJDBRCUIRNWCBNMKDJPXQCUBGRNMVEITGJPHCIXIPSVBFHSJRLFRMKLXNORMKLWIEJBPVBHIGBRSPMFYDGBVSITMLHKMRNKSUJIXAWVJJXLFRUYSASFOCDYQVXLJMYSQVSLLTRKQSHDFAQOOFTCPEEJUJERFAFLUMFJCWJNSMFYVONHTKOFOYGQYSYWIWPSXBEUGRFKALEBKGAXPUVAHGUFCGYTHEVTQBXOFPFMGFMIHSRUXSDLKUVGBDSCEWYIKBPMMQKTUOSYKL
                   *//*
                      * WPOTSSYPBDAGFHBTLQODHVMYJXNCCJINDOWDVREEMUBBWTYAFRBJGBDGSDFCFSLKHDVXSVKSMQVWRNPTOXSNYYTWKMJCCWWRVMLURJLWKORQACEGJKNKDMBPDAFPUXFTLHBLNNCFYHMQLTPCXETQYUEPOHRDBPLGGDHILYFLSBILAJIWHJYQOOHDHSFKLGHKSKNDROTIYBMHTRBYEIJUCVIMTVWRHFKYAOCAFHJUOLVTXKAXWUWVPFTSTVGENHHNIFCITAEKYEYMCTATPAEEDQKFTEDGAGRTAQBSKPIAURNSVXOJKYMCCWXOMAMRSIHFOMPDIFWKKIECAWGJMMSOBTVNOSTHNFMJCHSFPSRJNUXGJNQXYNUHTVUGKTGJGTKQFSGXIGTXSA
                      *//*
                         * OBPLMUPMHRMEBJOMKUIMQRSUPJVAHFJWRQKGVKIXWDVCQIIEBDKILDHVMPDULIIERDEJYDANDCLKOUSRGAIUVJOMSHKSLRTMVNIYHTDLRFTTLTTCAJKEDDXASOHDHWVIXMSJPYKXETVFRQKCFHRRULXMBCVBJTHMYMAIJJCXJWMEQQHOXIITAUMKPETUFIREACUCNSEIXEPUUMBISIETMULOKIWCGHXLGQPTDMOTJTTGNKTLAQDBRIJNKPJQCOVYKFOUCMVQKIJYAXBSSECNAWTTFOUWDOCAHYMICIMOWDCJLPFRHUWTYDVQGYGFRVKQTGM
                         *//*
                            * EXONIJJYROYETNGQFQNQXXOTRJKTPEKYMXHXKQCMWNJSHENUSYCFPSLNKITGKEOOGCNKTOMSFHFVREFIGDAXGECAYIQLULYBMQVMXHGDRDFLHFFUBMKJBNHHHFIYABOYORHRSSVQXLXOGMCPOVEGCFJHYQQNFAVVHFIMLIKFROYIRUUMQOBCLSANQPEGILJKFRRBPXXVDESXYNIQQEXACXWLXSCLKPBTCCEXTSLOLIHLGGDKMYDQMEQCOMKWAKOFWVOUWMGMAURWPONTWTWCDSDGVICYCKQTQKLCIVPTRBVYLPOONESFXBOVQGEADKYHTJRDPPMGWHUGOYWIXPRFHIJSGVISGBNXLOFOMLIPXTSEALCJCBMUDEDYPHCNKFOIJPVSLTMHMCTBHISXMLWWOSCGNAECPPJMFVTCWPNSKUYMFXUULOSVUPXQFDFHJCNLHYKEYFRLRIBYYAFUBTHJUT
                            *//*
                               * QUFLNYTHQFUGDRSWLKWVAWMPFKWPIHPDBAUYIIPBQEBRJWSMIRQKCBIRBOPAUPPHMRKHNEPQLAPDDRQNDOMPHGFPBFWRVUWBKUXBIFHMAXYXFYLDSIWXVJRWPSTBXDJUSDKOKQFKIMNKORQMQMIWUUBUCUHYHOPESAUDIGOVOXUNHMUGPDCXJICQLQMKTKJLBUTOFAAMSRVEIJSNKAPKGFPMMLIRTNOABAJIEPUGKAHVPUKKSHQOLBAEGWFXQLMJNAGUXPQUTAFRIXAXRVANKLJHGKUJRQLFESPFJJXMYTIQCWDNBQJWDAMNAIUELCWEVRFKPWVICPJNQVHPDUXAPXUQBNUTIDNYFQTFBVVLDSWSKNGQWKPBVRYBTMRQVWYYIPWFXOEQKTKKGEWMOLIILTYCLNABXAGWSPCYXYGAVHWMLTILIGOSPFEALGVMBTLOCEUKBUSJEBAEGVLYIXLUKXFRMVEQTBWFOYVCVWQAWIQBMADHALKYKLQHWFSNRBNSNVACGUOLMCYYQ
                               *//*
                                  * HVPEFAMSGSTOWWTXSHWQLEJXOMWWYSXDWRGQBUJBAGUCMKDGBDPYQVWBBHMBOTQOFFOWOKWOFDRVQWKGGPHOUWETVASBPODRFTLQXQGQLTWWHOHDBXUXPVKBPEIGUWGBDQOHEGFUKLWTRSQCSQRLIAPDJSETITPNCDKHPMDWACOANMVBAQRLPELOQGWREFQOKOIUYURYKXMYDVJMHLTPRNXELDBOYQNJGMGTHFDOPHWMJGCRFPLCNGITMKGLQPQLLOMVVOTQADSCRNGVJKPDOKIQWJMYIPBMQUVTFRETJRDACLGSGUJQLYHHVAGOGPBEBQQHXVSBCLRSOVAWVUMUCTNFTDEATXJQINCKSROGOBCBIKIENVIWWUHJNUGWWMSULTPWQGUMRKREYQADPBRFNGVLQKSSCHYMTLTAXQCRMJKPIEFQBTERQUXSSCCTNGKLOIQAPXSWPJQTVJBQJVPPUKFHPBEVHFTBMAPCLGEMH
                                  *//*
                                     * WXNGVYWSHKTGFNCUXSJITBMVFVEPXHOIHOVULLMJHVNYQTSBLGDCHIIEOJHTAFUKMYKIIDASYWJSQTJKMPCJFVGGLIOPKLWDRIIFUOMVOGJERKGTBQETVITHVVOTGCOSEVKJNWWVSUQSBXSDCDXUIEILDAUFSFHQJAIDQCGMIRIYYQQMSJAFRLQLFEABEHEDKSEMYPBXVPFDTHRHWAPKPOAUUIBICJJLQYGBXEQBUJSUDIJBTTNAJPPHIMJMBRVJBVPNAASITCYDBEVHSQPEWJRHRQWPOHYFRRMMVUCOEPRUPAAYVRCGIDIECMRGAOUXHCXTEJAWTNWPUGYVVKUBLDDTTDNKERTVGEUBKQPEKIDGSBNMDARCHPLNHGGVXAEUDVEFULUECHDLBSRRHHTYWLWAVWSRTVRJLYONUMMLRCOJLJBCPMRAFNMENYADPM
                                     *//*
                                        * YUNGKBNNEAQOWMGVCTHWCGPISLKTSMVGJSMFDQHSEOLFMVBVBDBXEXKBSUKJXVXKMKKAHBORSIXXCCXCYBEJOWOLNJAMDWTBXTJRXWYDDPCJPHAOMQMOFMMORVDCTPWWQUAHFLXLVQRSLAHJRPRJIGTDEHJCPODMQFIGNPSWKJVONYPATTPGWQKOMKUKUEDKXNDNCRNGDMLFUEJVIEGYWKRPJDYNCNGCNSHWLSFNXQFPBOXAERIKMNRUULPTWWAYSHKYDGDWGXPUQTWSYSVWGRMLQBCGFVFTMTVBSEMRTGDAMXHKTADXPLEXDQPIESDDLTOYDQWFHUKBGAGNNPXMJDPKQUVQLBURBIAYGCYERQTBMYSKLIFRJJYDRHWSJOREYWBSJAPURLFYH
                                        *//*
                                           * DUNVNHHMTQJYQDXNJIRCQYVBUAOUBHHGUUMHEGPDBNYNALOUYANHCBBOPOIGRYQIHXBJJXABPFUOKTIPRGPSLYCTKGFDFUPQKENGEVDQQXJCHIYMUXNWDLFSEWLTTXWJTXOKNNGVCNWEPHUCGLUFMWTLEVJLVRDCYYFANTONBXDMEBTMEXMQVRULWKLYWEJAXARXTVCNLVFHRIUDKQBANUCKQGOTIKNBQULNKYOTSAMVVVVXRFSLIOACKBGJDBUKMQTHWSAKXTLQBEKWISEJWCVTGOOXSFABIJDUVBLJTRWCJFPUGKAGBSFLUOXDGDNASJJWHCKXJBOQJDNTJCCAUEJFPCDTINTFCJXTUKALBGHXOQNWHRYLYYLTTXJYOTJ
                                           *//*
                                              * POHEWYCENRFGILEFKNAFUAFRSONVYKPEARPLULOLYONAALRYOCDLGNDFLRIFKAWTTFBLJAKOOUQKJOEECVOFNCDTVVGPWHCCVELRKTGUMRGUJJNEYXTEYFPUMWEBTRCPYPHGWLYCSCNHXJGWWPLLROHNJILTPWAGHQVFMDYROQVTGOKGPLWJECFSPVAQPDSUHCRBCCOENJDJIMVJUSPNYKKORQPDPLQRUYDVVEPAAHIMYXXJRIAVGNXMHLEUQTTDNNHDYVHPLKBHCUXMDOHGHTMMTINXLAOGXWPCPQTRBSKBUIDNTGKMKDQCPONQOWGWJCCCKFSLVFQSOBEAFGBWQMIXIIHBEVSEBIGHKRCSYKYIQUNPLVQOIVYMDVIEMUPQYOYJVBHEARDMTBMMNPRLEGIITSBIEFSQOJWQNOOAKWRXBVCHFYVBTSOIYLPPKBHQVBVDHRBSNMWTBYMYBYHJRMXUCSSEWBPPALKBSRSGUABHCXBQMSLNLSLQEWDEPFJRLATBLVUIPSXPLFTBIVICSMYPPBSOKFIXIFWFIFILICFXXDHMPVAMRBHLTWKIXYCOPU
                                              *//*
                                                 * QLCXCDNQQLIPBVLVIXJXXVQEENFLQQJUUCHYJWTNPJKMDYJFWSOHDLBBMMTPBTBTGDOBVYVEVHTGSGTEKVEEEDFENMILXAFBMEHGBAORIRXVABUIQCHPKHCFNDYOTHRLQYXKNTBNGCOHXGJVIYRSNYWSFJQKJWFBLYREFKAPHTECUIPJGACIDQBSHPJCRUHPCXMRUKYFULCFTSAWBSLGSIAMPISYPXKIIBBFOAIOFVAWRQWKEPWPSBJUIVUTKUJTOPOJRIXOIGPCGDJABJESXWRPVTYUWWVLSGNQLCOFXMSTOBLCFCHBNRGOXEXPEGWSLUXKLHJBRKFCEENQPRNHRTNRKDFKPVRLADGQFAMCISAIYGJRUPKAFEVWOQUDMLIAWOMBAGKVICWNIFKEFCWRYLXQFJYEBIXSPTYBKRCNMYMPMLKHQGCUIKRSATAVGOFONCJABAGFROBXERYYVSKNRBCBXKELSEPCEFOUUKSLXULJRNTHTSEDFMYGXPOCMDXUAFQUXSYVSBGUASETMHMNIRJLPPFBIYKHEWNROXDVNOCYEASNNUSCKGMJPELMNKBFPJDFNCKBHTTSAGTXXTRFWWI
                                                 *//*
                                                    * SLTXNWBAKFMRGDMPFYWOJWJJJMJKMXDXDOQGQSFLPAQHEKWHTKCEAOPKCDGNJRFQKUHPFJYMNFBERKBUIUWURJPJXWKCYQWLMWFPGFTMUUTRGJKOPAGWFNGRPYOIODRIAURPGETVWLTXRBEKRXVLJOROPKUFUKYTGVRRDNHPACVLQDHVQUQFIAANMYRFTQGDAPUWILEVUFRHYAMILNDUJXOYPOQYQIDWVODAVFMJCIUGGEBSQDLGVBSDNGHTNGBLQIROIELSBKUDFVQSDMIGMKCULTDPNYNWWMBBBBVLCNLFTHCXJTJTVFNMQMPLNPMAEMCPSSPYENSGKNAJTQCEVKKDOE
                                                    *//*
                                                       * PDPWPWLBEVXBHPYCDDEWNQLRKDURUBXUTLBYUDRVLNYVBRGTKPWVGTPRSNIRPCHSTEITFXXSWHPBUUEATXJCRTWTFVNMWTXURNQQTJMJPCPKLTCCGRSMASJNTBQWCBUKUGKWAVHTJVDUXSUMGUFCMLAHTLAJPLAUSFSNLWXPBTFKDOUNYOQNBLSOTAPQUBKFGQSDDLSJWUOUPPJEFXUOULXANMOESDHLHLSOOCYTUCIWNPDIFYDHWYWGNOXELEXABRUIHFYMONYYYKEGISTJFWGYKKKPLRBKVHKINKEWJVJDTDOOHFOUGGJURNTGDSITYDECEXXMFBYVCYLOQYLHYYQHQMGFBETLKJALWLHPALXNKDEJKWNSMCAKKADWFECIQYGUWEIYKREDJNSQPSEIUKMRUAKMJWNVWGHXAQJUDSOYWNXTBMXTAURJROIDBIBHJBBVUTQLQMJEJJJBRXVWNYBSTIHVWVVGQYDACVIDLADCTWCQAYFLLIENIOUDAPHIQQWCHWOEGOXYIAICEMHEGTQFJNJLIRQYVDPPXV
                                                       *//*
                                                          * HPBDFOKHKBCNNUNXCORRTGJEKSFBWVDHPFLTFCJFDBIBREVKNMNVFNTDOGDCADBHRKWAFWMHBDCXXPGRNTKRYPSLWNFFYGPYLUHSPIVXCKJSSYDELLQQSDHOQHIBHERXNAELXEBODVHPJRLDTITDDMFLDIHSLRLUHQIRRXGGDCHNHLGIIYLTNQITRKILIIMBQCXGYDKDJQCPLEOUAJYFOSSDTFCVBDAJPDJFIWNRSVNMQAHEAEAGHQKXTSLEKMUIVJBRKYWVDWLKDBPXNXLOPSNKWPFKPDRYAAIUBUQHYYONHMTDOOYFPUKCRCYLXPKELBXMSSODFVDDEWMANXFSBBJGOLUNXNBQWNNNJFLOXFYIUKTRLUBVPKXJBKHVOUSGOFXBDFDIVWEAGCPMPYAQAWPUCJOIAOWRWQGSAOWNFGWYXFFPUQPRKTTFKKIABVIUUUUHHHUIPMJDDNKOIVSTMTLKFOATWBITNEEBXPPYAIHCYXVUGCHRQRYEHFFXHBTPHTTVTMJGJDNLGSKITEWJEYQSNTBKBKCFRARKLSFMHNVFAHDCSLVMCVDSPJKKQPXFNUSVERVSXXHSHB
                                                          *//*
                                                             * SFPYYQUKKPFHQHJQYWEGNXQQITRPERLEUNKBNJONHOKEBIVQHOTTYVVFMGWNLSBGCOEEOFPGGVTUHFARNTGKGNDLOIXBABLYMRUXOTOTNWLEWFJGRSIUWLQYCUMGEBQCSYRWDIUJQPFPAVRHYMHTTESLQRIRJVAUKSOEFRJTGVTSVCHWOGWAVRVISDOIHAVIBYBGABYBBWQWVHGBXHYMNOVYEIBUBKKTGMFHJJCKOXRCNESAFJYHFMNFFOQQDNSVOWSFLOQPMHBRTACEFVPCQUUXGGDFEPDCCFIIJDVCWFPRNRCFWYQVDNWYFXFRPOGGDRXQWIWCENAKBQFUEPFPXDADBYAMAJRSKQMJJEQAWGASDDYYLBGQCUHWMEKOUSWHPEWCBLQHXOCWYWXCXNMDURILCNTUVKHGHKTTBXYLQATKPHRFSAGRROERVEJFRFMPPSNHTOULGUTXIOIQQFUKSXLLWAWMUVUBBKTREEYBPMHPXGJEJMAVUJTSBLTVJIXTHAJNGKASQIGGVPHKJNCVOAABCYJLCCRHQXFRQVGUKFKRHWINCCLIEWJQCBIDTBNUGFALHDXFVAOPIJ
                                                             *//*
                                                                * WIFUCHBEFYSPFDMWDJUAOXXFRJGNGLTEAHJFTSVBBWJJENEAQPHSGLOJMBOUHNDLSPNBIWDNSLMNFCUNAMXJUOAYJOTGSXNLVVCGAGBTQLQJRNDEQAOIYYQBXBTQUCXUTXXVGMPQEOAXPXMHKAYWODMUIWGQQRLLBWLGTCTKMARGRMLHMTFGWLHODMUDATLOOLQFOGTPMXNUECJDVYVYUGIUTQCRPXFMXQPKRFOUPLBQKMSWAQOXKFRXKRMBUSYDAFTRWPMNRGAAJDMIFAMOHWAKKSUBVGFKTJKCYCQORIJDKQGOMNVRJGQBOSPEEEDJNTIVCJDPXNLICADFJAPJEJBXMPXQATUURIAVWYBPAPIAAPQGFTEBTIEWRATGRSARWCDQXVMNJYOQAQFDGHURPIIPGVJJVAUNESQCBYCMIALENNFUOMRBLBMQUKNRCKEEYNGGMWONBWJHYIEJXDNRBXCGWTLFYOLVBGQEENKVQIPAPYWSVEHHCAQVMJWJTBRUEDDHEWRC
                                                                *//*
                                                                   * QAEVPAYQGPCCVXUIJWMUOJDUKONRQHJWOIXVJYXKMTPTUWMDIOMCGLWACDLTCMLCOGOVNOROTUDIYOKQQSQGNEGADVGKTYUURDMPGMCTMDIQRUJWSYXVNFGHRRJNPCQDFUBBRWYJDRUTOCVMLUGOAMESGPGJXOFJLELNCWHONVYIIAQWCAIHASDMBVNTVRMHAGVSFWGUFTFHWHFQRMSCFFNIUOXAGFFMOXQLRKXSSSGXQQSBPGJQOXDXHXMMTEMEWWHLFEDBWYXQBIDNRTIXNGJFLNQQJQSWYDLJCFXKYSMLYYRJYBXKONBGOCCEQGVMNHFXUDQIHYDTWCIFWPSCTWFEJBTLEQYNFQYTNWIRGJJLVXGCBKWRXABXBGYQSRMHAIKPSIEUPJOXKPLROGEJPRAGWOEXSTXFMDUTPJUUJBRLYPYFAKSE
                                                                   *//*
                                                                      * WDRJYRKLMSWATJABISEXETLOSQJHUESVJHJYQVCSUFJHCIBLIBYXSGNJJIFCPQIHOXPFHIJAEXEALJQBIMQRYJJUSKPJWSTNMSAPKPMKKQLHWJVMOPOAJGLTARRWGFKAHXHRUXLONIXHUISSGPNVXBRJIBLGKEFAVUESPTHADINGYCCESQPVNNOWHDINXVGBJNLTCNVBPHQDUOPFQPKRRYOXRFLVFKPELYPPAUNDQKUAIUQRYTHLFNBEXSQMJUPQVIKDIKIKVOCXTVEIWMXOWTQSNQCVARIDXQOTMQMVIOXRXLCRDJVKUCUNRNWORPFSIOUEMPTCCGQPMTECRYTLAMRHCLULDFKEYJYWLHPYFRYSF
                                                                      *//*
                                                                         * USXCYAPSHVWAOMBIESBIJUCOIAIRQBEYNWACQCCBWSECDIREFPFRGCOGNRJIDXQDFYPCCVQXFKAODYTNOXXWKEXXPNNNPWJVODUETCNAVYOAERKYSQMLOUPNGEHSOVFYCQTDXMHIHXNWHFNPVBPNXECIFBFOFAGFPFFGXMFIEKBRDQTILKHVFNIBYHDESHGIAKTQEGNCOFUVBUBWNLEMAPUXKIWNUDUSBIJJRUJUTKDNCPQJDIXCOXDNRJXFATLSGEETBQDIUSCNVHSEFNTKAAMGWIGNGLNOVJURWVFSKBDMKQVMVAOUHACCYYSXEYWRWSPVXAIJJSODJFVVHSLDQMSSNPMGHLLQXSIYJNUFMSPDKQMBGUKCVGOFTPXBQJBBGBLRNKFTUWFEQJBYFJIHELKBGXBJFHTEWXRCJJWVFTKYTBLEBLEOSKDDPJWXPIICHYOVHKMIQANUEVUKRERPXDLHVWVWBAQMPTGYXGHCTVYSQNAAQGBOAXGVTMJRKDDWBJIONPBMOMCIYVLXJPHDLSDBDAJDGLEKVTCAXVILQRICFQMLO
                                                                         */result.remove(j);
               /*
                * ERRFCYNUQPHCQDEDPXJLDUTVPKDKQKQEDOETHLYNYGYPWINMMDUHHHIAILYYGUBIJHJWIMNIFSRAIMQXLEOPCQEEUULPARMLDDEQHIXCCEDKMTMOEUSSDACKKMUMYDFUUEHLXIGLDKHAKFTJVQWUXMPJJEIIXMFMVGEFLHHODWRKKTYMLVPPNYKPCHXKKJYCAWJUPRHRJDJQMNMTJSMFLEWHLJWNNNBBLQXRBSIMGHXFRNAMVYVRFKCVSVWKFHTTXHTODXQOQXGKNPUBFOYYXPPXAYQWQKAJCQOASUKETYEXPLDQIUPWYLIYUPSGDRXGENJKIMQ
                *//*
                   * UDKGSBSEIORKLBKDGLKLQNJYAIRANLNYHXPXSOHUVTIYRSKKVWSBFFYOQYVLKRLHMPNEDYUHNQNWSVPTJBAPOIYVSKLRXBYHDNKWGQWADQWHGWUTTFRHVEKCILRXTUGRVLTNDLHSQMYUSNVCIFTBMRLEMYRFWQVRTXGOUBNHQMIXLVAIGQJYQYPDABVUYLKQUEXNGXXUMCHMWDYGPQKBEXRCNYKGXIFGOOPVAKOPOYWNHDJNGXSNUPARPCVLWCCISPQTLKUTRYYLVGTOMWYKINBVIDQJTMPXXJRHKRAHRLOGGYSGLJRSSVHJVLKVWCTRFTOBNAUNVHWWCAIDKFMMWYFDLPRKLORKAQUYDOYQKGBPWCPFPWLFTUXVUNCWVWIRRBVWGWWKEKMFJJYRQLFMDLATWSHUDADAHBQWIDOFPKSKLJRBBFAAQJWSMNRIUSXXETMSGYKGLPAX
                   *//*
                      * LOPYLSSRLTMRVRXQNXOKVQGAMPRRGYQGJAKGTODLPRKOUQQUTHOOBOMMDDVAUGXKLOMQLHNYYXJCEERIFOAQPXRKOWYWLSFWSBYNILSSRBWWKDEPSISEJEDGSNMWKHODGKTBFAEUHDRURIIURRNDHOYVUDKVLREYUDVGTANVSDIMWJIGTCUKDNTMTJQHDUOYLHAXSSLFEPJPTLLHTLPSWDBSCVRYOJMSDRGWKTTBHGJHXBUIWBDYDEYPKIPEQVBDSCNOLHABHWCJLSYJYADFAEWHFJWUHUHQHEDWBRBBPKLYVAXBHMNQRMRUEIBEXPEMCDYWUBUJPWIQMEWWUQFBYOLOYTNWFYWWYGXXPFXYPOQWNPRWKUXNWXFMRVAKRBAANMYSSSMYQELCEWBEUYTHXCPXUWFCJPEEONWKYHNHHKPYUBNFTMVBHFWIRCWJBXBPILPETAJIEIWGHCYDBFNRVVICIGOGPBDGHJRCSKRLOMJUNGJMGREFCOJQPRLXNKYAJNETTH
                      *//*
                         * WRBXJFPIXEJXABGYSOEQOHOJJNDDPMXOXPLHSAKKDDYMVOPHGFPUMHTYEEJHQGQOQORVPIRUGPVQWWGTAUECKBISUCAUGUXORYRORPLTVMYOYFVELKUDXXDPQOKDTMYGXEJKOTQVWWLDOJPCDSYFBYXKRIYERSCXDRMJYFPUIQNPOOJMPUNSSVCOACVGBBSNHGMKBIULPGQDYLFAWDAAYOCUYRNLYGGFSAMMOTMVFALAJVVYRHVQXGPJQNIKHRAJVKLBWKXYWSHRUDKXNSAAOEUSNXIJEAPOXDIKKLAGENXBQGVABXKGETHGYHTLMRGDCCIVXLQHFCVUAHLLFRIDNLNLOHNIH
                         *//*
                            * RBEFQPOBDUWVXDODRKFWVJIUCIUOOVFTYJLSFRKQGYJLDHUPHUIPQRLAWQBGDWULYIJXEHRCYBNCYQFMKPPPYHTCYYILWHSYAYPAVBDHAJAUEKNEEAFHLQANPXXTFDEHEPXGHMDALQPMRLBSCSKABDBMDIDPNGLWOUAXVNEIWRSBXKRXDUEIEJIWQLXKMSXIUBBRHDIVJUAYJJHXWAVEKCWVAQLQSDBJFWQAOQLRUMHSUVRWQXXIGYYSESOKNLXFMYBSXEWUSFAKPWGBPBPJMELUICOPTOXWIPPUAMWEQTUGQXVPKRHPRIWQCWEGCAJYPRMEVI
                            *//*
                               * XBPGRGWWCAOXYHUKQFMJIBFDWKVLVYXNQCXVEOKNWFUCROXJIXXYQLDFKLFHUBJNLQYWDQVHJWQPNNVLYKTCXJWCJKGOWPPQAONBRSALCVGSVFKJNEAYQEENIGEATSHONMVCJCGKTCCIJJULYJLNBTQAQBHNCWMPYQOXBNMWQLOIRDLQPYIRBTOTAYDSEQSWCWEGSBHGIYMOJJLKOMUOGJKPGUUDCKQICPXQAAPWXALPHRKLXCQLPOPGXUDEUYILQFXXCHGJAQOSIEINXKNMTRYYITRDQWCRRKUAKJKABELPQGTPIXSSMRMISFNUPBURFAQECFICRWQVFRORRDOEUEOEJUWYVHKDYEYNPFQDDDTNGCPTNEHVWIPTFLXJQHRBIRIESUMVGCIGRNQMDBLQERWOVLEPNDLKWNOCMJYMLMSAQEUKWABOMVHWLCMGFNTJAVYCNHMNTVBOOCKLEFSQGVDTTKYCAHHXWTGWWTWQQIMEYCLHTBJYGGNXUWNAPKXCCXLBGCPRDUGSBXXWHHOGOYOMHHORLLTQOORXNFQEEKJJCUXBNKVKPTMRLWMBLAXWXEISNMRSHDYPXJGWVIIJO
                               *//*
                                  * BPBUTSSTGXQEJOQKIYMYXUISUMHGXIXLKFGAFLGHRRYVDMNASWNTPTNAUKOCAKNUGSUKRDKJYJPXKOFPHOHVCRVSLXACAINQTOYNDUAERIGHNDEDLJBXOJXTBSXDJMGUMEIMQTMLSDHMUMFLAAXSWHIIIJTTPUAFEYXHKUNTDEJUMIWXHAHQSPCJKIFDRTYCWNTTVDWLTRRHYVBBYJWFRYBQHKSVDVNAPULRGILSMIWJTODIDLUHHGINNPEXYEVRFEKDAHBYCWOQLMGLERBSOFVFDUVTYPDAOALSFQAWQUEXCXFIXLIWFWBFXNLKWKJQFGRICRGWEBKTKTLBPPINDOFFRUWTJYRWIUYDU
                                  *//*
                                     * PHFQHINAYKJHGEBRAGGFWVDVGNFFDTBRHMXMMADSBSBROQDHQUWXCUGPSHYYAYJLJMPGJRJQBMHLLNEYATRADMKBLCLIJAXTOSMPLYDPVWDEBDFUYWDLASGJFXVCCLAPLUSVYCTYXGBHBEXVCEVUGLXXSGYIQSFTQYDYYGWSACWYEXWSRSSALEUEHFRGBDUEHBYOSJTHSRHAIHOFUGHBABRVEDXUVEDKRNORSAGRXBJBHTNOUGQBFTYVDJMSAOTGJSOSVIEGRJLGENQEUGKJTRNUDMDTRIGPMMWLXBOIYUNBMVBIYXVPRHIJFXMOCUGXCKTSFWYRGFTSCWYWLNUGQWQQHDAVFLPLYOWYTFGTBTWSKIJVYVCOIFCHPHEKJLUKJYVXXNQNRLOLRCCNTXMALWYSNWQMNKUSYBYUAQWSUBACQKYJJUDDYSFTBXXICOYEMYKULLBJTROGFMVQWXUVTOTUMGERXISTINMVBSFDLYFBGRXSLSQBJRIXJSET
                                     *//*
                                        * FGUFGKWSMBCBLTBALNYFXWNILJGHTWVLEUHYIFRTCBVSUYQDCNHLHNVTJCGOWFKPLCBUKDCXAADFMSYWTUFIHVQWMMFBOWUNUTCBDFABCBYVSTOFHEDWODFICDNASWEFJFPBHUXUFAEQSWBNYKPKDVNXQFGYMYCQTRJETFJPQLLABJXJNUALEWOAUDFXHDHNYCWJKFOXQHFIPCKAERJGVGKWXFMVGTGVOWBEXPQFDYMHJULNDERVPYENHOXWRQJAJBRQJTBTHPVLFUFXEFJXOCYYTELLHIAHSPTICESREISLWAUYMEEASVRLSROKREXYPACRIJVSSDPQLPMRLGFPXEPYNTUNHCFAKRDMGDUJINQMAXPDPYSBOMUDGEHMHGQRLVJYTFVQTQNVCTDIKPWHRTPXCQVMTXKTGGJDJ
                                        *//*
                                           * SRFAQDIWMIVUENWBIIRBKVNPPTNGVAEAYVISUHCPJMDECQSNSBDRCDXJWPNYBIWXEQVFRRCABOLXNJNTAAICIJMIUYFHTLHORLDCXUGQVAOOXTUMROXMLYFOTDBFHYWUHCGDRUPDDMIUMKSWPGVSCGKCEOXXRERCRVTSTSWYBMCAGLNXFHUYCGVMTAGKSQDMMICBTNLDPLTDIAROGWVJMUTASYQCICENERDICKJIQAIVPVAGAALGIQFHGHYWTEQXINFNMVWJQDQIFWCUVEHQPNYKUWDFFFSVYIKUJKXVFDDCMBEMUJKHIYPJSHOXSJPJQNUICKPWTNKBYTESBWMJFLYCASUBEWGAVLAPMFOUQGTLONIT
                                           *//*
                                              * ALTRCARBAKWWFUWERDBVUYCVJTQEFYTBGRKDICFOGLMOINQHYXYRAIUJBPVKPDYIENHXUXBIEXTVGQHPWKXXBRFIDLDSMLBHORXMHUXAHXDEHPSETPBQRTVECRGNDAPEYCYGAYUJTHGPOQSUOOOWJARBRVANNHIGEMUJUHPRFCDUQDUIKSDXBVQQMLNUKMSQVJEIRWSGVCKISRVPTCHJEEPXFBPKHAGOSBCWEHIOUVWSSSXKVQHSWXJUOUVAQPKEXNKRTYNHHHWIRLPKUFYVEEDKLJMXJPMLLCNUYJQWRTAYXAYXITJJKLJINOLKOPWXMCDNCSLABDTGRONWLNARPHWGGVPHQWCKILHFYXAWRLUMCSUJVPPHDCLRIYTOYPHFKESHEISYFQWHDAOIRHILGGYAULMJYFPEPHUQJKGFCRFRTHEYFJFHJKWXOKIQFYHTWSFSIHEBLDRILTTPNBNVMNVIDPAYXXQDJMGNEEMJVMXFEXMGDGTVPWQMULJJSEWUMVOCJDWJQPSSQVPBGHCKGPCVFCYSXFJBYCMORHFQCWYPNNTWMPKKUYTDVRLUFMFWAVHY
                                              *//*
                                                 * TWMBJUWGCUEDHBICNILYTCOVJKKGNYTIGCILUUQKTVGXJCDPJLAUTSGJLDLYGCKRNXJQJPJXWDQVGLELVAFEHUIGEJDWAWGLXHIUIKQPGDWJDHIOVQSMFSYOMIOUMFNPWSSWJGPTEKVEBREGCLKRKLSIGVKHEWDOHMOJKMCFWFKFIIWDGDXPQQLOIOQPWWMYOGSLRBOHFGAEUOAAJFXGHLGPGHARVCCQRWWMSTPXNPYIDAHJPBYCXNBFHTWEKSQPSQOWXTXCLNRRHEXTXSQVMWHAQOUGGKYHNQEKUPLMRYQSIVBEBWCCDPKEXLJQYDCFFTFSWDFAUHRKSSNPBYSNUWAJUNIXPDQVSTOTYSIJKRGNHRBQYFKXBRMFJCIMLRYVENMKBFUKMKNJKAIFAGVYFYGQVLSWKBPWUUGPAKOIFJJIDQAYEKMJYPBVFKUJLAYNYTCSDKRUSDNQFLSWOPGFPAFAHOMDCGIMICXQKNPELMAVRIKAUIKEKFOTTUCBKGJNGESYYRGSEVROSCWMSYHDQGKBSVLDWPSURIUTVASSPKKVOUOKADANTXAMGNIQXANYIQ
                                                 *//*
                                                    * DALXJXKXPSVBKAENYONJRMDXTOIAXIEEWEEGEONHXCRNEOOOCRQDWJUMQAKDCABVJCIWNKVLBIYGJRQAUFHPIKFNTEOVRYQJNUFFDRQSIEUGPVQEGCCIDKRPGXRJKNEPIHKXRJFGVBGVCRYGVWCAQQUPAVSIGIJMGQFCKECKIBDHJEYIYGVKYAJYJSTVAOQTAPNYWLQNACIRXSJKCMKQPFDTVJUTDJJTKOOLHARNWUCOELCGOJRXGOWJKSHMKDBAKGMAUREPJLLATELRICJPLNEGGADMOHMVJPEMPALVPCCFVAYWLIUBMMTMR
                                                    *//*
                                                       * CYNQWWNTIOAUGNJCMNXFQYMJTSESDPVUHPRBXRPEPNNNQMTFKEIGJLBCVSEADIKCNJNRVLRRIAKDDRURBMPHYWCSAEAUJAEYWMATWXYIUCIQMWAUNMREMXKXACHQCLXSWIDIUDSBURXWFNKULWTFKTFOWXRQODFCYVWFFJBREPUCKPWALTBUHDIULMASDUVHAEHVFCIUIBUVIGFLDQBQTTDAXTJHOJKLFIKBMDAEEWCUGUTAFDQSWCEGGSSOWMAVPUMEEVSDXACDINHNSGDCFHQFQKMABESCDEBOATNWSELPFBQGPUVVRFKHKKFKCKIDKHCCQETXLIDYRDHHFHCACDIAQTCQBCJTBERJGOQGELNMSDWFIMXLAWRVIYXGXOXCOLUVULMMCHXYODQEPHRXQMQEIFBKMDNNHHLOTEGBRJSYHCRSYBAFEADTEHBADMYWXKSWSKUSNMVYIRHEECDIASHCTJDHCWOWBIEDGPTMVIHBNXLRADMMBGQMPADMWGOQPDKWTHUKHUNPEULIOAMYFVWAEJEYWDMRNJDWEGDAR
                                                       *//*
                                                          * HCLBMYFWCTNCRWLEAGARHDSJEWTDPWTGSREOULAEATBXNRWYWAJGRVYOJXOABSOKECDXNSCOTHXYYDNHKCTSHIINLORWPKWKFTDERIGVUPXLARVNGHPEWTWRHPGTBWHSLQDIWMMPDKHPMLCWJKSAJFPPAFKHDJSSXIMETNIITHAWFSAWPIEEGLCIWBCNPPOFXWWQASPRECTRVHODUPVQCLWVONQMPXXBLORSVXXQQMCLEBBSCLIJVGORNWUGQNLIHMUWAJAETASELTIMGHVCCAEOGBHXTRPUEEJTKCLLCOGUTWCBAMGMLNXYYJUXIFXUXBDWRXSPPEYGFVFJYWYAJTKASAP
                                                          *//*
                                                             * OIWFKTNRNOORFIYJPLAFEEOYLQDSRWWNIAFARNDPTNNHMBRHVQKOSTXABANDIUWKYGUXDLPVVOMIHAOHCSTFGUBFJHTGTQBEUCGOMUTKESHAIGTJLTABWHJMVRLBDJBUGWVHFPJLGVUSCFIKMGBWKAFAHMTGPEXYXXNLCBISYFIQDYNKXMRWWCTTGXRMOBJKBEHUVOLMVFPSIAKIXHUCFHDWHVKSCAVOUAKNDODLNHQDQSAWDJMGGSCGAVXRAHTOFNGHQYGHCTVAEGPIGQMAJWXOASEDQVETYQYEHKHEHYFGATRAVQSFEMCWXDBADNAOQROVLIYFOJCQBHNKWCINUMJMOQERWJNFGPDLAIETKIMJERFDYNHLHCUGPGIJQYSQRVBPNBUSLYDQQPUAHWBRCMJSVDJOMSKTJTRWBGGQYUNKMWRTIPYEQCECVNILGFATKTGMWEMFSDKURYOXVJMYWLIIIXCLFDJEFBVFFKEWTQFGRTHEETIBTXRRPQBIKPVWRTYAUEKPDDHEXOVRNIPVERMLHGNRMQRDFHQSAMFMNENUGKMWIGMLDMXMEURPOB
                                                             *//*
                                                                * SFXUFYYYXGASLMRSRNSTEEUGYCXOSIYANEDNUVVLVGIGVVMUNCWPMDCABJXYDBDHWTAKGYKDQKPDHTTKFQKIQVVPPTHFBEIEBYWVUANAALUYKWUSRSWJTOGSDVJUEYOQPYCYQLCYKYHNXYNBBKWRFUQLTSRVIPKBCQYCMASUGMRWOWHONGIDKUVVGRFCPAFJDFDBPQGNDGHIWQXCXBYQHONQMEVFXTHLTYNITBDWDDQATSLVYMEYEFCEGJPUXEXGNBJWXYXGQSATATMGSGJRLTJQRWRUQDPTEBYEWUDQSCLNYBUSSNIGQO
                                                                *//*
                                                                   * IAOKNUCCDEQLSYLJUJSHSVBLDDSSMIMVVUVQFRWBETITXHLGRARTADJVQAQLIIKOUUHLQUUHLQAUAIEWFBPLFOKOJQTYPRAYAXDAKPTSDYUNODDRDBINLOIHBJIETDNYNQETIFPHFLDEUMRAAOIQJLGIGHBYBLSKMWQOXHACGREMQAMHTSIVBCFEQWITXNPHNFLGIMVWDXTPLAVRCUUJPAHTXADXFBVRIEELNRRXNLGURUENCMNCBDLSOJKGOYQPOWGMVRJHIPWYJBXETPGVORCWHFBCFCRHBVBVBHVPYIXEQLEIYLCQOANCHRSCYFJMHPGBOFISXBVNDXXDQPTHHNMXBAMMHVQUISKDSNRAUOJYWKGLOLMTOBHYJWJAGGHLFDFVRMNWRGAARRWPGGVVCMWTKLIFPVYPUWJWUOUNOWHXIDKMTJAJAGSQCKEBWSGNPKFCEPWXWWXQMWPEQTMLETTBPYYSQVTKNQDKMBCXVQUGAPYPKEOXGMUQBDRKHTBYEMTVCCDFHSDMPQRKHQGCPAADNGBXBVBXOYFDIDLARPUUFDHABGYDSERFJRHG
                                                                   *//*
                                                                      * QIIYUSNYYWGWTOSCUVEVHHKGTJGKQABTTBUXUFCJQANFOWRYDOTUDDLEDVAJWOUXWCNVVXYBBNDYXLOQXUBHSMYPSUUSHEMCXCPMWOGBCEHBWPMDJQBHOBWESWKFYNBJKWCMBUWHMCIFNVELPRWVJOYMTPKPIVWHSNOEQDMSDDGRRLNOFGBTKGWKEDOHCYENIYROETWNXDFRGAGMAFEAGOALYEANTVJBPRIEFQOFGPIMQKDJFQEVDABOJITMHAHSCTMLORLRJWAIGWYWEHVMIGNMPGCYLDEQMNHSIRFUNMQWWWVVOLFNIEWRBAMFUNGLNFKLFJJCPSQLVPEFABNDETDDTILMATLMEMYSTAUUROGUOXTOEOCSECOCUDESBFDVXGUMFRSHCEQESSDDATFIMJPYFVVIYUHNCUSIPGFHLNJQDSBRTOLLERAOYKBTLXRNXQIHUVSIRYSJKBWESKFQAXNKVWDLQLWYEOTFWOUDXGNGXRIHWIWHBPKEHQCMNALJIIHBOAMHPNWYPBNLXRKKAJQPLPDSSNGPARBUROOUCYMLCQOWBIVYVPGVQERTKHOLGWBRGLVAEDA
                                                                      *//*
                                                                         * ETJFBKWQNNXLJEBMBIQNSXFYBDSQUITXHNAAMIUBQBHHYHQBRFRXQFTXMLCCWVOAEXVKEWYVQDUGQVJKYFHOFAVFGIMIOKDGHWPYMIYEEUDEIAHNJGBCCSDAVGPMSJRERVSDXIKAPNJOMCIOIVISFBJOHWHHJHDXIGETJSVKIQPCBCIAQXXJOUGRLJSBYELKBFEKQACTWGYVGRGAQLDWROLRBPKOKAMSSPRRWNNTNSOBGCXRAMRRDHVCFQMSKAMTKRNSAWLCXMQOWWNXLTIIDMMCJWXOXBUURROGCPULPEYQNITCYCMWVXQGSSGKBMVVXRRMFNRCJXLALKUPMHUESAIRRRXBTSIWPHGCTIXPJWLSYYHJHUGYYUKKKBDKSGDULIHXIWUSRSTCUSXHHLVHAQOGFQEWFVSDYUQBMOXFCREEUTOMLSMRHDTCSQMJDCKFRWLVOHYYYUHLAPGRQFFRKJQBBVWFTCBQFXUNYBGUEWOVKWORCYBSXSQHPVLFRWKVFPTNBSKTWVLTCO
                                                                         */result.add(0, /*
                                                                                          * SYAXIXLNOWRMODFOGILNOULJXMRTTPNXKQLXATSMHKWFVEWKPTBXHLGDLNVIBQYMREIPOLQSVPGJHLPJSNRNQJHJXXCVOQPQDABGJTTADJHJVXEXRTTSKWQDVXMYTIJQORHYDMFFWEPVKKQIAFGMCHLCWDQRQMAIBUUIKVFQFDOJQFIQBICNWGUVKMUSXSAOULSUXWCUKVMUOFEBXWKPMGQTJBTJPLJUSYVUERBPHPOCXSBOBEMDYDQIXASFPNCCEQVARJBGJQMTAJYLCRABJJNPDELOMCXUUNNABUQTGJWDXPYLUEFGQOXUEGDFUMJBGIPRUWEOLWERDMMYNEVVVQKGFTAXWBGJGDNKQNFXUTWTCKFMHKXKBLDGAMVRVNIVECJCXAEUJOGDQEXUCLILESYBQWFHIJJATTXDPJDOFUEMTEIXHXNIVOBPWICYECANTRFIKXQAKUVUQICUHFNDIWYOSMEJBDMGPDTYWHAELSGMBLOEABKTOHRWPDBBRAJLPAUGDPMREYRRDGJIAEPEWWYGPVXXUKPGRAUCRGTLKWSGNCTYWAAMHCCHSETYLPOPINEGAVCDDTXPUAJNBMMUMT
                                                                                          */elt);
               /*
                * YGMPELAMLCNFFYOOGFVDJLKSPSYYRPKCKOEEOWXOLJBALYUFLRTPIKXOYEOKKCLCMPRMERVKRCRXVUFXIVGPMWKALNDVUGPCCIWNSEITKJLBYXKLDXNIQELHDPGIPSWJEDPXXVNTOWLESWIKIWNVPNSMNNCHCSAOPWCHHGKBQEQWAWMQGKCUXPSIPGKXELMRGGKXIFWJLEPWNTLOHLVHKHUJRXCOBQBBJOYGAAUDVLEGULFJABUPUHWIHSETHCQKBRXVNEQONSDEJHQFASDEMGFNMFTERTAOINOFWESXUJPFCHOCOWBKODONEDMSMXSRNEFOVWIRQTXQOWQSJVTACOUGTXLMHO
                *//*
                   * EXUMEFHNNBARMSXGTRWDTXXGWEGLJOCJJYCVPGRIAHIVJVPIKXXKTCXGMDXHJYRDQOXAULEDAVMRYJNLLWHVEFRPJVLGWLRCNIQNRKTWGRYADVCBNTEYBVDLBQBCGMQMSICHCAUHTJOBFSXWAVKJQHLMFWCLRSAQQNGGWXWLVWBTPDJKFAVDIRTNSUCMHTYIFLDNOCGQSXJYSSEETQWAPIXAOQKQYMVMFFLBXTMYTVFETPLVCPSAOECWNSHMJCPGVQOEIOTTXLQYCRETKCBECXKHMFLNONDXBCCTHUQHDCLAICCVGABQBBRUHCVKLSOCMPRPIGIEHJCOMCXFJHHVSLRKVUTEYHPFKIMAVOOEFIOCOUYPKHJLPMPSOSLPBNUPDWEDEYADJBTYEKRNKMROHGPPUOLCTAIVRRLBHUSTSRBLFQGCTUCEKSLEXWDVCXQUBERGXLDCPMWLMSIJ
                   *//*
                      * HRTNVNWJVVHYHRLEDVTSHAJMFSFWKGEWVVCYAUGPSAOSAOJBMRYBWWWGWMGBMYXHNHARMEBRMGVMDYLMVKAUWUJMWSCJOUQYYPYNQALGMHWLVDIWUELAFVBUWGRVQOYJLFTVKPABIPVFUYCJCVBQYVFLWUITKCFKISDVQUXFFMYDEVIOWEAQATINVRFCNGSQBSTDTWERTEYOAMNBQBKFFPRGQSJFUIVOJFVKROGKFWGHEINUHBRGAOVQVAJTWFFRYPVLSWJOKJLQGDUAEQJUJLYATGRLWWQDCXXLQTIIRROSLIGKPWISFBIWUJVNQANTLCUIYWDIXCHWKGEPWLPNQJURHFCSVJWKTFXVSSWXVPCCRKYVDMJDYKQYBAWWGIFTHMUWUNTHUIVMKHKMIPAIBRWRYANFUDHCXHORJBVMLCUYHJBCHYDUMFTRLLGLIVQXUNDQGXRWVRTJ
                      *//*
                         * CRIVDORKGEAXHWUQIVYJIUGCJNSJBECPOQJBKPFDEUYYAKXLNKNHIPVAOKNDUAEURLMUMSAQJJXJVMEPXTPEGIUDFCJTJAWYUYKGEPCARQBRDMJKCUDVCUVHEDRNIXPWWXBPOUNKRNVACMCSPAVNQOAKJROPTOKBHNYQBSIUMJLYKLLPKIEKYBUXXQJJNIHUVUBSJXXFQRYLSKYHVKFLVGIJOBVIFXRMGWTNBVJPXDLVQCPAYSQYJMHHHJEKEQRWCGXERNLXQWLVFMEIQDQBJXJVPYPSQWBFWAYUCAXWCLQSGDUJHDBGTEVXPGKUIXMBEWJFVRKJVKIPGTBNLEBHMWMUYAQAMTCVESVSANQLIBKUIQQCUBTFHCEYGAFLFKYFPIRUDVTRQLANMACBAMJQADCOPVAIERCXFNJUSXBNJULXKMIYBRGPGARFDLOOAYEJHJSFLRHYWLVJBBATWNMJEPTFDTUIFFTVXYKLSBSDBPFSYQSPFFPWDGWAIXPOVUDBUEBUVAFLRTAYTLITWCLMPUSWJUFDLNPRTGXRNWQBOBEXIDNFAKQSCVYSUYHPYFSECNSWNWGUBLNMBKDCYDUT
                         *//*
                            * RXIBTHJVHCWLUFXIGJEAVMMRQWVICNEIAXUKSEXLONGOAAHLFLINSMKWPRMJCQLWKAWPYHWEQFOPBALYHMDECCONNKDBXQLRTYIEALKGNBFCLVKWOHFCKBXFFDPVATBRYVFOCNJULJLALBBQPROVEJMWGRGLGCKTUGUFNHEEFPHVDPCRJXJVLUJCSUDTMKUNYSDFIDCMFSLHTPKXRMFESLFCBQIRTHIPOXXIACPCAWDUPURXHBLNNYQHGDMWQPOHMHECGYHFOELWBVFANGFQLEDLFLKJCFFTBCQUBTXGRSAGHXMQFKYJAFUYTVPXELIJQAKQQKSVNPDTCCDQDOUJEEUSYRRTNGABNSQYVRKWYRAWVWVTJOYUBUPGMALWQTWXTQFYVEJTBNANOLINYPBCNEVLWWKECJMIYTACHGSJTVTNJPQFESBIMWCJBPCQLCWQLBEIKVDWVIIGGHWV
                            *//*
                               * VCQSNDFACIQTYOVCYNCDFOLFRMSTUCHBDTFHDAYVNIXDOEXIKBANHXLXYCJXXAAXWQVIQEOOWMTGIGEPOIJHOGCTSVUOOEBOAEXWCHSEYIMKDTPWXKRBEHMWAKMGPDNQNPAMRDWDJWVHPDUTOLFCVRBIAIFMECADJMYQKMMVWNCIRYFBSXNLGAQTNDIDAJHIIVETQMALVTETKJIEXDIOPVLFSDREUSXSKSRPVKYHKELDESIVHOEXNCQTBVNPSLKFVMOCCLJLHKYVTHPELLAWXXUOMVPQYISOUBAUYANXYXQOULUWELLJIBDEIGYOLGDMFKFGMCJIURCQQLYUWBEHRANOMBDSKFMUYLUDUUCIUBYGSUKFQQHEWBILKBNURYOCMAAWRESGYJNFPXCJNRJDPGKSPKOEPQLCBOVHEDWDGRDEHJDKVIVJQKMOVVGNPMDAYKFJNHVGJAOEIHQKSMTLGOOCHSNDASRGHRTLAVVETGEUBRWTGCXXEMCRWBPAJSWVSYRPYQWNXLOOJHLTVDXTRWDLDQWJGVXNMQOJRMGHURDCXHUNWACMPYFWFDFDCORRRSEFROGJMORKRBMCB
                               *//*
                                  * TVKCARRUVVONFKXKDEEBOMSGXBYDYLLHQEPQITEVPEEBPKBTRHEAOSTPUSUHKLOEWNPIIBLRVBWDNWJVEIREQIMBERESWKGBLEDGUBXSKTAUGHMLHXWERAVCRMPPCGFOHUVCLHKQJCJGOPEMWWWHBMJPJKECMMGLKJFPNQSSRNQIWGCUCXPXSOVUUSXONWOXEQVLLSAFXCBNQAWKAJIIXSFJNFGOWILABJOASOFIJGYMJJVSUKDFSHADFPCUXNTXAKGMIQXKQGRHJDFLBEBAMBCYMHFGCFWDXOJBOTXFKUGTGXBLNSMMLVKQYKBDXTUVYPKGLYSHPESRVXTFAVAXBKMHULTSNHIDDKSWSJSYYRBKJSSUOTYIWPRGSHSQ
                                  *//*
                                     * JQWECXOQDUMKBSXWXPMWWUEXCTMVBJHTNIFSRPFIHCELKQJBBFIRCQQVDGDYTYTKLKJBIFKGWFVILEOBQQPHKOSOTSCNDBRULXGUKLXIPVJSPAMFALTCTGMRSKFFYFPNEVFCVBXGSFHWULNMNGBNYHRVCHIIILOHXTPGYHUWLXXMGQDDMTLWNVAHKPLOMVOVEORREAPMUXEKCXUUAARTGOETWFIVRSGBYCLUVFHBSTLBCECYUSWYRVBLANWEHKTFKWFLLTDRWTLXEONMQJQUPQQJITGLQSVYBASVDBVJUNQSVKKWXJUWWXPXMXXBONFUXAVKWPOMMYWXDLSFEXMILWDMEGMQUCWDEXFNKFAWWMPVIMNQXWBUJAFTPNGI
                                     *//*
                                        * MSVPUVTVPWQJICVOKUSXDLKMVYBPESTVXHUYDQNSRPFYXBYYKGRSUKLNPWCTTEJLKBSBTYIWHEHYEEUTGAYGOYXSEYCJFIYYMJEAVHONFTVLIXUAOWQUPJSBGEJPRPAUVSMMCTKUVDSOAFNYUPUXTGLASHOLTLEDEUAMXTFVWXOEJSVMVCUKUXKKDLOQGTWACVGYYRUSJNCVFTQXVDRWOQELUMALAYAWPULHTFVPPGXOWIYQCTKDTLWXYKPSBOJHTUKLMPUCQXJMAJOBKOVFGOSMYJYJFHBOGPITUPBFUHABXRURUATRBDFYNWWHINWUBNLIBHIYXYGLRYQESVBYWHEOFRWSHUVDMKSAPTWDBDEORMSXARNKMEAOOGSKCBBRURPTENJGQIWAINOYUWYAOPGEXTUKOPHLSTHKTDUSYJXSWWQXGIDHJTFCBKSMESMDNLGLDVKEFPPYYWGGXAJCEFGRTNGRL
                                        *//*
                                           * PVIECDMPSCSARROLPTCUBLKCGKNETSWOMFTNJWJFUXYITUQSOCUALPAGOEFVCJWPFINEUJXYMRLHNQRVMUDRVCTJAOBDHGTPXPAWHXATWJHDSOOWYBSWQFUQWFVPLCYCDRFFDRJNPUCLGMOQCDMFBNHMVXTXGOUVXVDBDMWHRWRKTQYCHVOQYXWVKMBEPFSNXQTIINBBESKSKVQYYGHKWXVLSKFFIPYCOQOUQBBASCUVTQCPNJWIRTLRRLJUGOCPQSRNKPSQUWGMDPITASXIOVNGFQEROBDTYNUILORVCXJNLPBJXXEIIPLWUHDPMEFCFELNQTIASXQUWDMYRIUGIRLVXBJDKDIEMJTFONYTLUKLAKXHYLLXICGOYCJECICIGUWEFEBNFVTUOYSJFRUVDXMONGVMUABNCVLNYFIOPWIEETWNQLAQWEDPJURTDABBAKSHPUGUWAIQQOBHXQUEAWTRTDDITFYDFBPRTGKFJIMTSPKFSHKJKOXLKKOHCMYBEQXYCAFVEEWORMNLKIBGVU
                                           *//*
                                              * XTQSHHLLDNTFPAUHHLSUOBWADHTDOWAIAKEUTYBKQPARKDCMEBPUIDOMWFUNSJDQOUTFMSMVLDQWQVXRJLGCPHBHAPSWKKAQMQGPLDEIBRRTKJCTNCHWNTYWBLSNJCKPKANNDNUFJXLTEKRNABAAAPWNTCNBHWCBSPPNSGFWVDUPRTWPTWWXFBONSPPOQPSKOLPAJSSNVNCBPETOHSKSAWQMNAKOOMEKDEGVOHSQWCBYTHWDIFVDGSXBXOYTIUMOJMNHBWNQRLYOSPBPQDOGDSABMNXMEILQGURFNOOIGSMDHFCUSHMLWKDKANXSTYQBFROKYXPUVSUXLCTORHXCTOSFHUE
                                              *//*
                                                 * UCFXQHJLEPMHFMWGVNDSFRTHHHTLVPLMXMOCDBXUIADAJEPVSSDCUMFQHHKSEJOLIUAHPFNMXMKEBDEEYIGJVTQDGIBEQHCJXNORVCINFTONAWITPOQAEUXEOEWLVDHYNMQLGPVFQTXKFEMILPRHHWHETLBPFUILKUERGNGJKQQCNURTOLWIMONFDBNXOLAGJKXSTVXFQODCKFAIJJCBNTLAIJTVAGNXWWCNIPUPSKRDBQFTLGIOYJTOXYJFODJPKXEQRAVDWUEKBSFOEQVRWDONLXCARHTLEHSQJIRSNAGQHTKYAFDFYKIWXNYKCECLEHRMYFVYUNUCTWWAXBBNWRPMSCJYLMXIDPOVGUVEPEXATXMMVFTJIOLDBLNHKCVRBCKODPHOQXRCGJDUJTALIMHSQYSVSGJHYTCFUOLUDLOOYOHHDLRYYYGXDTCJLTXCIAJKTVTTPYGCQTEXLSNVEG
                                                 *//*
                                                    * AGNGNPWCWSIXDLNIDWIHCQQVOXHOCXNAYQYXUMLILLABTXKBMHRMMYOPLTTBKUOBOWAKJDUMTDNVHEMVXOUMVSPSJNHKYCBWEUETNFCAMGYCTOFXAIYNLTIKHSIERWYOBVMQYPVANOTYPREKCOMQCAJFBWKGYDKCKGIEDITELHPSUWIXIWOKKVGOHGGGXIYHGKFNJPBNULTIVSNRKORXMSXOEOUXIBWEOGYHANLOHHTRVEIGHGRQUSDIDPMTARQRTHUYDWGYOHKDVVAGFIAIHEOCIFYCBDQFPWCBGXRIDGXEVAAELKMSVTKQEWGQPINWMLXANPUPKVCRRVOTGYKVAWWABQBYBYGYXCLLBFFWFTWYDDTBTRNTUKDVBCVEMKTEFBUXVXEHGMXWBMKLQIQPJOFRTDXLEMLTSJUPFFOYGPCWDGSJHQFKKODGSAUBNBGGVHDTJSRDAULDFQHMMSNJYDPWXF
                                                    *//*
                                                       * FTVGLEYPPUSNRMOHFQKCGGEMXINCEOGVELPQQNMABEKVERQVNRVAKGGDYMJKTESMXMIFHGJXOSBSSEHVPASBLXHYWWYODGXSLFXAPNQVJAVCYLYEXJKETHMDRHSMESDHCDWYMQUGRROOGMTKTDGPINRXQJSONMAFYDBPFDMCGEEDMBMEGXXRUDETFMCKNFQLYOCTCDMUGSVUROXRRKSFEVUSRHBQUPPVOUMLKMMIYKQPGLWIJLFLTEJDDMOWWOJPXCXUAJMXAKARBFINUAHJSKHJSWUNIJRTIPGXDYPOQMBVXMUURHYNBREWQFKPLCGNTQIVJXUOIJSUUTGRKNFIACNMFLPITEBNRMBHSTGWPEJXRNGUIEUNGDVRROBRHYDRDPLTMQOIUEMGEKCOVCCVXEVLNGWQYMEJBFUIVJNSE
                                                       *//*
                                                          * FMISGGKNTLXXBTJQSFOVFULFKMQRTPLSBDYOAHDCWOVRTOYLPWDIPWRECQYSTQUEWEAIVCKFMIDAYLSIDHIIFBKUQGBDCTOARDYYLJEMYHUTOUFFJXNLMSRYDAEKMWTNWPHWCRMSPCRLKXLGIPIHXRSQNWKSEAYQLECGSBNSDRVDDCXOVSVYNEFEFTUSDVKLGVJDURRESOKTPEJUGIJIFJNWUMSLVRUUYRHSNLOKESRPJWCEMMFGHTMTYJHCAUJQGSCRCKRQABXIXJTFESCIWCCNVIXLLYKNDOKHUWODCGYQBOVLJNXUYPOSNGTVAMLIJYWBMGIHMOXUUPDXHJOAXVNVJHAAHPXAHUNWFYROIQOPKUBKNXUGSIOQERUMYAXONUWTAIDGEJYCNTNIMIIFALVVSVSNOWVJYMLLIILTMNHDGAKAUQULCBXDLAXCVIXQQWABDVUINJJEDSQFLWKMYTMHRWYQDWYBIWFGMEAEWMYQIMVQFWBSNRRSIUWEAXYMTRDFASKDVOLKLGWYVLCRLWGJIJEXPGUFQLEYXPFTUEPXWRUPWA
                                                          *//*
                                                             * RNYMADUNKHPXAVBRUCPXBCTMVNCFNJVBCARMOTQJQXVBUOMNYNMVARURMUFQREJQBVCWBQFQPLORPLDACEWVCLDWHYKYRHJENJLAFLJWFLGWSDBDIQNKVJSPYWCHNYTTJAUCSYDCJEXAPUKAWNXOQXTCXEDVRCHCLEBCPNQCMPNUSLSMFKYDCGDUDSOTGSBBUMPFINNGWHMCHUOEEWWSLSFRRFDITKVJHCPCVKQTYXNVRGWNOFRQCNJEOHFQOOYQYKCMHEANWYUASBTKTCGWXKUITUURDSEVNSSRPGIJGHBXMEWCEALKYPIBBSICESEQLBYBMYSHJGAIHKPDTNEFXYDSRUDLQOJBCKDNGBUCIIUPITFOEIJSXGUEKBDPJYWENGLIVEQOCMNPDRFOPOSXXKJSEBHALEJQRVDFWTMSYXNBQNMIMMJMPMAVAVJXHPHNDDQEIWJLGENWNFFFIYBCMCEFEGXHUNLIYKPFBQGBAPLPAEOFAVNHGCNVTGODADQMYIVNCOCDWDXMYFYOVFLBMHGJOWRPGOQEMKXTYABGFWHWOEBKHMHKADFPQWDCYTRKDUQVISPCAIJAJPQVBOHNDA
                                                             */}
            /*
             * JXAPOBROVUWSCWKGQCVARVJAEOCGKNXEMXHJRJCKEJUQDAEHGKURDJMJGDJUBUXYFQCSURWSKLQWVOOBUDYLCSNPHXJVGDVOGBTPSAGTGLVNORAFOBDDRJTCTVBUKGSJYLTYYTRIAFEXNPKQVAMUSJIXEYLGGEYHPKWDVFSAKGDWVJQNQQRPSQLHXGPRIJFBUXJPMXOMNUGFBNVJSIDMYBCDUPQNAGGIASPIXXCUUJYJXAJCTLDSTLNBTUMLOWAGTLIVWXPFGERUHLVMHLGEJWBTFJDCYSLCWWKQLRDUMMGHLUAWQQEIQFBBJFEWKRISOHFCDKOYMEOPROTKBDMHUTIMOHOPAGHBYMBOXJDTPGXRLQOCEHCFFBKEJXTYXNRTVPCKJRIJFMVHKNDBTWJKBARNEUVRSWDQNRMKYXLEPMTLYLIYFPVWIPEFUGAHURYLNAMDHFWKJELGDEBIGGQGTDSAYVHTYHUINGQMCTDVOAHJNRMNGLTNGNDRLJDOGYXJTXNLPHDP
             *//*
                * HQPEFSFPSFIWUCGAOJVTFSNLOWGIINJBSXYJEKURMWLKNARBIKOTVDCEMAVQYSIVBHWDFDRGSYPFNRWFAGURNCGPEBUYISMSSCFTOKUMKPFHGEHRHSEEMRNYXSLCOTIKNFPBSDXLVCHGXCXGHPSMRNQLVHGVNGQLUCUICYTRDEHCJQKOLUSUYESVXXSQXTYASPMYRTYIMQQTAUJCRWXKFDNCPMNRAPLWSGJHAIQGNILGQAWASYGRLRFFJORLPLRLETCQVQTRPUKTQPGSUVKPVJKCEHHMBQSBHPJCCQXFMVOFEMGEIDTIERAQAGFOTYWKUNWYIXWOERFKRBOCLSODSENCHSFUQAHOUPCQATCPDUAWWPKCDVKRTSQCODIFOCPLRHMWOSEGXCDERRMBRTBWPCACJJBRSANUQDGEKDLHOJYLWAPCBRARRUKYWRGWDPVIFAONMNYQIYIESWIUDBLBXDXXQYYUCYUOHCXFHCHLQRVJIVXBKUJPANCHTVBBRYVSLHBAWWTWIEEVRGRHN
                *//*
                   * PQSKPVKWCIDWUBCOGVYFCSNFWLJOEOHXDTWNXUKBFEXJYJUCNHDRMAMULHGHBIOIUYQPJEDDECSYWTKFIXENDXFRMRNKXPMIGBENDYOQLQAHDWYIRWCPLIEFGUCKVPGLPQFPUSYUAIJUCHUDESHEGBKDIMTLYJLABFODQIAJOTLCJCDENSMWVPIBJAAUYMXUHQBFWWPMHNNAFYHSRWXJDYSIQECYWJUVHLAHMODDITWBFOEABTXAEVMQHWTTFCGOUCHKCIQGVCOBGYLMGVPXQKEDPRAUFJEEVINVYCREVMSBGMWXBTJKEQAQVVELTUYHVIYCTAJMKQUBGFHQSHQUXONFAHNKJJKTRAXVAPRBEQKHUSDVLMLYJQCSYOCPYOWFJNNURHBNACECRWXACXOACFAXJFMHSYRUOPJBQVUWIHMX
                   *//*
                      * LBJMFEKHQGSEUQIMUHDFHYMTATDCUBSVTVJVTFCQPARUXSBFFPHULYHRWFQRWGDVCOFCTBOIUCXFYHNYVJOIUXAFWTNWQQFTFGLGWBJTMTVSGWTIYDIMBUFWDFVXOBRKDBQXTBKKMFSJPVGTNBYXJTGMYFXYWVCBYWTBWXLFSMEKUFGOYTOCBOTOHLIUTBCYYSTXLGJCFUFPNOUWVFWKRCUMPEGGAVIWYLYQGTBVHSOJHNRXTRUJGFMIXYSXKLNHTOAMXASTDKXMOAGVXLWKYTTWKIHDPVSYDHVRDSWPMRKLQHDRERFNQVCAJAGTNRUGDYHRWBENJHVIYMTOJADRURSBSKYBOBJCPDUNYXSUBFDUHUIPNXDCHJYXYPUYPGLXULGDVANHELQEWBFNDWWHNYTLTEATCCBYRJKBMNCOQEMICQINMRBSIBIBSVVALITYBWR
                      *//*
                         * PDPOYAABYRNBLSNOPWYMANSWUKIDINHHBIQNEXBETKKJNOAKDLUYUPEVKLHDRHNRWQNSDBJBAPUPWOAJSPYHVRKSBUJLEHWXCBYMXUEHHKCOVSPGXGLFNYEWUVHEAVWLDMJQANPLJXLGLQQYMMYAWHBRPVTTGDLQVUVAQRNBEEHKYNQIYJKOAQVUPIANJKABKIDYKIHDPQPOSTLJCBUBTCNBSBNDPAMPCLXJFVDJLXOUJNSVCTXHYCYCEMQRQLQWDUQIHGYLELPXUMSEMJMDGHFGAVDTNJMENEAMGWPOSMPKVHEUUCBYBTGHATXMEMKWXSIEOAWCGKFOYBSLRTYFYWWGDKOLUWCYHVVFQOPJJEFQPBSMOPTYFITIPATJRODXBJRMEUAMOOBGXXFRNRNDLHRGMYYYGUICMVXIYDRFWPJYFIWRSMLHAVYNGBHKJDGTAROLEQUYAEVVELLOBXDYSRDBSJJPQDQYCFUTKRKYUWRKPVSLVGNHGTPITSRHSIEVLVKGGSPPMVUVPQAHDGKGHDSOOQLJWJBDREP
                         *//*
                            * TFWAPVMFGEWDKBBYCXVMSPFSHPDKUYAOTKIAFSWGGHEDUKOBQULFFBEBFURSVHYSHPOJGDICXMUIXSEENMIIOGBKBIVAWQCHOKCDNHMDBIUSSIXUBGIFOPWOMKYHIWREFYAJADUVWVUCLUWAKQHVXQLFHYKEMLWADQLTDWCCSKPFOTKIWCWKBPYDSAOHGGAVGMTBLPQMULDAJPRUCKFBFHKENSJUAQUPROVVHGRTOXPHNXLKMHMEABOMFKXICBWOGEBGBQFVUUJGSYAJLSEPBTBKVRCWCIHBXNIFBTUPYJUFTKKXMHAFKSVHGAQBUXAXCOMIKFSALGPRUURJVYHPUTWWPUYAWCHNYHGKFRAUEUOLKLFHODWEXRLSFUFAHXIVMWBFYUVHCVXKOKUPRTHFT
                            *//*
                               * EBLFCCPPNRHONSQUGYNWAQDCFFDFYJLLHCQEQGHEOOIKFKQAIREYMNQXXACKIEOTATFMWTISJAJDYPEFIVIFITLVBOHPOXUFWCGHPYYFOVDXKACDVRFEDKWFHDBTJMBLXSFBMSIGABNVTTGQTTBQXUNCIXSDWUPKSQPLUJEUVRKUWYVBPALCVEVRETPIBAMLFHGBPCLKLDXAOGKDWGLBXSCELLOQXRVEGMXASEHXGGAQTWJHOOENGJOJKNKKLYIJEPNXPHIQDKEIDFIHPRDJWFFPLFDFJMWDLRJMGQFKIDGNMUEJALGCDBSQQNYBFFCCPMPOFUVEJWSGICBKPGJHCSCK
                               *//*
                                  * XUAHSDFBTHCNXCMRWIQWEIUTSLNGYPCNNQJUOWWDMTGVMPDVUQTJTIQDMUHCCLIXORWAHCGFYNTQGACVQINCSKNHCYKTFMYTSAIIBFXXBCPJPFIXHUYALXDBSCSVXFFUAFPPVEIGAPOFCJJIVGDIVJNDJHEHMAELUNKQPINUFRSJMLCCJFPLYMLIRAJIUHPMYJOOWBHDHXGXJOWDWASOBPRYGFMQXQQLKIXEEPDINMFJGCMBMEOYTIKMKVPOVGTSQYCFVJUFIPQXLLGGJKNEOCQEYNJGQRHBQOALXLCAHNLBWQKHBPXXHTAWGKXBRPADENGJLAJRLUGWKXWAPNPGBDWWRPKDJNCFHDVPBDXVYVNAFFBFSOKGHUGBGSLFAJWOMXTLUNUIAOLE
                                  *//*
                                     * RBMRMGYNNTFCMGKVVKBOOLPMHXCHFDCKPQRUHQBRVCVSKVDSNYQKVXJMSBTXYWRLPCWHQEIWRLCYHFEXXLOLHKOJALGXLSRDEGJVJUHVWPEMWXJXJJPGXHTKFTALAPKIELPDWWQGRTCHITBLJUBVRBJXHXQNJQEVVCXPLWASTWRFTNDJMYMOJSDVXECYHSPXSJPFPKDNDSNPOQNPEGILKCHJDYESTUTJIIREVWIPDDJIHRXGMJNJVCEYLAJRBXLQSETPMIHTDUHNFCCRBAWGKTXJHLSQNELKJUHLGSPOHGBYFDILAMRMITSLOTXLMYPHRUFETHDLTYCSWCTUOWAPQRVDUDHQEAGHMBTSGPMBDRHOPORHGWDYSGPWWPIUBQDDHRKEHBYIORJBPWLKATMAYRKEHTDILG
                                     *//*
                                        * MBCORGOFWCQFXFFWGSBQKDJLTRULODYILBBHIDLYUVIUQIISJLCLWTFMJHMGNYFAGXLLIIQPRYMMPCORVLYFPTJXVKQBMLCKGSLJTPFGTEIIKTNLAGYHCTJWYVLKIOSOAELKLYFREHEFERHOXTGKAPJSQDICSRQGELVEJGBNKYSWAFCAGSCOYXWTWVQWFJCTHSUAPQMHIANNISKLWQYWHDFYJSFGBQHPHVTVWWWVCNXEWHYLQJXPQFAYWLCJVQPKYOEFLMMFLBDCBTBBNKYWYXYWOLYLMNHCOTILBDEFOQRBMYEMTQVCLDSPQFYNEEFWHRWOXXHJPPQDDXQGTHKTRAYMLAPGOYLXHDAWUPRHYQUEIOBUPUDBIJHXGLEVCIAKBDKSQGBAYBADYUTVXAILNGELDXPLEDLESXRIQPVQIVTHWQLLDKE
                                        *//*
                                           * EXYUQTSYNHEKPCWKWURQKBPLABJIKKVFVBSMXGOIHKABREXIRVVLOVOBVJCIYSNXOQKQCUNNFAHGBOOOKCAYPLONARFTTNFABNVTOYPJRRISYBLPYAPVBUBJSLSKYUYCWYWJUOIGDLDPCBCTGKIFWTBDUIBXWUCEGXJXXYERSHXWIQBGNYEEPBDRBUHHHKGFVVAYOSUSILAHJSTTXVQITBWDSLJMAVUEIGVWCFURAASFDFGWWVGGESKBORIMRBTDVMBUMIXXWKLUQAPDCUNPIJJXDRAIJFGQOYVICXDSIAAFRXFYNTSWSAPNOHYNCVPARBKXDIFUAPMXRIDSNWSICIOEEMYKWFEMSANMQGMKUKVIHUTGDNXEQMYSQNWSLXJIKFGWEEFUJJCBJDRUSRPODHRDPTGRLDYVGNPMOITFGLFBFUPNMXDVIJWIDYEXWRQMCSQCJJRTBBTJKEXDTIHYUAJJFQILDSRUDHDPMXESROYRLYXYMBNONPOKBOJNRBRAWNTTGEITDWHQCSPBVQHGSGDMVMEVIBVDLCUSGHMINTMLOHRXMJEJMEEOVJSBYXRJKFNWBAPNQDOLPOCRY
                                           *//*
                                              * OXQKWYRKAEWLYABQOFOYNQMJAKPYVOVSUBKAXEUISDJHIDYTJUTCIFHVYKHRWKJALJOATPIEYNOUWVYGNCOBXPTOIJLJOFVCQWEIVYHCNNCAQOMBQUVFAKIGEQGRHYABQTJSATJQIFHGJPOBLRVRYYNTPSVVCOSTCEDTPUNMHQUXKIHMXMPJIYGNNISAYYYWJEFLMBJPYWAEXUSCRKFHOLIBACWPCJJRMHSPTTPQUNFEALOSAEHAAYOYPTHCDNSWYVIQOMRVAXTSIMXWMEJGKEWWGLOECIVJOCKNOLXVCVKSERACDMCEJBNAYDITQRLCXIUSEWGYOPCUBLISLASOQAVKXRVYQWQXUKCHBHETIWVWQJFAJR
                                              */}
         /*
          * TUWEEOHMSLABFOJONGYLOSFGQOQIROWVXSWLQEWALJHUCLNLECYJCJPYCMYSTYWCVXLSJQHLTAJDPANXNBTJQABGOHYVWVICBQUWNQWFAIBHVELIRQPOXRFKCTSWFBEOEYLGFIIITALEPUIBSDEWPPNCBOOHVSQGBMGRQXTMFEYOLWRWRVSBVGVUSNRNMIIJCUEWPGEEHSWDSWETHCOPWEKDHQPEFOGRTFPQRSVJDJWIKPVRUDWILTXWKMIPITPHCXXAATBKRUPXAOGIKTAIEYHJQKOTXLVOCBPPHLSIYIORFDNTNQOWVKGYPMUHSMSYDHWWNAKIYEOGAAKVTOOYADRJCSNBGUDCSDUTFSHABVUEFAODVKDHSSTHFVUYVLYDIWSWUXEXQPNHVREUDUDVLJWULRFLMYQNRYGPRKARGEVYAHPLPDJLTMXIIJCHOMUIMEPGWWXHGAVDIFIXNWAFYUQFRCITNIUGPJVQVDKVBYQFKYAPRAHUYEXKRCBLRCQEBME
          *//*
             * CKGTGNHPGGNXHWDESQEAPKSRSGFYINMXGFRFAMYRESMVTHNASAIAAYLNTCVOHBQQPIXFMKGEKLVDBPQDSJRFHYXMCOKPGGRFHSSJDDBGWMCJJHRFRPAHIWPEUBMFWOASOQJVEKDJLLADKTETRMUCSISJUJDIDNPUPTQFRCXDEWQVVQLTEIATVMTHVTDAXFQCXOJWPGPPYCCVXNFHASMJXIHRIDJPFQLPAKXJHKQGRHIVGTRKLQDQLLXPWDCTFCBRNEXJVNVMWXRVXXOBQPJTAWIBILAGYLBRPJWSMHPLRKFWTDAXXBXQNLDHBKUSGWSALMXKXGDUMUEEVKNQCKVQSQYVVQLEJVWAPFGXJTTILDNIRSBSSGKOYOQEPRQWHEUWHMCPNJLPFPQDSWJSAKMKFVQFBJDGGV
             *//*
                * PRCPFTLCEBYBXURVQAAKNVQRJFPMINUPPFASXERHDRBWGXURDIVAXSLAVUGWRRADRWSMXVTRAWALCNGJDMUMVPXFSFYAASIILSPDHYOHVXYYCKJIXIQUXGIBYSEOPRVPSBEGLWNANRXBATLPXQTHJLYRFGOIXTYJHBLMCHKFFRIKHUTAKTOJWMAJDMCRSFBCSTBKQVXPGFXKOJCLWNSXHHJTRJVIWRLDWDGIWYMEKQJAHHGMPMLESHWQPEGJCQBSSQMERYMNBDEKPSEQYVCHGMSIWASRGFQGKJLLGSVIHEKVFERGTRJRNJJGJCJODWLPUVNANIXWPSBRVOIUHRVSHFOTYSRJDOEWVTJIOTJBQVIBQBVSJWSBJHROYLOFUYHWRQBAMXFSXRKRGPKAVGKSWLXXNYDBXPTFFTJQOUWCDPQPKDUKPRPQKRSTNUMUDJVXRFJYUAOOWQMTBLMTYJJXTSLDNP
                *//*
                   * DLJELGUBLPOTOJDVCFLWQGHARCQRHDAOEMVCHFKISXNDPBBHTYEHPORNMRADRLISIAVVIVSYGRHJEBADLGLPHLMALHWSKPICBAHBNVCMDSEXUHFHCIPKKRGCSKNUIPSKVHKDMMRYQVOMSYPIUCSJMFNQXVBENQNXVPQPSKUPJHUQYSLTDFPYLIYIVGFJRXTMBJMILIJRGYRFPYPMCDPGQGHHKEGWBTGESMVNXANBKTCPGBOYDTXTBFIXPTJAJKPQWEFPQESHHQNHOMMOKUVFGVTSWWIAWBVAYSNPIWETVCPMKSMUEOFYGXVGLDOATLHOASGVGJMAYEAWLBSGPQQKYGOLMWOYMLSKNBLOCFXGMQAOSEPIOVVETBETHGGTAIDEFHHQHCYCIUOLWHOVVQIWYGJKRLYXNJLGAVEBIYXISTMCTUYBEEDWMTYUPOPSGJAXQURMWDENBHOIDYAW
                   *//*
                      * YPOBWUMKUAOBSYKENDMLMAIWGOUGQMOSRLCUKTEIBPYXYFQGRMATNGLJHNAPNUXEHKKFBBAIDDYJLWOYQDVIWODMUKLSGATODMGQTUHHGLDAMFOIUHFGWPQLAIVNQSHNBDTLNAAGCNGOKTKBBLJIGBUTAQPHJOQLMTKYEFMYIDCSFWPQECSRIHJGWBNGRNEWCFPLECNGYKBGTXQWIRYXSKWJDKLIBXAXIWLBHHSBUODQCAEHYVYDHFLGTHJJJUMXEDVWEBDIVWQBQOHGNBDGLRXLTOTVBRFQTYSIRDVDBESLLODEHFTLLITNIPNDJ
                      *//*
                         * JEKBWMOFQUNRTQWLHKEMHJPODKAMLXULNJEPCOTILBJAAMUMDVUHBCIFDYCUYURGREEVMSNTJUAKWXSXXBEXRJUKLWJMUEGHITXYHHLEHJJUVVBYHXMWSDKCXQDEIRIOLLPTDSRNCLQHRTBLLFRPDSGTOLAQEDLJMPMDWJFPEMRXTPJFOIPIOPXDRYMWWQOCPIQPCJVIPXBGNVIHTNLABDRJIVUAQNVWIGJSWTXHHMKOJYBAVLFKNGGMINOAJNMDGSNRKMNNNCMVVKTPUTEMJAQCGEIQBXRWGDKAGLWCFKUHYHIHKOKBMMKVYVBFUSVWRXLIUHLVDSNBHROPAGWJWREIDOGRPHLGGXOIDSXRJURRNSCFDFRFQFFLPCHRCXMDDIRYHWKAQFDICKJUEVRTIYVTMMMFCUBTQVVWRPJRXVLUAFMEFCGHWPRL
                         *//*
                            * YWVNLADVHAHBAXTCHGJVIVLSJDOYDGTUIKMPFIVOTMLUNYUHGLIAKKUVVLJSHIYWTSWXVHPIVVNEUPOGFSVLYCTISVJBHYWTJCCQLGFGMIGMAEGGTIIFTGXGKJNLLUUIJPNEQQAWXEYATAFRBWLBRBWTHSNYPEQEEMHDWVRSHQOVXJOMYCAQIVQCGNIQELDHBWNKPKBNUUPNUMGJPQYNEMRUQHTOOQUGXLSJPLTJHYYQHDFICKNGLDIMRBABRIGAYWLPSNUPPBUTIDGLVJEPHMIKVRUAIBTLYHMGQTICPLAENT
                            *//*
                               * EDPJTMIOLCHEVIKJEHTCGPNGEYTBCCAFRRCSGNDVUXDWDIPNEDALOCEEQRYGMHREWJTHYQNECVFIEVKOCCTJJCQJGLLOIOPLLWILDAALFQOGKUTKAGKLFFYREJNYUVTLCKFXJUWBLOEIODDDHWNPXBYPLYMNDPIIUGULLYVVEWJXHEHBCHWMYUARRBCNXGRAKELMYBSSBDFOUIFUUSJPJLMJINMGAMGYVBOKXSMYUSGFIRGOLEJAKGQYPKQEGBPDXRACDJPVPXWVQOVLVVPSAMDLSRQFNMBHIOKJIJLYEDTAOAOJTLWYBTRFAHPKSTLGAXMQRNVECBJEWFUSSSHNSPIUQUNTHKHGCMMOSBPIDRYLUXWWXBYOURXHVBVWXMQPQRKVHYCDQSXSOWNERDWDWETOEUANTAFAUHLQJTWEOOOXHTYHKVJTLEIPHKIDIVVSAMSHSTBIEBGH
                               */}
      /*
       * ICGVUUFEUVDMRQGMNSXYSBXGAKWHSSHWODWQAMSFYYBKEGULRHCYJXFCXAAMBWBXDISHKOTFLYIISWQWHJLNGDALUHHDLWKGWJUEWNKWPLIIISIKEFTKIFDGVOEVGWJJJALQEQKBAEBWPWRFETCEUXKRQIRKJHDMQWKHDJCXNAQUPDETGLEGBSTJHCYMEBXGVKGRSVONUASBQBLTBHMGGMLOCFXFTDSFAUFRQRDYHWOWXOILNHARMWBHKCJXYFJHFYQDYRKEWWDQXSDEBWBMSQNMMYTPRVNCRBKAKCHPOJMMUKCGDXKOMCGNEPIEXYUWHFBUXXMHST
       *//*
          * XCJCHNOVVHTIMMQGAUCHFOASPSBKHTNBMGSLNESKMPIYMLQJKXTXBSPIDRGPWEVBXIGIDPYMQDXAACRUONAFBGGXSFPSXSHKKHLVEKYALWAPRGFWMJWKWOJCSGVWNDVMNJYYROUYVTYXLSLEELWWEJRPQFSYQXOJKXACGOADNNBOIRFLPEXTEKUYRGCUUUWIRWRCHIGJVVUPLMCTELXOXNQXVYISBUYXJLQYAGFPOAYFCPSJPCPBIFBVTIFQIRDUWMWRPSJQEKHUTLLWWMDKQQJMWOYFLFQUFLWVGOXQARIGMMWMPHSNRKUCXSCRLVHIRXUUDPBBLULSDJJYBTWBQSBIDLEXAXVJJLKHVBVWWQVYAOQUADQRQPHBKLDKIBFGGIJLDDIWINVEWKFPLJGWUGUXNEFXNASELVXSWBRVRPSPCWDJSIDBMFWHHE
          *//*
             * PHUYFGMNADRSNIUEMEGYACRDSAMJEGLBNHDBSMKSKHBCHRVBSOFTWEOBPDWALNMEPJSQOAVIFSSNWSGQJXOLYHXSSSJMUYOHJCFQILWMSLPWNSIOEVAOIYGLPQKLSCSFIJJTIQVEFGTDEGRPDXNKAXVWEDYFYCMWAGPGMEPSEGJGDWKTPVLLIBJTSIMFJUDCJQGHGNIPYXPUWFXBVNUCAGBXRTKGOMHULUKGTEHBYJQGDRCAFJUOIMCTNDVNBLIWCCRJOOVXDRTHNIFKBQGEEKQJQHCWIXVYDOWFIBOHAAYTLUGXUXGODJGNVGLSMDIJRYBRMJNDKGKHRYFIOQKSLYXWGVHPKICQXSBJTFCQBLTSSSOKGXKQNSQEPQQKBHJNHASWGFLVJRW
             *//*
                * OPTJRDJFBGDGHOBCQFRPAYRHUVSMKLEMTYMCCIBBCUIOFHYGSRAQVMHUUSKLHLRDVAPMIMRQJEPODYPYAXXGVXVXTHWHDRRFVWKWSUBQVHLOTYKCSSINDSPOJUHDVCBIXWWMYDOHKMLQCSKXKEHYHMGHYHQRJBEDPEAYYIHCQWWMHMYABCHUNJMRIXMVDEHKNMWYSXIDBTAQMDKMKSLOLKVHLPFTTXWBWPGAFFDCCHLNYQWFIFVNHAFGWNXHOPUKMIEDBPFKISUXPPFVMOVXQECJBUVXHJJBQWFKOVDYWEDGCHCFVNVDQHDFPXNXOJXNFSMOKYTYTQAHVJVAWOWNJNUATHVWVDVOJYEGNORXKVTCJUTMLKVKFXAIHRAYVPKAFIJKOBKAMLOHRKMCKWARATLBHSLNAECGXDDSUASYCCIJAKBAXLIRVXNPCIJRWFCDNYCFKKHKDIAXCLCAFPQONWRNRFMWBPSHOSATOSFMQFXXONYOIIYNWHQLDHIYYUSCHGRWYAJWLUEKFUMVLILNJRXWDVOIUOMESOPDPNDVVDLTSVUNNCWIEVQFWVPGPRDFXVLSHCUVTQEDPIG
                *//*
                   * ORYKITPAVTAWSJGQXWVUQUODTQVFJKKNVYVCLFGAETUEMQMSYSBFTPRVJAKLBUTOTDKWXJADSTXVYGIXXTEYCDGLAUTVJNSUEEXCWUYQWYBVFSSDERKRCUOUFTXCXKCSXKUUJDHHIPUPNSPEIUOXEVRMSNIYEHKDVRTASLWUTOUQSRAARVWGMAMCCKBYGORQJJMXFROHRDAYHDSBGVRHYEBIERPNYIDUXJMHDHJWTJLHNALWIMSAHSBTPDVRIQHFPLDKHCWXABIFISWIPJPRVWMLSAXTOQQKWVMFTMQBUGSUJTHHQYLOMHOWHCCQXXQIHLSMNQSTGODNYOMDNYMAOAPRCYLWGJDYPTAQGCWLIKWEVRKRCFMSGGPWDUXITLLXWBOFVJYHEPGAVLVDIFDVHDSSFXYIOWGGCLYECMPTKPXQLAQWWQGCJJXOANDGYUWKFYVAJCQCDWFGCDGGCCXLIWWJWDDLTPSILRWKFUTKGXH
                   *//*
                      * GFQEBXUSVHMYJCOUHMWIKXVILKMSEAHPCYIKCLEDEOXONYSMLVAILCHFKKCAPSVJUKGWSTCOLUCROQKGIMSTUAHRSIQNTIWNKIPAVVJUNYXSAMKTXWNJJXLXCBTHOTGKHSDXDXVEKMHACXQRPKTLWSEWYETUPGDVLUFKAEAIMVAMRJJHLASHIFWTYIHVAMLYMSEUIXLXWHFPOCSNQGUICNLALIMAXVHBBCCRGQRNYHUAXOEMRQVWIIREXMFHSCFRGDGDAKYCVXAROLYFUISPTFLYQQHGOQNUSYYTPLSSWSPRJQDRJHDFNLYGJYC
                      *//*
                         * PVQAGXICXOQWHTEOIGPXMILUSODPHKTDGYSTRVMBSHUGTDOUKEWUKLUKNWRFBAMBKOLRFBRMQGKNCKUMYRXIUKNVLEBXNKTLCSYDLKGWNRBRXXXKGNNAMGJBDJYUOFFPTVQNKCVLTIFJUHRQORGMRPLBKGBHOURWGERYCDTEJEQDQYDBTPHPBXORFJJWURJSRRSIKLXGGPNNNPCJWULBLBAYNRJOAMYXWJRCFAAFLYKGBFYBCLYCTBVNYCQPNYECLVJCHSHDEQHQWHIGDSTICXJUOFEVTNYKPTSVUKPMGLHHNVQUGOJBNAMWRMWERFKKBEHDUDJXDVRHEIYSIKUTNEXOJAXPETFJNGXLKVGOCCINBXEJKRHWGTRVIGDDTHGNVNCERRCNGMJEQYWFIYVTVBFNNBIKBVUYLAENGWKGDGTRQDKJEUUTUMQHDSYQNSXFJXWEKVSDWPSQMKDNXESXYSJOFCJYGWCJCCUDLJJKNNYONCTNUWEITOYJEYCHQOPEXRUQTAJAXVPSL
                         *//*
                            * NVWMFUHRJRGDWKRPNXQIEJSSPMVTJVYXNWQLUJCVKNNGQVBMYVCPKBGOMAPOBYNBHWYRHQNYJGYBKDXAUWHTXIKHVCYGQWLNCAYWRIOVXNYDGHJSYOEJNBGMXMGWBEOTLOAYOVDJSSSVNSDFALAOLAWDGQCXEAIVFTRTQWYJJIJMXUGECJBWNYUTWRUALFAYTCDWHMGUHQNIYKHBBCHJOPNAULQCDGSXADXNLYVWLJNSTJFFLQIPAVWJQPFYKQEOQMRCQIIIUNRKJWEFMTNPQNFQLDORTMBFDSYAXGOGEQXKHEWYYDYVAWNQUCHTUQQDTMPKRSPIIQEQBGXYNATRSSMBAWMV
                            */return /*
                                      * YBRYYPNMIIKFHQCPJCTWTGVQWJANLGKQGXKAHVOISTLIUCIIWNYXWRTROILPPYTYODHIUKXAJJGWAPUPYSDQOQNOLIFHLNNAQQMRTXEMGSWCHOJJMMJDUMXAJDXIYPBFKDBCKWCJIRAQIJUXSRRUHRCPGIXNLTOPQVQPOQURUWGBUNKWJTJKGAOQERBXHHFYMTSXHVVWLQSFHRXOXOIJEFRECPCPCEWQGWNKHQBRBILTDLEGERMRQPIVYERVULWSNNSCFOOCYWHCNXMVNQMACPGFGLVVMFQJAGHPPQNUGEPLJPXMWFFVSDYVAXHSXJVKMUGICTLOWBNQJIOJQHSISXVMPVXDAMKBLDLWCDBEM
                                      */result;

   }
}

// (TODO) Documentation de la classe List:
// Découvrez la ci-dessous.

/*
 * SKIP NAVIGATION LINKSOVERVIEWPACKAGECLASSUSETREEDEPRECATEDINDEXHELPJava™
 * Platform
 * Standard Ed. 8PREV CLASSNEXT CLASSFRAMESNO FRAMESALL CLASSESSUMMARY: NESTED |
 * FIELD | CONSTR | METHODDETAIL: FIELD | CONSTR | METHOD
 * compact1, compact2, compact3
 * java.util
 * Interface List<E>
 * Type Parameters:
 * E - the type of elements in this list
 * All Superinterfaces:
 * Collection<E>, Iterable<E>
 * All Known Implementing Classes:
 * AbstractList, AbstractSequentialList, ArrayList, AttributeList,
 * CopyOnWriteArrayList, LinkedList, RoleList, RoleUnresolvedList, Stack, Vector
 * 
 * public interface List<E>
 * extends Collection<E>
 * An ordered collection (also known as a sequence). The user of this interface
 * has precise control over where in the list each element is inserted. The user
 * can access elements by their integer index (position in the list), and search
 * for elements in the list.
 * Unlike sets, lists typically allow duplicate elements. More formally, lists
 * typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they
 * typically allow multiple null elements if they allow null elements at all. It
 * is not inconceivable that someone might wish to implement a list that
 * prohibits duplicates, by throwing runtime exceptions when the user attempts
 * to insert them, but we expect this usage to be rare.
 * 
 * The List interface places additional stipulations, beyond those specified in
 * the Collection interface, on the contracts of the iterator, add, remove,
 * equals, and hashCode methods. Declarations for other inherited methods are
 * also included here for convenience.
 * 
 * The List interface provides four methods for positional (indexed) access to
 * list elements. Lists (like Java arrays) are zero based. Note that these
 * operations may execute in time proportional to the index value for some
 * implementations (the LinkedList class, for example). Thus, iterating over the
 * elements in a list is typically preferable to indexing through it if the
 * caller does not know the implementation.
 * 
 * The List interface provides a special iterator, called a ListIterator, that
 * allows element insertion and replacement, and bidirectional access in
 * addition to the normal operations that the Iterator interface provides. A
 * method is provided to obtain a list iterator that starts at a specified
 * position in the list.
 * 
 * The List interface provides two methods to search for a specified object.
 * From a performance standpoint, these methods should be used with caution. In
 * many implementations they will perform costly linear searches.
 * 
 * The List interface provides two methods to efficiently insert and remove
 * multiple elements at an arbitrary point in the list.
 * 
 * Note: While it is permissible for lists to contain themselves as elements,
 * extreme caution is advised: the equals and hashCode methods are no longer
 * well defined on such a list.
 * 
 * Some list implementations have restrictions on the elements that they may
 * contain. For example, some implementations prohibit null elements, and some
 * have restrictions on the types of their elements. Attempting to add an
 * ineligible element throws an unchecked exception, typically
 * NullPointerException or ClassCastException. Attempting to query the presence
 * of an ineligible element may throw an exception, or it may simply return
 * false; some implementations will exhibit the former behavior and some will
 * exhibit the latter. More generally, attempting an operation on an ineligible
 * element whose completion would not result in the insertion of an ineligible
 * element into the list may throw an exception or it may succeed, at the option
 * of the implementation. Such exceptions are marked as "optional" in the
 * specification for this interface.
 * 
 * This interface is a member of the Java Collections Framework.
 * 
 * Since:
 * 1.2
 * See Also:
 * Collection, Set, ArrayList, LinkedList, Vector, Arrays.asList(Object[]),
 * Collections.nCopies(int, Object), Collections.EMPTY_LIST, AbstractList,
 * AbstractSequentialList
 * Method Summary
 * All MethodsInstance MethodsAbstract MethodsDefault Methods
 * Modifier and Type Method and Description
 * boolean add(E e)
 * Appends the specified element to the end of this list (optional operation).
 * void add(int index, E element)
 * Inserts the specified element at the specified position in this list
 * (optional operation).
 * boolean addAll(Collection<? extends E> c)
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * iterator (optional operation).
 * boolean addAll(int index, Collection<? extends E> c)
 * Inserts all of the elements in the specified collection into this list at the
 * specified position (optional operation).
 * void clear()
 * Removes all of the elements from this list (optional operation).
 * boolean contains(Object o)
 * Returns true if this list contains the specified element.
 * boolean containsAll(Collection<?> c)
 * Returns true if this list contains all of the elements of the specified
 * collection.
 * boolean equals(Object o)
 * Compares the specified object with this list for equality.
 * E get(int index)
 * Returns the element at the specified position in this list.
 * int hashCode()
 * Returns the hash code value for this list.
 * int indexOf(Object o)
 * Returns the index of the first occurrence of the specified element in this
 * list, or -1 if this list does not contain the element.
 * boolean isEmpty()
 * Returns true if this list contains no elements.
 * Iterator<E> iterator()
 * Returns an iterator over the elements in this list in proper sequence.
 * int lastIndexOf(Object o)
 * Returns the index of the last occurrence of the specified element in this
 * list, or -1 if this list does not contain the element.
 * ListIterator<E> listIterator()
 * Returns a list iterator over the elements in this list (in proper sequence).
 * ListIterator<E> listIterator(int index)
 * Returns a list iterator over the elements in this list (in proper sequence),
 * starting at the specified position in the list.
 * E remove(int index)
 * Removes the element at the specified position in this list (optional
 * operation).
 * boolean remove(Object o)
 * Removes the first occurrence of the specified element from this list, if it
 * is present (optional operation).
 * boolean removeAll(Collection<?> c)
 * Removes from this list all of its elements that are contained in the
 * specified collection (optional operation).
 * default void replaceAll(UnaryOperator<E> operator)
 * Replaces each element of this list with the result of applying the operator
 * to that element.
 * boolean retainAll(Collection<?> c)
 * Retains only the elements in this list that are contained in the specified
 * collection (optional operation).
 * E set(int index, E element)
 * Replaces the element at the specified position in this list with the
 * specified element (optional operation).
 * int size()
 * Returns the number of elements in this list.
 * default void sort(Comparator<? super E> c)
 * Sorts this list according to the order induced by the specified Comparator.
 * default Spliterator<E> spliterator()
 * Creates a Spliterator over the elements in this list.
 * List<E> subList(int fromIndex, int toIndex)
 * Returns a view of the portion of this list between the specified fromIndex,
 * inclusive, and toIndex, exclusive.
 * Object[] toArray()
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element).
 * <T> T[] toArray(T[] a)
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element); the runtime type of the returned array
 * is that of the specified array.
 * Methods inherited from interface java.util.Collection
 * parallelStream, removeIf, stream
 * Methods inherited from interface java.lang.Iterable
 * forEach
 * Method Detail
 * size
 * int size()
 * Returns the number of elements in this list. If this list contains more than
 * Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
 * Specified by:
 * size in interface Collection<E>
 * Returns:
 * the number of elements in this list
 * isEmpty
 * boolean isEmpty()
 * Returns true if this list contains no elements.
 * Specified by:
 * isEmpty in interface Collection<E>
 * Returns:
 * true if this list contains no elements
 * contains
 * boolean contains(Object o)
 * Returns true if this list contains the specified element. More formally,
 * returns true if and only if this list contains at least one element e such
 * that (o==null ? e==null : o.equals(e)).
 * Specified by:
 * contains in interface Collection<E>
 * Parameters:
 * o - element whose presence in this list is to be tested
 * Returns:
 * true if this list contains the specified element
 * Throws:
 * ClassCastException - if the type of the specified element is incompatible
 * with this list (optional)
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements (optional)
 * iterator
 * Iterator<E> iterator()
 * Returns an iterator over the elements in this list in proper sequence.
 * Specified by:
 * iterator in interface Collection<E>
 * Specified by:
 * iterator in interface Iterable<E>
 * Returns:
 * an iterator over the elements in this list in proper sequence
 * toArray
 * Object[] toArray()
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element).
 * The returned array will be "safe" in that no references to it are maintained
 * by this list. (In other words, this method must allocate a new array even if
 * this list is backed by an array). The caller is thus free to modify the
 * returned array.
 * 
 * This method acts as bridge between array-based and collection-based APIs.
 * 
 * Specified by:
 * toArray in interface Collection<E>
 * Returns:
 * an array containing all of the elements in this list in proper sequence
 * See Also:
 * Arrays.asList(Object[])
 * toArray
 * <T> T[] toArray(T[] a)
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element); the runtime type of the returned array
 * is that of the specified array. If the list fits in the specified array, it
 * is returned therein. Otherwise, a new array is allocated with the runtime
 * type of the specified array and the size of this list.
 * If the list fits in the specified array with room to spare (i.e., the array
 * has more elements than the list), the element in the array immediately
 * following the end of the list is set to null. (This is useful in determining
 * the length of the list only if the caller knows that the list does not
 * contain any null elements.)
 * 
 * Like the toArray() method, this method acts as bridge between array-based and
 * collection-based APIs. Further, this method allows precise control over the
 * runtime type of the output array, and may, under certain circumstances, be
 * used to save allocation costs.
 * 
 * Suppose x is a list known to contain only strings. The following code can be
 * used to dump the list into a newly allocated array of String:
 * 
 * 
 * String[] y = x.toArray(new String[0]);
 * 
 * Note that toArray(new Object[0]) is identical in function to toArray().
 * Specified by:
 * toArray in interface Collection<E>
 * Type Parameters:
 * T - the runtime type of the array to contain the collection
 * Parameters:
 * a - the array into which the elements of this list are to be stored, if it is
 * big enough; otherwise, a new array of the same runtime type is allocated for
 * this purpose.
 * Returns:
 * an array containing the elements of this list
 * Throws:
 * ArrayStoreException - if the runtime type of the specified array is not a
 * supertype of the runtime type of every element in this list
 * NullPointerException - if the specified array is null
 * add
 * boolean add(E e)
 * Appends the specified element to the end of this list (optional operation).
 * Lists that support this operation may place limitations on what elements may
 * be added to this list. In particular, some lists will refuse to add null
 * elements, and others will impose restrictions on the type of elements that
 * may be added. List classes should clearly specify in their documentation any
 * restrictions on what elements may be added.
 * 
 * Specified by:
 * add in interface Collection<E>
 * Parameters:
 * e - element to be appended to this list
 * Returns:
 * true (as specified by Collection.add(E))
 * Throws:
 * UnsupportedOperationException - if the add operation is not supported by this
 * list
 * ClassCastException - if the class of the specified element prevents it from
 * being added to this list
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements
 * IllegalArgumentException - if some property of this element prevents it from
 * being added to this list
 * remove
 * boolean remove(Object o)
 * Removes the first occurrence of the specified element from this list, if it
 * is present (optional operation). If this list does not contain the element,
 * it is unchanged. More formally, removes the element with the lowest index i
 * such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element
 * exists). Returns true if this list contained the specified element (or
 * equivalently, if this list changed as a result of the call).
 * Specified by:
 * remove in interface Collection<E>
 * Parameters:
 * o - element to be removed from this list, if present
 * Returns:
 * true if this list contained the specified element
 * Throws:
 * ClassCastException - if the type of the specified element is incompatible
 * with this list (optional)
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements (optional)
 * UnsupportedOperationException - if the remove operation is not supported by
 * this list
 * containsAll
 * boolean containsAll(Collection<?> c)
 * Returns true if this list contains all of the elements of the specified
 * collection.
 * Specified by:
 * containsAll in interface Collection<E>
 * Parameters:
 * c - collection to be checked for containment in this list
 * Returns:
 * true if this list contains all of the elements of the specified collection
 * Throws:
 * ClassCastException - if the types of one or more elements in the specified
 * collection are incompatible with this list (optional)
 * NullPointerException - if the specified collection contains one or more null
 * elements and this list does not permit null elements (optional), or if the
 * specified collection is null
 * See Also:
 * contains(Object)
 * addAll
 * boolean addAll(Collection<? extends E> c)
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * iterator (optional operation). The behavior of this operation is undefined if
 * the specified collection is modified while the operation is in progress.
 * (Note that this will occur if the specified collection is this list, and it's
 * nonempty.)
 * Specified by:
 * addAll in interface Collection<E>
 * Parameters:
 * c - collection containing elements to be added to this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * UnsupportedOperationException - if the addAll operation is not supported by
 * this list
 * ClassCastException - if the class of an element of the specified collection
 * prevents it from being added to this list
 * NullPointerException - if the specified collection contains one or more null
 * elements and this list does not permit null elements, or if the specified
 * collection is null
 * IllegalArgumentException - if some property of an element of the specified
 * collection prevents it from being added to this list
 * See Also:
 * add(Object)
 * addAll
 * boolean addAll(int index,
 * Collection<? extends E> c)
 * Inserts all of the elements in the specified collection into this list at the
 * specified position (optional operation). Shifts the element currently at that
 * position (if any) and any subsequent elements to the right (increases their
 * indices). The new elements will appear in this list in the order that they
 * are returned by the specified collection's iterator. The behavior of this
 * operation is undefined if the specified collection is modified while the
 * operation is in progress. (Note that this will occur if the specified
 * collection is this list, and it's nonempty.)
 * Parameters:
 * index - index at which to insert the first element from the specified
 * collection
 * c - collection containing elements to be added to this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * UnsupportedOperationException - if the addAll operation is not supported by
 * this list
 * ClassCastException - if the class of an element of the specified collection
 * prevents it from being added to this list
 * NullPointerException - if the specified collection contains one or more null
 * elements and this list does not permit null elements, or if the specified
 * collection is null
 * IllegalArgumentException - if some property of an element of the specified
 * collection prevents it from being added to this list
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * > size())
 * removeAll
 * boolean removeAll(Collection<?> c)
 * Removes from this list all of its elements that are contained in the
 * specified collection (optional operation).
 * Specified by:
 * removeAll in interface Collection<E>
 * Parameters:
 * c - collection containing elements to be removed from this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * UnsupportedOperationException - if the removeAll operation is not supported
 * by this list
 * ClassCastException - if the class of an element of this list is incompatible
 * with the specified collection (optional)
 * NullPointerException - if this list contains a null element and the specified
 * collection does not permit null elements (optional), or if the specified
 * collection is null
 * See Also:
 * remove(Object), contains(Object)
 * retainAll
 * boolean retainAll(Collection<?> c)
 * Retains only the elements in this list that are contained in the specified
 * collection (optional operation). In other words, removes from this list all
 * of its elements that are not contained in the specified collection.
 * Specified by:
 * retainAll in interface Collection<E>
 * Parameters:
 * c - collection containing elements to be retained in this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * UnsupportedOperationException - if the retainAll operation is not supported
 * by this list
 * ClassCastException - if the class of an element of this list is incompatible
 * with the specified collection (optional)
 * NullPointerException - if this list contains a null element and the specified
 * collection does not permit null elements (optional), or if the specified
 * collection is null
 * See Also:
 * remove(Object), contains(Object)
 * replaceAll
 * default void replaceAll(UnaryOperator<E> operator)
 * Replaces each element of this list with the result of applying the operator
 * to that element. Errors or runtime exceptions thrown by the operator are
 * relayed to the caller.
 * Implementation Requirements:
 * The default implementation is equivalent to, for this list:
 * 
 * final ListIterator<E> li = list.listIterator();
 * while (li.hasNext()) {
 * li.set(operator.apply(li.next()));
 * }
 * 
 * If the list's list-iterator does not support the set operation then an
 * UnsupportedOperationException will be thrown when replacing the first
 * element.
 * Parameters:
 * operator - the operator to apply to each element
 * Throws:
 * UnsupportedOperationException - if this list is unmodifiable. Implementations
 * may throw this exception if an element cannot be replaced or if, in general,
 * modification is not supported
 * NullPointerException - if the specified operator is null or if the operator
 * result is a null value and this list does not permit null elements (optional)
 * Since:
 * 1.8
 * sort
 * default void sort(Comparator<? super E> c)
 * Sorts this list according to the order induced by the specified Comparator.
 * All elements in this list must be mutually comparable using the specified
 * comparator (that is, c.compare(e1, e2) must not throw a ClassCastException
 * for any elements e1 and e2 in the list).
 * 
 * If the specified comparator is null then all elements in this list must
 * implement the Comparable interface and the elements' natural ordering should
 * be used.
 * 
 * This list must be modifiable, but need not be resizable.
 * 
 * Implementation Requirements:
 * The default implementation obtains an array containing all elements in this
 * list, sorts the array, and iterates over this list resetting each element
 * from the corresponding position in the array. (This avoids the n2 log(n)
 * performance that would result from attempting to sort a linked list in
 * place.)
 * Implementation Note:
 * This implementation is a stable, adaptive, iterative mergesort that requires
 * far fewer than n lg(n) comparisons when the input array is partially sorted,
 * while offering the performance of a traditional mergesort when the input
 * array is randomly ordered. If the input array is nearly sorted, the
 * implementation requires approximately n comparisons. Temporary storage
 * requirements vary from a small constant for nearly sorted input arrays to n/2
 * object references for randomly ordered input arrays.
 * The implementation takes equal advantage of ascending and descending order in
 * its input array, and can take advantage of ascending and descending order in
 * different parts of the same input array. It is well-suited to merging two or
 * more sorted arrays: simply concatenate the arrays and sort the resulting
 * array.
 * 
 * The implementation was adapted from Tim Peters's list sort for Python (
 * TimSort). It uses techniques from Peter McIlroy's
 * "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of
 * the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 * January 1993.
 * 
 * Parameters:
 * c - the Comparator used to compare list elements. A null value indicates that
 * the elements' natural ordering should be used
 * Throws:
 * ClassCastException - if the list contains elements that are not mutually
 * comparable using the specified comparator
 * UnsupportedOperationException - if the list's list-iterator does not support
 * the set operation
 * IllegalArgumentException - (optional) if the comparator is found to violate
 * the Comparator contract
 * Since:
 * 1.8
 * clear
 * void clear()
 * Removes all of the elements from this list (optional operation). The list
 * will be empty after this call returns.
 * Specified by:
 * clear in interface Collection<E>
 * Throws:
 * UnsupportedOperationException - if the clear operation is not supported by
 * this list
 * equals
 * boolean equals(Object o)
 * Compares the specified object with this list for equality. Returns true if
 * and only if the specified object is also a list, both lists have the same
 * size, and all corresponding pairs of elements in the two lists are equal.
 * (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).)
 * In other words, two lists are defined to be equal if they contain the same
 * elements in the same order. This definition ensures that the equals method
 * works properly across different implementations of the List interface.
 * Specified by:
 * equals in interface Collection<E>
 * Overrides:
 * equals in class Object
 * Parameters:
 * o - the object to be compared for equality with this list
 * Returns:
 * true if the specified object is equal to this list
 * See Also:
 * Object.hashCode(), HashMap
 * hashCode
 * int hashCode()
 * Returns the hash code value for this list. The hash code of a list is defined
 * to be the result of the following calculation:
 * 
 * int hashCode = 1;
 * for (E e : list)
 * hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
 * 
 * This ensures that list1.equals(list2) implies that
 * list1.hashCode()==list2.hashCode() for any two lists, list1 and list2, as
 * required by the general contract of Object.hashCode().
 * Specified by:
 * hashCode in interface Collection<E>
 * Overrides:
 * hashCode in class Object
 * Returns:
 * the hash code value for this list
 * See Also:
 * Object.equals(Object), equals(Object)
 * get
 * E get(int index)
 * Returns the element at the specified position in this list.
 * Parameters:
 * index - index of the element to return
 * Returns:
 * the element at the specified position in this list
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * >= size())
 * set
 * E set(int index,
 * E element)
 * Replaces the element at the specified position in this list with the
 * specified element (optional operation).
 * Parameters:
 * index - index of the element to replace
 * element - element to be stored at the specified position
 * Returns:
 * the element previously at the specified position
 * Throws:
 * UnsupportedOperationException - if the set operation is not supported by this
 * list
 * ClassCastException - if the class of the specified element prevents it from
 * being added to this list
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements
 * IllegalArgumentException - if some property of the specified element prevents
 * it from being added to this list
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * >= size())
 * add
 * void add(int index,
 * E element)
 * Inserts the specified element at the specified position in this list
 * (optional operation). Shifts the element currently at that position (if any)
 * and any subsequent elements to the right (adds one to their indices).
 * Parameters:
 * index - index at which the specified element is to be inserted
 * element - element to be inserted
 * Throws:
 * UnsupportedOperationException - if the add operation is not supported by this
 * list
 * ClassCastException - if the class of the specified element prevents it from
 * being added to this list
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements
 * IllegalArgumentException - if some property of the specified element prevents
 * it from being added to this list
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * > size())
 * remove
 * E remove(int index)
 * Removes the element at the specified position in this list (optional
 * operation). Shifts any subsequent elements to the left (subtracts one from
 * their indices). Returns the element that was removed from the list.
 * Parameters:
 * index - the index of the element to be removed
 * Returns:
 * the element previously at the specified position
 * Throws:
 * UnsupportedOperationException - if the remove operation is not supported by
 * this list
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * >= size())
 * indexOf
 * int indexOf(Object o)
 * Returns the index of the first occurrence of the specified element in this
 * list, or -1 if this list does not contain the element. More formally, returns
 * the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or
 * -1 if there is no such index.
 * Parameters:
 * o - element to search for
 * Returns:
 * the index of the first occurrence of the specified element in this list, or
 * -1 if this list does not contain the element
 * Throws:
 * ClassCastException - if the type of the specified element is incompatible
 * with this list (optional)
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements (optional)
 * lastIndexOf
 * int lastIndexOf(Object o)
 * Returns the index of the last occurrence of the specified element in this
 * list, or -1 if this list does not contain the element. More formally, returns
 * the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or
 * -1 if there is no such index.
 * Parameters:
 * o - element to search for
 * Returns:
 * the index of the last occurrence of the specified element in this list, or -1
 * if this list does not contain the element
 * Throws:
 * ClassCastException - if the type of the specified element is incompatible
 * with this list (optional)
 * NullPointerException - if the specified element is null and this list does
 * not permit null elements (optional)
 * listIterator
 * ListIterator<E> listIterator()
 * Returns a list iterator over the elements in this list (in proper sequence).
 * Returns:
 * a list iterator over the elements in this list (in proper sequence)
 * listIterator
 * ListIterator<E> listIterator(int index)
 * Returns a list iterator over the elements in this list (in proper sequence),
 * starting at the specified position in the list. The specified index indicates
 * the first element that would be returned by an initial call to next. An
 * initial call to previous would return the element with the specified index
 * minus one.
 * Parameters:
 * index - index of the first element to be returned from the list iterator (by
 * a call to next)
 * Returns:
 * a list iterator over the elements in this list (in proper sequence), starting
 * at the specified position in the list
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * > size())
 * subList
 * List<E> subList(int fromIndex,
 * int toIndex)
 * Returns a view of the portion of this list between the specified fromIndex,
 * inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the
 * returned list is empty.) The returned list is backed by this list, so
 * non-structural changes in the returned list are reflected in this list, and
 * vice-versa. The returned list supports all of the optional list operations
 * supported by this list.
 * This method eliminates the need for explicit range operations (of the sort
 * that commonly exist for arrays). Any operation that expects a list can be
 * used as a range operation by passing a subList view instead of a whole list.
 * For example, the following idiom removes a range of elements from a list:
 * 
 * 
 * list.subList(from, to).clear();
 * 
 * Similar idioms may be constructed for indexOf and lastIndexOf, and all of the
 * algorithms in the Collections class can be applied to a subList.
 * The semantics of the list returned by this method become undefined if the
 * backing list (i.e., this list) is structurally modified in any way other than
 * via the returned list. (Structural modifications are those that change the
 * size of this list, or otherwise perturb it in such a fashion that iterations
 * in progress may yield incorrect results.)
 * 
 * Parameters:
 * fromIndex - low endpoint (inclusive) of the subList
 * toIndex - high endpoint (exclusive) of the subList
 * Returns:
 * a view of the specified range within this list
 * Throws:
 * IndexOutOfBoundsException - for an illegal endpoint index value (fromIndex <
 * 0 || toIndex > size || fromIndex > toIndex)
 * spliterator
 * default Spliterator<E> spliterator()
 * Creates a Spliterator over the elements in this list.
 * The Spliterator reports Spliterator.SIZED and Spliterator.ORDERED.
 * Implementations should document the reporting of additional characteristic
 * values.
 * 
 * Specified by:
 * spliterator in interface Collection<E>
 * Specified by:
 * spliterator in interface Iterable<E>
 * Implementation Requirements:
 * The default implementation creates a late-binding spliterator from the list's
 * Iterator. The spliterator inherits the fail-fast properties of the list's
 * iterator.
 * Implementation Note:
 * The created Spliterator additionally reports Spliterator.SUBSIZED.
 * Returns:
 * a Spliterator over the elements in this list
 * Since:
 * 1.8
 * SKIP NAVIGATION LINKSOVERVIEWPACKAGECLASSUSETREEDEPRECATEDINDEXHELPJava™
 * Platform
 * Standard Ed. 8PREV CLASSNEXT CLASSFRAMESNO FRAMESALL CLASSESSUMMARY: NESTED |
 * FIELD | CONSTR | METHODDETAIL: FIELD | CONSTR | METHOD
 * Submit a bug or feature
 * For further API reference and developer documentation, see Java SE
 * Documentation. That documentation contains more detailed, developer-targeted
 * descriptions, with conceptual overviews, definitions of terms, workarounds,
 * and working code examples.
 * Copyright © 1993, 2023, Oracle and/or its affiliates. All rights reserved.
 * Use is subject to license terms. Also see the documentation redistribution
 * policy. Modify Préférences en matière de cookies. Modify Ad Choices.
 */

// (TODO) Documentation de la classe ArrayList:
// Découvrez la ci-dessous.

/*
 * SKIP NAVIGATION LINKSOVERVIEWPACKAGECLASSUSETREEDEPRECATEDINDEXHELPJava™
 * Platform
 * Standard Ed. 8PREV CLASSNEXT CLASSFRAMESNO FRAMESALL CLASSESSUMMARY: NESTED |
 * FIELD | CONSTR | METHODDETAIL: FIELD | CONSTR | METHOD
 * compact1, compact2, compact3
 * java.util
 * Class ArrayList<E>
 * java.lang.Object
 * java.util.AbstractCollection<E>
 * java.util.AbstractList<E>
 * java.util.ArrayList<E>
 * All Implemented Interfaces:
 * Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess
 * Direct Known Subclasses:
 * AttributeList, RoleList, RoleUnresolvedList
 * 
 * public class ArrayList<E>
 * extends AbstractList<E>
 * implements List<E>, RandomAccess, Cloneable, Serializable
 * Resizable-array implementation of the List interface. Implements all optional
 * list operations, and permits all elements, including null. In addition to
 * implementing the List interface, this class provides methods to manipulate
 * the size of the array that is used internally to store the list. (This class
 * is roughly equivalent to Vector, except that it is unsynchronized.)
 * The size, isEmpty, get, set, iterator, and listIterator operations run in
 * constant time. The add operation runs in amortized constant time, that is,
 * adding n elements requires O(n) time. All of the other operations run in
 * linear time (roughly speaking). The constant factor is low compared to that
 * for the LinkedList implementation.
 * 
 * Each ArrayList instance has a capacity. The capacity is the size of the array
 * used to store the elements in the list. It is always at least as large as the
 * list size. As elements are added to an ArrayList, its capacity grows
 * automatically. The details of the growth policy are not specified beyond the
 * fact that adding an element has constant amortized time cost.
 * 
 * An application can increase the capacity of an ArrayList instance before
 * adding a large number of elements using the ensureCapacity operation. This
 * may reduce the amount of incremental reallocation.
 * 
 * Note that this implementation is not synchronized. If multiple threads access
 * an ArrayList instance concurrently, and at least one of the threads modifies
 * the list structurally, it must be synchronized externally. (A structural
 * modification is any operation that adds or deletes one or more elements, or
 * explicitly resizes the backing array; merely setting the value of an element
 * is not a structural modification.) This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the list. If no such
 * object exists, the list should be "wrapped" using the
 * Collections.synchronizedList method. This is best done at creation time, to
 * prevent accidental unsynchronized access to the list:
 * 
 * List list = Collections.synchronizedList(new ArrayList(...));
 * The iterators returned by this class's iterator and listIterator methods are
 * fail-fast: if the list is structurally modified at any time after the
 * iterator is created, in any way except through the iterator's own remove or
 * add methods, the iterator will throw a ConcurrentModificationException. Thus,
 * in the face of concurrent modification, the iterator fails quickly and
 * cleanly, rather than risking arbitrary, non-deterministic behavior at an
 * undetermined time in the future.
 * 
 * Note that the fail-fast behavior of an iterator cannot be guaranteed as it
 * is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification. Fail-fast iterators throw
 * ConcurrentModificationException on a best-effort basis. Therefore, it would
 * be wrong to write a program that depended on this exception for its
 * correctness: the fail-fast behavior of iterators should be used only to
 * detect bugs.
 * 
 * This class is a member of the Java Collections Framework.
 * 
 * Since:
 * 1.2
 * See Also:
 * Collection, List, LinkedList, Vector, Serialized Form
 * Field Summary
 * Fields inherited from class java.util.AbstractList
 * modCount
 * Constructor Summary
 * Constructors
 * Constructor and Description
 * ArrayList()
 * Constructs an empty list with an initial capacity of ten.
 * ArrayList(Collection<? extends E> c)
 * Constructs a list containing the elements of the specified collection, in the
 * order they are returned by the collection's iterator.
 * ArrayList(int initialCapacity)
 * Constructs an empty list with the specified initial capacity.
 * Method Summary
 * All MethodsInstance MethodsConcrete Methods
 * Modifier and Type Method and Description
 * boolean add(E e)
 * Appends the specified element to the end of this list.
 * void add(int index, E element)
 * Inserts the specified element at the specified position in this list.
 * boolean addAll(Collection<? extends E> c)
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * Iterator.
 * boolean addAll(int index, Collection<? extends E> c)
 * Inserts all of the elements in the specified collection into this list,
 * starting at the specified position.
 * void clear()
 * Removes all of the elements from this list.
 * Object clone()
 * Returns a shallow copy of this ArrayList instance.
 * boolean contains(Object o)
 * Returns true if this list contains the specified element.
 * void ensureCapacity(int minCapacity)
 * Increases the capacity of this ArrayList instance, if necessary, to ensure
 * that it can hold at least the number of elements specified by the minimum
 * capacity argument.
 * void forEach(Consumer<? super E> action)
 * Performs the given action for each element of the Iterable until all elements
 * have been processed or the action throws an exception.
 * E get(int index)
 * Returns the element at the specified position in this list.
 * int indexOf(Object o)
 * Returns the index of the first occurrence of the specified element in this
 * list, or -1 if this list does not contain the element.
 * boolean isEmpty()
 * Returns true if this list contains no elements.
 * Iterator<E> iterator()
 * Returns an iterator over the elements in this list in proper sequence.
 * int lastIndexOf(Object o)
 * Returns the index of the last occurrence of the specified element in this
 * list, or -1 if this list does not contain the element.
 * ListIterator<E> listIterator()
 * Returns a list iterator over the elements in this list (in proper sequence).
 * ListIterator<E> listIterator(int index)
 * Returns a list iterator over the elements in this list (in proper sequence),
 * starting at the specified position in the list.
 * E remove(int index)
 * Removes the element at the specified position in this list.
 * boolean remove(Object o)
 * Removes the first occurrence of the specified element from this list, if it
 * is present.
 * boolean removeAll(Collection<?> c)
 * Removes from this list all of its elements that are contained in the
 * specified collection.
 * boolean removeIf(Predicate<? super E> filter)
 * Removes all of the elements of this collection that satisfy the given
 * predicate.
 * protected void removeRange(int fromIndex, int toIndex)
 * Removes from this list all of the elements whose index is between fromIndex,
 * inclusive, and toIndex, exclusive.
 * void replaceAll(UnaryOperator<E> operator)
 * Replaces each element of this list with the result of applying the operator
 * to that element.
 * boolean retainAll(Collection<?> c)
 * Retains only the elements in this list that are contained in the specified
 * collection.
 * E set(int index, E element)
 * Replaces the element at the specified position in this list with the
 * specified element.
 * int size()
 * Returns the number of elements in this list.
 * void sort(Comparator<? super E> c)
 * Sorts this list according to the order induced by the specified Comparator.
 * Spliterator<E> spliterator()
 * Creates a late-binding and fail-fast Spliterator over the elements in this
 * list.
 * List<E> subList(int fromIndex, int toIndex)
 * Returns a view of the portion of this list between the specified fromIndex,
 * inclusive, and toIndex, exclusive.
 * Object[] toArray()
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element).
 * <T> T[] toArray(T[] a)
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element); the runtime type of the returned array
 * is that of the specified array.
 * void trimToSize()
 * Trims the capacity of this ArrayList instance to be the list's current size.
 * Methods inherited from class java.util.AbstractList
 * equals, hashCode
 * Methods inherited from class java.util.AbstractCollection
 * containsAll, toString
 * Methods inherited from class java.lang.Object
 * finalize, getClass, notify, notifyAll, wait, wait, wait
 * Methods inherited from interface java.util.List
 * containsAll, equals, hashCode
 * Methods inherited from interface java.util.Collection
 * parallelStream, stream
 * Constructor Detail
 * ArrayList
 * public ArrayList(int initialCapacity)
 * Constructs an empty list with the specified initial capacity.
 * Parameters:
 * initialCapacity - the initial capacity of the list
 * Throws:
 * IllegalArgumentException - if the specified initial capacity is negative
 * ArrayList
 * public ArrayList()
 * Constructs an empty list with an initial capacity of ten.
 * ArrayList
 * public ArrayList(Collection<? extends E> c)
 * Constructs a list containing the elements of the specified collection, in the
 * order they are returned by the collection's iterator.
 * Parameters:
 * c - the collection whose elements are to be placed into this list
 * Throws:
 * NullPointerException - if the specified collection is null
 * Method Detail
 * trimToSize
 * public void trimToSize()
 * Trims the capacity of this ArrayList instance to be the list's current size.
 * An application can use this operation to minimize the storage of an ArrayList
 * instance.
 * ensureCapacity
 * public void ensureCapacity(int minCapacity)
 * Increases the capacity of this ArrayList instance, if necessary, to ensure
 * that it can hold at least the number of elements specified by the minimum
 * capacity argument.
 * Parameters:
 * minCapacity - the desired minimum capacity
 * size
 * public int size()
 * Returns the number of elements in this list.
 * Specified by:
 * size in interface Collection<E>
 * Specified by:
 * size in interface List<E>
 * Specified by:
 * size in class AbstractCollection<E>
 * Returns:
 * the number of elements in this list
 * isEmpty
 * public boolean isEmpty()
 * Returns true if this list contains no elements.
 * Specified by:
 * isEmpty in interface Collection<E>
 * Specified by:
 * isEmpty in interface List<E>
 * Overrides:
 * isEmpty in class AbstractCollection<E>
 * Returns:
 * true if this list contains no elements
 * contains
 * public boolean contains(Object o)
 * Returns true if this list contains the specified element. More formally,
 * returns true if and only if this list contains at least one element e such
 * that (o==null ? e==null : o.equals(e)).
 * Specified by:
 * contains in interface Collection<E>
 * Specified by:
 * contains in interface List<E>
 * Overrides:
 * contains in class AbstractCollection<E>
 * Parameters:
 * o - element whose presence in this list is to be tested
 * Returns:
 * true if this list contains the specified element
 * indexOf
 * public int indexOf(Object o)
 * Returns the index of the first occurrence of the specified element in this
 * list, or -1 if this list does not contain the element. More formally, returns
 * the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or
 * -1 if there is no such index.
 * Specified by:
 * indexOf in interface List<E>
 * Overrides:
 * indexOf in class AbstractList<E>
 * Parameters:
 * o - element to search for
 * Returns:
 * the index of the first occurrence of the specified element in this list, or
 * -1 if this list does not contain the element
 * lastIndexOf
 * public int lastIndexOf(Object o)
 * Returns the index of the last occurrence of the specified element in this
 * list, or -1 if this list does not contain the element. More formally, returns
 * the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or
 * -1 if there is no such index.
 * Specified by:
 * lastIndexOf in interface List<E>
 * Overrides:
 * lastIndexOf in class AbstractList<E>
 * Parameters:
 * o - element to search for
 * Returns:
 * the index of the last occurrence of the specified element in this list, or -1
 * if this list does not contain the element
 * clone
 * public Object clone()
 * Returns a shallow copy of this ArrayList instance. (The elements themselves
 * are not copied.)
 * Overrides:
 * clone in class Object
 * Returns:
 * a clone of this ArrayList instance
 * See Also:
 * Cloneable
 * toArray
 * public Object[] toArray()
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element).
 * The returned array will be "safe" in that no references to it are maintained
 * by this list. (In other words, this method must allocate a new array). The
 * caller is thus free to modify the returned array.
 * 
 * This method acts as bridge between array-based and collection-based APIs.
 * 
 * Specified by:
 * toArray in interface Collection<E>
 * Specified by:
 * toArray in interface List<E>
 * Overrides:
 * toArray in class AbstractCollection<E>
 * Returns:
 * an array containing all of the elements in this list in proper sequence
 * See Also:
 * Arrays.asList(Object[])
 * toArray
 * public <T> T[] toArray(T[] a)
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element); the runtime type of the returned array
 * is that of the specified array. If the list fits in the specified array, it
 * is returned therein. Otherwise, a new array is allocated with the runtime
 * type of the specified array and the size of this list.
 * If the list fits in the specified array with room to spare (i.e., the array
 * has more elements than the list), the element in the array immediately
 * following the end of the collection is set to null. (This is useful in
 * determining the length of the list only if the caller knows that the list
 * does not contain any null elements.)
 * 
 * Specified by:
 * toArray in interface Collection<E>
 * Specified by:
 * toArray in interface List<E>
 * Overrides:
 * toArray in class AbstractCollection<E>
 * Type Parameters:
 * T - the runtime type of the array to contain the collection
 * Parameters:
 * a - the array into which the elements of the list are to be stored, if it is
 * big enough; otherwise, a new array of the same runtime type is allocated for
 * this purpose.
 * Returns:
 * an array containing the elements of the list
 * Throws:
 * ArrayStoreException - if the runtime type of the specified array is not a
 * supertype of the runtime type of every element in this list
 * NullPointerException - if the specified array is null
 * get
 * public E get(int index)
 * Returns the element at the specified position in this list.
 * Specified by:
 * get in interface List<E>
 * Specified by:
 * get in class AbstractList<E>
 * Parameters:
 * index - index of the element to return
 * Returns:
 * the element at the specified position in this list
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * >= size())
 * set
 * public E set(int index,
 * E element)
 * Replaces the element at the specified position in this list with the
 * specified element.
 * Specified by:
 * set in interface List<E>
 * Overrides:
 * set in class AbstractList<E>
 * Parameters:
 * index - index of the element to replace
 * element - element to be stored at the specified position
 * Returns:
 * the element previously at the specified position
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * >= size())
 * add
 * public boolean add(E e)
 * Appends the specified element to the end of this list.
 * Specified by:
 * add in interface Collection<E>
 * Specified by:
 * add in interface List<E>
 * Overrides:
 * add in class AbstractList<E>
 * Parameters:
 * e - element to be appended to this list
 * Returns:
 * true (as specified by Collection.add(E))
 * add
 * public void add(int index,
 * E element)
 * Inserts the specified element at the specified position in this list. Shifts
 * the element currently at that position (if any) and any subsequent elements
 * to the right (adds one to their indices).
 * Specified by:
 * add in interface List<E>
 * Overrides:
 * add in class AbstractList<E>
 * Parameters:
 * index - index at which the specified element is to be inserted
 * element - element to be inserted
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * > size())
 * remove
 * public E remove(int index)
 * Removes the element at the specified position in this list. Shifts any
 * subsequent elements to the left (subtracts one from their indices).
 * Specified by:
 * remove in interface List<E>
 * Overrides:
 * remove in class AbstractList<E>
 * Parameters:
 * index - the index of the element to be removed
 * Returns:
 * the element that was removed from the list
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * >= size())
 * remove
 * public boolean remove(Object o)
 * Removes the first occurrence of the specified element from this list, if it
 * is present. If the list does not contain the element, it is unchanged. More
 * formally, removes the element with the lowest index i such that (o==null ?
 * get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if
 * this list contained the specified element (or equivalently, if this list
 * changed as a result of the call).
 * Specified by:
 * remove in interface Collection<E>
 * Specified by:
 * remove in interface List<E>
 * Overrides:
 * remove in class AbstractCollection<E>
 * Parameters:
 * o - element to be removed from this list, if present
 * Returns:
 * true if this list contained the specified element
 * clear
 * public void clear()
 * Removes all of the elements from this list. The list will be empty after this
 * call returns.
 * Specified by:
 * clear in interface Collection<E>
 * Specified by:
 * clear in interface List<E>
 * Overrides:
 * clear in class AbstractList<E>
 * addAll
 * public boolean addAll(Collection<? extends E> c)
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * Iterator. The behavior of this operation is undefined if the specified
 * collection is modified while the operation is in progress. (This implies that
 * the behavior of this call is undefined if the specified collection is this
 * list, and this list is nonempty.)
 * Specified by:
 * addAll in interface Collection<E>
 * Specified by:
 * addAll in interface List<E>
 * Overrides:
 * addAll in class AbstractCollection<E>
 * Parameters:
 * c - collection containing elements to be added to this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * NullPointerException - if the specified collection is null
 * See Also:
 * AbstractCollection.add(Object)
 * addAll
 * public boolean addAll(int index,
 * Collection<? extends E> c)
 * Inserts all of the elements in the specified collection into this list,
 * starting at the specified position. Shifts the element currently at that
 * position (if any) and any subsequent elements to the right (increases their
 * indices). The new elements will appear in the list in the order that they are
 * returned by the specified collection's iterator.
 * Specified by:
 * addAll in interface List<E>
 * Overrides:
 * addAll in class AbstractList<E>
 * Parameters:
 * index - index at which to insert the first element from the specified
 * collection
 * c - collection containing elements to be added to this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * > size())
 * NullPointerException - if the specified collection is null
 * removeRange
 * protected void removeRange(int fromIndex,
 * int toIndex)
 * Removes from this list all of the elements whose index is between fromIndex,
 * inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left
 * (reduces their index). This call shortens the list by (toIndex - fromIndex)
 * elements. (If toIndex==fromIndex, this operation has no effect.)
 * Overrides:
 * removeRange in class AbstractList<E>
 * Parameters:
 * fromIndex - index of first element to be removed
 * toIndex - index after last element to be removed
 * Throws:
 * IndexOutOfBoundsException - if fromIndex or toIndex is out of range
 * (fromIndex < 0 || fromIndex >= size() || toIndex > size() || toIndex <
 * fromIndex)
 * removeAll
 * public boolean removeAll(Collection<?> c)
 * Removes from this list all of its elements that are contained in the
 * specified collection.
 * Specified by:
 * removeAll in interface Collection<E>
 * Specified by:
 * removeAll in interface List<E>
 * Overrides:
 * removeAll in class AbstractCollection<E>
 * Parameters:
 * c - collection containing elements to be removed from this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * ClassCastException - if the class of an element of this list is incompatible
 * with the specified collection (optional)
 * NullPointerException - if this list contains a null element and the specified
 * collection does not permit null elements (optional), or if the specified
 * collection is null
 * See Also:
 * Collection.contains(Object)
 * retainAll
 * public boolean retainAll(Collection<?> c)
 * Retains only the elements in this list that are contained in the specified
 * collection. In other words, removes from this list all of its elements that
 * are not contained in the specified collection.
 * Specified by:
 * retainAll in interface Collection<E>
 * Specified by:
 * retainAll in interface List<E>
 * Overrides:
 * retainAll in class AbstractCollection<E>
 * Parameters:
 * c - collection containing elements to be retained in this list
 * Returns:
 * true if this list changed as a result of the call
 * Throws:
 * ClassCastException - if the class of an element of this list is incompatible
 * with the specified collection (optional)
 * NullPointerException - if this list contains a null element and the specified
 * collection does not permit null elements (optional), or if the specified
 * collection is null
 * See Also:
 * Collection.contains(Object)
 * listIterator
 * public ListIterator<E> listIterator(int index)
 * Returns a list iterator over the elements in this list (in proper sequence),
 * starting at the specified position in the list. The specified index indicates
 * the first element that would be returned by an initial call to next. An
 * initial call to previous would return the element with the specified index
 * minus one.
 * The returned list iterator is fail-fast.
 * 
 * Specified by:
 * listIterator in interface List<E>
 * Overrides:
 * listIterator in class AbstractList<E>
 * Parameters:
 * index - index of the first element to be returned from the list iterator (by
 * a call to next)
 * Returns:
 * a list iterator over the elements in this list (in proper sequence), starting
 * at the specified position in the list
 * Throws:
 * IndexOutOfBoundsException - if the index is out of range (index < 0 || index
 * > size())
 * listIterator
 * public ListIterator<E> listIterator()
 * Returns a list iterator over the elements in this list (in proper sequence).
 * The returned list iterator is fail-fast.
 * 
 * Specified by:
 * listIterator in interface List<E>
 * Overrides:
 * listIterator in class AbstractList<E>
 * Returns:
 * a list iterator over the elements in this list (in proper sequence)
 * See Also:
 * listIterator(int)
 * iterator
 * public Iterator<E> iterator()
 * Returns an iterator over the elements in this list in proper sequence.
 * The returned iterator is fail-fast.
 * 
 * Specified by:
 * iterator in interface Iterable<E>
 * Specified by:
 * iterator in interface Collection<E>
 * Specified by:
 * iterator in interface List<E>
 * Overrides:
 * iterator in class AbstractList<E>
 * Returns:
 * an iterator over the elements in this list in proper sequence
 * subList
 * public List<E> subList(int fromIndex,
 * int toIndex)
 * Returns a view of the portion of this list between the specified fromIndex,
 * inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the
 * returned list is empty.) The returned list is backed by this list, so
 * non-structural changes in the returned list are reflected in this list, and
 * vice-versa. The returned list supports all of the optional list operations.
 * This method eliminates the need for explicit range operations (of the sort
 * that commonly exist for arrays). Any operation that expects a list can be
 * used as a range operation by passing a subList view instead of a whole list.
 * For example, the following idiom removes a range of elements from a list:
 * 
 * list.subList(from, to).clear();
 * 
 * Similar idioms may be constructed for indexOf(Object) and
 * lastIndexOf(Object), and all of the algorithms in the Collections class can
 * be applied to a subList.
 * The semantics of the list returned by this method become undefined if the
 * backing list (i.e., this list) is structurally modified in any way other than
 * via the returned list. (Structural modifications are those that change the
 * size of this list, or otherwise perturb it in such a fashion that iterations
 * in progress may yield incorrect results.)
 * 
 * Specified by:
 * subList in interface List<E>
 * Overrides:
 * subList in class AbstractList<E>
 * Parameters:
 * fromIndex - low endpoint (inclusive) of the subList
 * toIndex - high endpoint (exclusive) of the subList
 * Returns:
 * a view of the specified range within this list
 * Throws:
 * IndexOutOfBoundsException - if an endpoint index value is out of range
 * (fromIndex < 0 || toIndex > size)
 * IllegalArgumentException - if the endpoint indices are out of order
 * (fromIndex > toIndex)
 * forEach
 * public void forEach(Consumer<? super E> action)
 * Description copied from interface: Iterable
 * Performs the given action for each element of the Iterable until all elements
 * have been processed or the action throws an exception. Unless otherwise
 * specified by the implementing class, actions are performed in the order of
 * iteration (if an iteration order is specified). Exceptions thrown by the
 * action are relayed to the caller.
 * Specified by:
 * forEach in interface Iterable<E>
 * Parameters:
 * action - The action to be performed for each element
 * spliterator
 * public Spliterator<E> spliterator()
 * Creates a late-binding and fail-fast Spliterator over the elements in this
 * list.
 * The Spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, and
 * Spliterator.ORDERED. Overriding implementations should document the reporting
 * of additional characteristic values.
 * 
 * Specified by:
 * spliterator in interface Iterable<E>
 * Specified by:
 * spliterator in interface Collection<E>
 * Specified by:
 * spliterator in interface List<E>
 * Returns:
 * a Spliterator over the elements in this list
 * Since:
 * 1.8
 * removeIf
 * public boolean removeIf(Predicate<? super E> filter)
 * Description copied from interface: Collection
 * Removes all of the elements of this collection that satisfy the given
 * predicate. Errors or runtime exceptions thrown during iteration or by the
 * predicate are relayed to the caller.
 * Specified by:
 * removeIf in interface Collection<E>
 * Parameters:
 * filter - a predicate which returns true for elements to be removed
 * Returns:
 * true if any elements were removed
 * replaceAll
 * public void replaceAll(UnaryOperator<E> operator)
 * Description copied from interface: List
 * Replaces each element of this list with the result of applying the operator
 * to that element. Errors or runtime exceptions thrown by the operator are
 * relayed to the caller.
 * Specified by:
 * replaceAll in interface List<E>
 * Parameters:
 * operator - the operator to apply to each element
 * sort
 * public void sort(Comparator<? super E> c)
 * Description copied from interface: List
 * Sorts this list according to the order induced by the specified Comparator.
 * All elements in this list must be mutually comparable using the specified
 * comparator (that is, c.compare(e1, e2) must not throw a ClassCastException
 * for any elements e1 and e2 in the list).
 * 
 * If the specified comparator is null then all elements in this list must
 * implement the Comparable interface and the elements' natural ordering should
 * be used.
 * 
 * This list must be modifiable, but need not be resizable.
 * 
 * Specified by:
 * sort in interface List<E>
 * Parameters:
 * c - the Comparator used to compare list elements. A null value indicates that
 * the elements' natural ordering should be used
 * SKIP NAVIGATION LINKSOVERVIEWPACKAGECLASSUSETREEDEPRECATEDINDEXHELPJava™
 * Platform
 * Standard Ed. 8PREV CLASSNEXT CLASSFRAMESNO FRAMESALL CLASSESSUMMARY: NESTED |
 * FIELD | CONSTR | METHODDETAIL: FIELD | CONSTR | METHOD
 * Submit a bug or feature
 * For further API reference and developer documentation, see Java SE
 * Documentation. That documentation contains more detailed, developer-targeted
 * descriptions, with conceptual overviews, definitions of terms, workarounds,
 * and working code examples.
 * Copyright © 1993, 2023, Oracle and/or its affiliates. All rights reserved.
 * Use is subject to license terms. Also see the documentation redistribution
 * policy. Modify Préférences en matière de cookies. Modify Ad Choices.
 */

// (TODO) Documentation de la classe Arrays:
// Découvrez la ci-dessous.
/*
 * SKIP NAVIGATION LINKSOVERVIEWPACKAGECLASSUSETREEDEPRECATEDINDEXHELPJava™
 * Platform
 * Standard Ed. 8PREV CLASSNEXT CLASSFRAMESNO FRAMESALL CLASSESSUMMARY: NESTED |
 * FIELD | CONSTR | METHODDETAIL: FIELD | CONSTR | METHOD
 * compact1, compact2, compact3
 * java.util
 * Class Arrays
 * java.lang.Object
 * java.util.Arrays
 * 
 * public class Arrays
 * extends Object
 * This class contains various methods for manipulating arrays (such as sorting
 * and searching). This class also contains a static factory that allows arrays
 * to be viewed as lists.
 * The methods in this class all throw a NullPointerException, if the specified
 * array reference is null, except where noted.
 * 
 * The documentation for the methods contained in this class includes briefs
 * description of the implementations. Such descriptions should be regarded as
 * implementation notes, rather than parts of the specification. Implementors
 * should feel free to substitute other algorithms, so long as the specification
 * itself is adhered to. (For example, the algorithm used by sort(Object[]) does
 * not have to be a MergeSort, but it does have to be stable.)
 * 
 * This class is a member of the Java Collections Framework.
 * 
 * Since:
 * 1.2
 * Method Summary
 * All MethodsStatic MethodsConcrete Methods
 * Modifier and Type Method and Description
 * static <T> List<T> asList(T... a)
 * Returns a fixed-size list backed by the specified array.
 * static int binarySearch(byte[] a, byte key)
 * Searches the specified array of bytes for the specified value using the
 * binary search algorithm.
 * static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)
 * Searches a range of the specified array of bytes for the specified value
 * using the binary search algorithm.
 * static int binarySearch(char[] a, char key)
 * Searches the specified array of chars for the specified value using the
 * binary search algorithm.
 * static int binarySearch(char[] a, int fromIndex, int toIndex, char key)
 * Searches a range of the specified array of chars for the specified value
 * using the binary search algorithm.
 * static int binarySearch(double[] a, double key)
 * Searches the specified array of doubles for the specified value using the
 * binary search algorithm.
 * static int binarySearch(double[] a, int fromIndex, int toIndex, double key)
 * Searches a range of the specified array of doubles for the specified value
 * using the binary search algorithm.
 * static int binarySearch(float[] a, float key)
 * Searches the specified array of floats for the specified value using the
 * binary search algorithm.
 * static int binarySearch(float[] a, int fromIndex, int toIndex, float key)
 * Searches a range of the specified array of floats for the specified value
 * using the binary search algorithm.
 * static int binarySearch(int[] a, int key)
 * Searches the specified array of ints for the specified value using the binary
 * search algorithm.
 * static int binarySearch(int[] a, int fromIndex, int toIndex, int key)
 * Searches a range of the specified array of ints for the specified value using
 * the binary search algorithm.
 * static int binarySearch(long[] a, int fromIndex, int toIndex, long key)
 * Searches a range of the specified array of longs for the specified value
 * using the binary search algorithm.
 * static int binarySearch(long[] a, long key)
 * Searches the specified array of longs for the specified value using the
 * binary search algorithm.
 * static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)
 * Searches a range of the specified array for the specified object using the
 * binary search algorithm.
 * static int binarySearch(Object[] a, Object key)
 * Searches the specified array for the specified object using the binary search
 * algorithm.
 * static int binarySearch(short[] a, int fromIndex, int toIndex, short key)
 * Searches a range of the specified array of shorts for the specified value
 * using the binary search algorithm.
 * static int binarySearch(short[] a, short key)
 * Searches the specified array of shorts for the specified value using the
 * binary search algorithm.
 * static <T> int binarySearch(T[] a, int fromIndex, int toIndex, T key,
 * Comparator<? super T> c)
 * Searches a range of the specified array for the specified object using the
 * binary search algorithm.
 * static <T> int binarySearch(T[] a, T key, Comparator<? super T> c)
 * Searches the specified array for the specified object using the binary search
 * algorithm.
 * static boolean[] copyOf(boolean[] original, int newLength)
 * Copies the specified array, truncating or padding with false (if necessary)
 * so the copy has the specified length.
 * static byte[] copyOf(byte[] original, int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length.
 * static char[] copyOf(char[] original, int newLength)
 * Copies the specified array, truncating or padding with null characters (if
 * necessary) so the copy has the specified length.
 * static double[] copyOf(double[] original, int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length.
 * static float[] copyOf(float[] original, int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length.
 * static int[] copyOf(int[] original, int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length.
 * static long[] copyOf(long[] original, int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length.
 * static short[] copyOf(short[] original, int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length.
 * static <T> T[] copyOf(T[] original, int newLength)
 * Copies the specified array, truncating or padding with nulls (if necessary)
 * so the copy has the specified length.
 * static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]>
 * newType)
 * Copies the specified array, truncating or padding with nulls (if necessary)
 * so the copy has the specified length.
 * static boolean[] copyOfRange(boolean[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static byte[] copyOfRange(byte[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static char[] copyOfRange(char[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static double[] copyOfRange(double[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static float[] copyOfRange(float[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static int[] copyOfRange(int[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static long[] copyOfRange(long[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static short[] copyOfRange(short[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static <T> T[] copyOfRange(T[] original, int from, int to)
 * Copies the specified range of the specified array into a new array.
 * static <T,U> T[] copyOfRange(U[] original, int from, int to, Class<? extends
 * T[]> newType)
 * Copies the specified range of the specified array into a new array.
 * static boolean deepEquals(Object[] a1, Object[] a2)
 * Returns true if the two specified arrays are deeply equal to one another.
 * static int deepHashCode(Object[] a)
 * Returns a hash code based on the "deep contents" of the specified array.
 * static String deepToString(Object[] a)
 * Returns a string representation of the "deep contents" of the specified
 * array.
 * static boolean equals(boolean[] a, boolean[] a2)
 * Returns true if the two specified arrays of booleans are equal to one
 * another.
 * static boolean equals(byte[] a, byte[] a2)
 * Returns true if the two specified arrays of bytes are equal to one another.
 * static boolean equals(char[] a, char[] a2)
 * Returns true if the two specified arrays of chars are equal to one another.
 * static boolean equals(double[] a, double[] a2)
 * Returns true if the two specified arrays of doubles are equal to one another.
 * static boolean equals(float[] a, float[] a2)
 * Returns true if the two specified arrays of floats are equal to one another.
 * static boolean equals(int[] a, int[] a2)
 * Returns true if the two specified arrays of ints are equal to one another.
 * static boolean equals(long[] a, long[] a2)
 * Returns true if the two specified arrays of longs are equal to one another.
 * static boolean equals(Object[] a, Object[] a2)
 * Returns true if the two specified arrays of Objects are equal to one another.
 * static boolean equals(short[] a, short[] a2)
 * Returns true if the two specified arrays of shorts are equal to one another.
 * static void fill(boolean[] a, boolean val)
 * Assigns the specified boolean value to each element of the specified array of
 * booleans.
 * static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)
 * Assigns the specified boolean value to each element of the specified range of
 * the specified array of booleans.
 * static void fill(byte[] a, byte val)
 * Assigns the specified byte value to each element of the specified array of
 * bytes.
 * static void fill(byte[] a, int fromIndex, int toIndex, byte val)
 * Assigns the specified byte value to each element of the specified range of
 * the specified array of bytes.
 * static void fill(char[] a, char val)
 * Assigns the specified char value to each element of the specified array of
 * chars.
 * static void fill(char[] a, int fromIndex, int toIndex, char val)
 * Assigns the specified char value to each element of the specified range of
 * the specified array of chars.
 * static void fill(double[] a, double val)
 * Assigns the specified double value to each element of the specified array of
 * doubles.
 * static void fill(double[] a, int fromIndex, int toIndex, double val)
 * Assigns the specified double value to each element of the specified range of
 * the specified array of doubles.
 * static void fill(float[] a, float val)
 * Assigns the specified float value to each element of the specified array of
 * floats.
 * static void fill(float[] a, int fromIndex, int toIndex, float val)
 * Assigns the specified float value to each element of the specified range of
 * the specified array of floats.
 * static void fill(int[] a, int val)
 * Assigns the specified int value to each element of the specified array of
 * ints.
 * static void fill(int[] a, int fromIndex, int toIndex, int val)
 * Assigns the specified int value to each element of the specified range of the
 * specified array of ints.
 * static void fill(long[] a, int fromIndex, int toIndex, long val)
 * Assigns the specified long value to each element of the specified range of
 * the specified array of longs.
 * static void fill(long[] a, long val)
 * Assigns the specified long value to each element of the specified array of
 * longs.
 * static void fill(Object[] a, int fromIndex, int toIndex, Object val)
 * Assigns the specified Object reference to each element of the specified range
 * of the specified array of Objects.
 * static void fill(Object[] a, Object val)
 * Assigns the specified Object reference to each element of the specified array
 * of Objects.
 * static void fill(short[] a, int fromIndex, int toIndex, short val)
 * Assigns the specified short value to each element of the specified range of
 * the specified array of shorts.
 * static void fill(short[] a, short val)
 * Assigns the specified short value to each element of the specified array of
 * shorts.
 * static int hashCode(boolean[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(byte[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(char[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(double[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(float[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(int[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(long[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(Object[] a)
 * Returns a hash code based on the contents of the specified array.
 * static int hashCode(short[] a)
 * Returns a hash code based on the contents of the specified array.
 * static void parallelPrefix(double[] array, DoubleBinaryOperator op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function.
 * static void parallelPrefix(double[] array, int fromIndex, int toIndex,
 * DoubleBinaryOperator op)
 * Performs parallelPrefix(double[], DoubleBinaryOperator) for the given
 * subrange of the array.
 * static void parallelPrefix(int[] array, IntBinaryOperator op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function.
 * static void parallelPrefix(int[] array, int fromIndex, int toIndex,
 * IntBinaryOperator op)
 * Performs parallelPrefix(int[], IntBinaryOperator) for the given subrange of
 * the array.
 * static void parallelPrefix(long[] array, int fromIndex, int toIndex,
 * LongBinaryOperator op)
 * Performs parallelPrefix(long[], LongBinaryOperator) for the given subrange of
 * the array.
 * static void parallelPrefix(long[] array, LongBinaryOperator op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function.
 * static <T> void parallelPrefix(T[] array, BinaryOperator<T> op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function.
 * static <T> void parallelPrefix(T[] array, int fromIndex, int toIndex,
 * BinaryOperator<T> op)
 * Performs parallelPrefix(Object[], BinaryOperator) for the given subrange of
 * the array.
 * static void parallelSetAll(double[] array, IntToDoubleFunction generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * static void parallelSetAll(int[] array, IntUnaryOperator generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * static void parallelSetAll(long[] array, IntToLongFunction generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * static <T> void parallelSetAll(T[] array, IntFunction<? extends T> generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * static void parallelSort(byte[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(byte[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static void parallelSort(char[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(char[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static void parallelSort(double[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(double[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static void parallelSort(float[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(float[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static void parallelSort(int[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(int[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static void parallelSort(long[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(long[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static void parallelSort(short[] a)
 * Sorts the specified array into ascending numerical order.
 * static void parallelSort(short[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending numerical order.
 * static <T extends Comparable<? super T>>
 * void parallelSort(T[] a)
 * Sorts the specified array of objects into ascending order, according to the
 * natural ordering of its elements.
 * static <T> void parallelSort(T[] a, Comparator<? super T> cmp)
 * Sorts the specified array of objects according to the order induced by the
 * specified comparator.
 * static <T extends Comparable<? super T>>
 * void parallelSort(T[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the specified array of objects into ascending
 * order, according to the natural ordering of its elements.
 * static <T> void parallelSort(T[] a, int fromIndex, int toIndex, Comparator<?
 * super T> cmp)
 * Sorts the specified range of the specified array of objects according to the
 * order induced by the specified comparator.
 * static void setAll(double[] array, IntToDoubleFunction generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * static void setAll(int[] array, IntUnaryOperator generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * static void setAll(long[] array, IntToLongFunction generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * static <T> void setAll(T[] array, IntFunction<? extends T> generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * static void sort(byte[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(byte[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static void sort(char[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(char[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static void sort(double[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(double[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static void sort(float[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(float[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static void sort(int[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(int[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static void sort(long[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(long[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static void sort(Object[] a)
 * Sorts the specified array of objects into ascending order, according to the
 * natural ordering of its elements.
 * static void sort(Object[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the specified array of objects into ascending
 * order, according to the natural ordering of its elements.
 * static void sort(short[] a)
 * Sorts the specified array into ascending numerical order.
 * static void sort(short[] a, int fromIndex, int toIndex)
 * Sorts the specified range of the array into ascending order.
 * static <T> void sort(T[] a, Comparator<? super T> c)
 * Sorts the specified array of objects according to the order induced by the
 * specified comparator.
 * static <T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T>
 * c)
 * Sorts the specified range of the specified array of objects according to the
 * order induced by the specified comparator.
 * static Spliterator.OfDouble spliterator(double[] array)
 * Returns a Spliterator.OfDouble covering all of the specified array.
 * static Spliterator.OfDouble spliterator(double[] array, int startInclusive,
 * int endExclusive)
 * Returns a Spliterator.OfDouble covering the specified range of the specified
 * array.
 * static Spliterator.OfInt spliterator(int[] array)
 * Returns a Spliterator.OfInt covering all of the specified array.
 * static Spliterator.OfInt spliterator(int[] array, int startInclusive, int
 * endExclusive)
 * Returns a Spliterator.OfInt covering the specified range of the specified
 * array.
 * static Spliterator.OfLong spliterator(long[] array)
 * Returns a Spliterator.OfLong covering all of the specified array.
 * static Spliterator.OfLong spliterator(long[] array, int startInclusive, int
 * endExclusive)
 * Returns a Spliterator.OfLong covering the specified range of the specified
 * array.
 * static <T> Spliterator<T> spliterator(T[] array)
 * Returns a Spliterator covering all of the specified array.
 * static <T> Spliterator<T> spliterator(T[] array, int startInclusive, int
 * endExclusive)
 * Returns a Spliterator covering the specified range of the specified array.
 * static DoubleStream stream(double[] array)
 * Returns a sequential DoubleStream with the specified array as its source.
 * static DoubleStream stream(double[] array, int startInclusive, int
 * endExclusive)
 * Returns a sequential DoubleStream with the specified range of the specified
 * array as its source.
 * static IntStream stream(int[] array)
 * Returns a sequential IntStream with the specified array as its source.
 * static IntStream stream(int[] array, int startInclusive, int endExclusive)
 * Returns a sequential IntStream with the specified range of the specified
 * array as its source.
 * static LongStream stream(long[] array)
 * Returns a sequential LongStream with the specified array as its source.
 * static LongStream stream(long[] array, int startInclusive, int endExclusive)
 * Returns a sequential LongStream with the specified range of the specified
 * array as its source.
 * static <T> Stream<T> stream(T[] array)
 * Returns a sequential Stream with the specified array as its source.
 * static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)
 * Returns a sequential Stream with the specified range of the specified array
 * as its source.
 * static String toString(boolean[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(byte[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(char[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(double[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(float[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(int[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(long[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(Object[] a)
 * Returns a string representation of the contents of the specified array.
 * static String toString(short[] a)
 * Returns a string representation of the contents of the specified array.
 * Methods inherited from class java.lang.Object
 * clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString,
 * wait, wait, wait
 * Method Detail
 * sort
 * public static void sort(int[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(int[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * sort
 * public static void sort(long[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(long[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * sort
 * public static void sort(short[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(short[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * sort
 * public static void sort(char[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(char[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * sort
 * public static void sort(byte[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(byte[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * sort
 * public static void sort(float[] a)
 * Sorts the specified array into ascending numerical order.
 * The < relation does not provide a total order on all float values: -0.0f ==
 * 0.0f is true and a Float.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than
 * value 0.0f and Float.NaN is considered greater than any other value and all
 * Float.NaN values are considered equal.
 * 
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(float[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * The < relation does not provide a total order on all float values: -0.0f ==
 * 0.0f is true and a Float.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than
 * value 0.0f and Float.NaN is considered greater than any other value and all
 * Float.NaN values are considered equal.
 * 
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * sort
 * public static void sort(double[] a)
 * Sorts the specified array into ascending numerical order.
 * The < relation does not provide a total order on all double values: -0.0d ==
 * 0.0d is true and a Double.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Double.compareTo(java.lang.Double): -0.0d is treated as less
 * than value 0.0d and Double.NaN is considered greater than any other value and
 * all Double.NaN values are considered equal.
 * 
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * sort
 * public static void sort(double[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending order. The range to be
 * sorted extends from the index fromIndex, inclusive, to the index toIndex,
 * exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * The < relation does not provide a total order on all double values: -0.0d ==
 * 0.0d is true and a Double.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Double.compareTo(java.lang.Double): -0.0d is treated as less
 * than value 0.0d and Double.NaN is considered greater than any other value and
 * all Double.NaN values are considered equal.
 * 
 * Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by
 * Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers
 * O(n log(n)) performance on many data sets that cause other quicksorts to
 * degrade to quadratic performance, and is typically faster than traditional
 * (one-pivot) Quicksort implementations.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * parallelSort
 * public static void parallelSort(byte[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(byte[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(char[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(char[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(short[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(short[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(int[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(int[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(long[] a)
 * Sorts the specified array into ascending numerical order.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(long[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(float[] a)
 * Sorts the specified array into ascending numerical order.
 * The < relation does not provide a total order on all float values: -0.0f ==
 * 0.0f is true and a Float.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than
 * value 0.0f and Float.NaN is considered greater than any other value and all
 * Float.NaN values are considered equal.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(float[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * The < relation does not provide a total order on all float values: -0.0f ==
 * 0.0f is true and a Float.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than
 * value 0.0f and Float.NaN is considered greater than any other value and all
 * Float.NaN values are considered equal.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(double[] a)
 * Sorts the specified array into ascending numerical order.
 * The < relation does not provide a total order on all double values: -0.0d ==
 * 0.0d is true and a Double.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Double.compareTo(java.lang.Double): -0.0d is treated as less
 * than value 0.0d and Double.NaN is considered greater than any other value and
 * all Double.NaN values are considered equal.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * Since:
 * 1.8
 * parallelSort
 * public static void parallelSort(double[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the array into ascending numerical order. The
 * range to be sorted extends from the index fromIndex, inclusive, to the index
 * toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
 * The < relation does not provide a total order on all double values: -0.0d ==
 * 0.0d is true and a Double.NaN value compares neither less than, greater than,
 * nor equal to any value, even itself. This method uses the total order imposed
 * by the method Double.compareTo(java.lang.Double): -0.0d is treated as less
 * than value 0.0d and Double.NaN is considered greater than any other value and
 * all Double.NaN values are considered equal.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element, inclusive, to be sorted
 * toIndex - the index of the last element, exclusive, to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.8
 * parallelSort
 * public static <T extends Comparable<? super T>> void parallelSort(T[] a)
 * Sorts the specified array of objects into ascending order, according to the
 * natural ordering of its elements. All elements in the array must implement
 * the Comparable interface. Furthermore, all elements in the array must be
 * mutually comparable (that is, e1.compareTo(e2) must not throw a
 * ClassCastException for any elements e1 and e2 in the array).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Type Parameters:
 * T - the class of the objects to be sorted
 * Parameters:
 * a - the array to be sorted
 * Throws:
 * ClassCastException - if the array contains elements that are not mutually
 * comparable (for example, strings and integers)
 * IllegalArgumentException - (optional) if the natural ordering of the array
 * elements is found to violate the Comparable contract
 * Since:
 * 1.8
 * parallelSort
 * public static <T extends Comparable<? super T>> void parallelSort(T[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the specified array of objects into ascending
 * order, according to the natural ordering of its elements. The range to be
 * sorted extends from index fromIndex, inclusive, to index toIndex, exclusive.
 * (If fromIndex==toIndex, the range to be sorted is empty.) All elements in
 * this range must implement the Comparable interface. Furthermore, all elements
 * in this range must be mutually comparable (that is, e1.compareTo(e2) must not
 * throw a ClassCastException for any elements e1 and e2 in the array).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Type Parameters:
 * T - the class of the objects to be sorted
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element (inclusive) to be sorted
 * toIndex - the index of the last element (exclusive) to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex or (optional) if the
 * natural ordering of the array elements is found to violate the Comparable
 * contract
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * ClassCastException - if the array contains elements that are not mutually
 * comparable (for example, strings and integers).
 * Since:
 * 1.8
 * parallelSort
 * public static <T> void parallelSort(T[] a,
 * Comparator<? super T> cmp)
 * Sorts the specified array of objects according to the order induced by the
 * specified comparator. All elements in the array must be mutually comparable
 * by the specified comparator (that is, c.compare(e1, e2) must not throw a
 * ClassCastException for any elements e1 and e2 in the array).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the original array. The ForkJoin common pool is used to execute
 * any parallel tasks.
 * Type Parameters:
 * T - the class of the objects to be sorted
 * Parameters:
 * a - the array to be sorted
 * cmp - the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 * Throws:
 * ClassCastException - if the array contains elements that are not mutually
 * comparable using the specified comparator
 * IllegalArgumentException - (optional) if the comparator is found to violate
 * the Comparator contract
 * Since:
 * 1.8
 * parallelSort
 * public static <T> void parallelSort(T[] a,
 * int fromIndex,
 * int toIndex,
 * Comparator<? super T> cmp)
 * Sorts the specified range of the specified array of objects according to the
 * order induced by the specified comparator. The range to be sorted extends
 * from index fromIndex, inclusive, to index toIndex, exclusive. (If
 * fromIndex==toIndex, the range to be sorted is empty.) All elements in the
 * range must be mutually comparable by the specified comparator (that is,
 * c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and
 * e2 in the range).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation Note:
 * The sorting algorithm is a parallel sort-merge that breaks the array into
 * sub-arrays that are themselves sorted and then merged. When the sub-array
 * length reaches a minimum granularity, the sub-array is sorted using the
 * appropriate Arrays.sort method. If the length of the specified array is less
 * than the minimum granularity, then it is sorted using the appropriate
 * Arrays.sort method. The algorithm requires a working space no greater than
 * the size of the specified range of the original array. The ForkJoin common
 * pool is used to execute any parallel tasks.
 * Type Parameters:
 * T - the class of the objects to be sorted
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element (inclusive) to be sorted
 * toIndex - the index of the last element (exclusive) to be sorted
 * cmp - the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex or (optional) if the
 * natural ordering of the array elements is found to violate the Comparable
 * contract
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * ClassCastException - if the array contains elements that are not mutually
 * comparable (for example, strings and integers).
 * Since:
 * 1.8
 * sort
 * public static void sort(Object[] a)
 * Sorts the specified array of objects into ascending order, according to the
 * natural ordering of its elements. All elements in the array must implement
 * the Comparable interface. Furthermore, all elements in the array must be
 * mutually comparable (that is, e1.compareTo(e2) must not throw a
 * ClassCastException for any elements e1 and e2 in the array).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation note: This implementation is a stable, adaptive, iterative
 * mergesort that requires far fewer than n lg(n) comparisons when the input
 * array is partially sorted, while offering the performance of a traditional
 * mergesort when the input array is randomly ordered. If the input array is
 * nearly sorted, the implementation requires approximately n comparisons.
 * Temporary storage requirements vary from a small constant for nearly sorted
 * input arrays to n/2 object references for randomly ordered input arrays.
 * 
 * The implementation takes equal advantage of ascending and descending order in
 * its input array, and can take advantage of ascending and descending order in
 * different parts of the the same input array. It is well-suited to merging two
 * or more sorted arrays: simply concatenate the arrays and sort the resulting
 * array.
 * 
 * The implementation was adapted from Tim Peters's list sort for Python (
 * TimSort). It uses techniques from Peter McIlroy's
 * "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of
 * the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 * January 1993.
 * 
 * Parameters:
 * a - the array to be sorted
 * Throws:
 * ClassCastException - if the array contains elements that are not mutually
 * comparable (for example, strings and integers)
 * IllegalArgumentException - (optional) if the natural ordering of the array
 * elements is found to violate the Comparable contract
 * sort
 * public static void sort(Object[] a,
 * int fromIndex,
 * int toIndex)
 * Sorts the specified range of the specified array of objects into ascending
 * order, according to the natural ordering of its elements. The range to be
 * sorted extends from index fromIndex, inclusive, to index toIndex, exclusive.
 * (If fromIndex==toIndex, the range to be sorted is empty.) All elements in
 * this range must implement the Comparable interface. Furthermore, all elements
 * in this range must be mutually comparable (that is, e1.compareTo(e2) must not
 * throw a ClassCastException for any elements e1 and e2 in the array).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation note: This implementation is a stable, adaptive, iterative
 * mergesort that requires far fewer than n lg(n) comparisons when the input
 * array is partially sorted, while offering the performance of a traditional
 * mergesort when the input array is randomly ordered. If the input array is
 * nearly sorted, the implementation requires approximately n comparisons.
 * Temporary storage requirements vary from a small constant for nearly sorted
 * input arrays to n/2 object references for randomly ordered input arrays.
 * 
 * The implementation takes equal advantage of ascending and descending order in
 * its input array, and can take advantage of ascending and descending order in
 * different parts of the the same input array. It is well-suited to merging two
 * or more sorted arrays: simply concatenate the arrays and sort the resulting
 * array.
 * 
 * The implementation was adapted from Tim Peters's list sort for Python (
 * TimSort). It uses techniques from Peter McIlroy's
 * "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of
 * the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 * January 1993.
 * 
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element (inclusive) to be sorted
 * toIndex - the index of the last element (exclusive) to be sorted
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex or (optional) if the
 * natural ordering of the array elements is found to violate the Comparable
 * contract
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * ClassCastException - if the array contains elements that are not mutually
 * comparable (for example, strings and integers).
 * sort
 * public static <T> void sort(T[] a,
 * Comparator<? super T> c)
 * Sorts the specified array of objects according to the order induced by the
 * specified comparator. All elements in the array must be mutually comparable
 * by the specified comparator (that is, c.compare(e1, e2) must not throw a
 * ClassCastException for any elements e1 and e2 in the array).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation note: This implementation is a stable, adaptive, iterative
 * mergesort that requires far fewer than n lg(n) comparisons when the input
 * array is partially sorted, while offering the performance of a traditional
 * mergesort when the input array is randomly ordered. If the input array is
 * nearly sorted, the implementation requires approximately n comparisons.
 * Temporary storage requirements vary from a small constant for nearly sorted
 * input arrays to n/2 object references for randomly ordered input arrays.
 * 
 * The implementation takes equal advantage of ascending and descending order in
 * its input array, and can take advantage of ascending and descending order in
 * different parts of the the same input array. It is well-suited to merging two
 * or more sorted arrays: simply concatenate the arrays and sort the resulting
 * array.
 * 
 * The implementation was adapted from Tim Peters's list sort for Python (
 * TimSort). It uses techniques from Peter McIlroy's
 * "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of
 * the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 * January 1993.
 * 
 * Type Parameters:
 * T - the class of the objects to be sorted
 * Parameters:
 * a - the array to be sorted
 * c - the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 * Throws:
 * ClassCastException - if the array contains elements that are not mutually
 * comparable using the specified comparator
 * IllegalArgumentException - (optional) if the comparator is found to violate
 * the Comparator contract
 * sort
 * public static <T> void sort(T[] a,
 * int fromIndex,
 * int toIndex,
 * Comparator<? super T> c)
 * Sorts the specified range of the specified array of objects according to the
 * order induced by the specified comparator. The range to be sorted extends
 * from index fromIndex, inclusive, to index toIndex, exclusive. (If
 * fromIndex==toIndex, the range to be sorted is empty.) All elements in the
 * range must be mutually comparable by the specified comparator (that is,
 * c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and
 * e2 in the range).
 * This sort is guaranteed to be stable: equal elements will not be reordered as
 * a result of the sort.
 * 
 * Implementation note: This implementation is a stable, adaptive, iterative
 * mergesort that requires far fewer than n lg(n) comparisons when the input
 * array is partially sorted, while offering the performance of a traditional
 * mergesort when the input array is randomly ordered. If the input array is
 * nearly sorted, the implementation requires approximately n comparisons.
 * Temporary storage requirements vary from a small constant for nearly sorted
 * input arrays to n/2 object references for randomly ordered input arrays.
 * 
 * The implementation takes equal advantage of ascending and descending order in
 * its input array, and can take advantage of ascending and descending order in
 * different parts of the the same input array. It is well-suited to merging two
 * or more sorted arrays: simply concatenate the arrays and sort the resulting
 * array.
 * 
 * The implementation was adapted from Tim Peters's list sort for Python (
 * TimSort). It uses techniques from Peter McIlroy's
 * "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of
 * the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 * January 1993.
 * 
 * Type Parameters:
 * T - the class of the objects to be sorted
 * Parameters:
 * a - the array to be sorted
 * fromIndex - the index of the first element (inclusive) to be sorted
 * toIndex - the index of the last element (exclusive) to be sorted
 * c - the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 * Throws:
 * ClassCastException - if the array contains elements that are not mutually
 * comparable using the specified comparator.
 * IllegalArgumentException - if fromIndex > toIndex or (optional) if the
 * comparator is found to violate the Comparator contract
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * parallelPrefix
 * public static <T> void parallelPrefix(T[] array,
 * BinaryOperator<T> op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function. For example if the array initially holds [2, 1, 0, 3] and
 * the operation performs addition, then upon return the array holds [2, 3, 3,
 * 6]. Parallel prefix computation is usually more efficient than sequential
 * loops for large arrays.
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * array - the array, which is modified in-place by this method
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static <T> void parallelPrefix(T[] array,
 * int fromIndex,
 * int toIndex,
 * BinaryOperator<T> op)
 * Performs parallelPrefix(Object[], BinaryOperator) for the given subrange of
 * the array.
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * array - the array
 * fromIndex - the index of the first element, inclusive
 * toIndex - the index of the last element, exclusive
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > array.length
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static void parallelPrefix(long[] array,
 * LongBinaryOperator op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function. For example if the array initially holds [2, 1, 0, 3] and
 * the operation performs addition, then upon return the array holds [2, 3, 3,
 * 6]. Parallel prefix computation is usually more efficient than sequential
 * loops for large arrays.
 * Parameters:
 * array - the array, which is modified in-place by this method
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static void parallelPrefix(long[] array,
 * int fromIndex,
 * int toIndex,
 * LongBinaryOperator op)
 * Performs parallelPrefix(long[], LongBinaryOperator) for the given subrange of
 * the array.
 * Parameters:
 * array - the array
 * fromIndex - the index of the first element, inclusive
 * toIndex - the index of the last element, exclusive
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > array.length
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static void parallelPrefix(double[] array,
 * DoubleBinaryOperator op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function. For example if the array initially holds [2.0, 1.0, 0.0,
 * 3.0] and the operation performs addition, then upon return the array holds
 * [2.0, 3.0, 3.0, 6.0]. Parallel prefix computation is usually more efficient
 * than sequential loops for large arrays.
 * Because floating-point operations may not be strictly associative, the
 * returned result may not be identical to the value that would be obtained if
 * the operation was performed sequentially.
 * 
 * Parameters:
 * array - the array, which is modified in-place by this method
 * op - a side-effect-free function to perform the cumulation
 * Throws:
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static void parallelPrefix(double[] array,
 * int fromIndex,
 * int toIndex,
 * DoubleBinaryOperator op)
 * Performs parallelPrefix(double[], DoubleBinaryOperator) for the given
 * subrange of the array.
 * Parameters:
 * array - the array
 * fromIndex - the index of the first element, inclusive
 * toIndex - the index of the last element, exclusive
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > array.length
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static void parallelPrefix(int[] array,
 * IntBinaryOperator op)
 * Cumulates, in parallel, each element of the given array in place, using the
 * supplied function. For example if the array initially holds [2, 1, 0, 3] and
 * the operation performs addition, then upon return the array holds [2, 3, 3,
 * 6]. Parallel prefix computation is usually more efficient than sequential
 * loops for large arrays.
 * Parameters:
 * array - the array, which is modified in-place by this method
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * parallelPrefix
 * public static void parallelPrefix(int[] array,
 * int fromIndex,
 * int toIndex,
 * IntBinaryOperator op)
 * Performs parallelPrefix(int[], IntBinaryOperator) for the given subrange of
 * the array.
 * Parameters:
 * array - the array
 * fromIndex - the index of the first element, inclusive
 * toIndex - the index of the last element, exclusive
 * op - a side-effect-free, associative function to perform the cumulation
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > array.length
 * NullPointerException - if the specified array or function is null
 * Since:
 * 1.8
 * binarySearch
 * public static int binarySearch(long[] a,
 * long key)
 * Searches the specified array of longs for the specified value using the
 * binary search algorithm. The array must be sorted (as by the sort(long[])
 * method) prior to making this call. If it is not sorted, the results are
 * undefined. If the array contains multiple elements with the specified value,
 * there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(long[] a,
 * int fromIndex,
 * int toIndex,
 * long key)
 * Searches a range of the specified array of longs for the specified value
 * using the binary search algorithm. The range must be sorted (as by the
 * sort(long[], int, int) method) prior to making this call. If it is not
 * sorted, the results are undefined. If the range contains multiple elements
 * with the specified value, there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(int[] a,
 * int key)
 * Searches the specified array of ints for the specified value using the binary
 * search algorithm. The array must be sorted (as by the sort(int[]) method)
 * prior to making this call. If it is not sorted, the results are undefined. If
 * the array contains multiple elements with the specified value, there is no
 * guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(int[] a,
 * int fromIndex,
 * int toIndex,
 * int key)
 * Searches a range of the specified array of ints for the specified value using
 * the binary search algorithm. The range must be sorted (as by the sort(int[],
 * int, int) method) prior to making this call. If it is not sorted, the results
 * are undefined. If the range contains multiple elements with the specified
 * value, there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(short[] a,
 * short key)
 * Searches the specified array of shorts for the specified value using the
 * binary search algorithm. The array must be sorted (as by the sort(short[])
 * method) prior to making this call. If it is not sorted, the results are
 * undefined. If the array contains multiple elements with the specified value,
 * there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(short[] a,
 * int fromIndex,
 * int toIndex,
 * short key)
 * Searches a range of the specified array of shorts for the specified value
 * using the binary search algorithm. The range must be sorted (as by the
 * sort(short[], int, int) method) prior to making this call. If it is not
 * sorted, the results are undefined. If the range contains multiple elements
 * with the specified value, there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(char[] a,
 * char key)
 * Searches the specified array of chars for the specified value using the
 * binary search algorithm. The array must be sorted (as by the sort(char[])
 * method) prior to making this call. If it is not sorted, the results are
 * undefined. If the array contains multiple elements with the specified value,
 * there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(char[] a,
 * int fromIndex,
 * int toIndex,
 * char key)
 * Searches a range of the specified array of chars for the specified value
 * using the binary search algorithm. The range must be sorted (as by the
 * sort(char[], int, int) method) prior to making this call. If it is not
 * sorted, the results are undefined. If the range contains multiple elements
 * with the specified value, there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(byte[] a,
 * byte key)
 * Searches the specified array of bytes for the specified value using the
 * binary search algorithm. The array must be sorted (as by the sort(byte[])
 * method) prior to making this call. If it is not sorted, the results are
 * undefined. If the array contains multiple elements with the specified value,
 * there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(byte[] a,
 * int fromIndex,
 * int toIndex,
 * byte key)
 * Searches a range of the specified array of bytes for the specified value
 * using the binary search algorithm. The range must be sorted (as by the
 * sort(byte[], int, int) method) prior to making this call. If it is not
 * sorted, the results are undefined. If the range contains multiple elements
 * with the specified value, there is no guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(double[] a,
 * double key)
 * Searches the specified array of doubles for the specified value using the
 * binary search algorithm. The array must be sorted (as by the sort(double[])
 * method) prior to making this call. If it is not sorted, the results are
 * undefined. If the array contains multiple elements with the specified value,
 * there is no guarantee which one will be found. This method considers all NaN
 * values to be equivalent and equal.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(double[] a,
 * int fromIndex,
 * int toIndex,
 * double key)
 * Searches a range of the specified array of doubles for the specified value
 * using the binary search algorithm. The range must be sorted (as by the
 * sort(double[], int, int) method) prior to making this call. If it is not
 * sorted, the results are undefined. If the range contains multiple elements
 * with the specified value, there is no guarantee which one will be found. This
 * method considers all NaN values to be equivalent and equal.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(float[] a,
 * float key)
 * Searches the specified array of floats for the specified value using the
 * binary search algorithm. The array must be sorted (as by the sort(float[])
 * method) prior to making this call. If it is not sorted, the results are
 * undefined. If the array contains multiple elements with the specified value,
 * there is no guarantee which one will be found. This method considers all NaN
 * values to be equivalent and equal.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * binarySearch
 * public static int binarySearch(float[] a,
 * int fromIndex,
 * int toIndex,
 * float key)
 * Searches a range of the specified array of floats for the specified value
 * using the binary search algorithm. The range must be sorted (as by the
 * sort(float[], int, int) method) prior to making this call. If it is not
 * sorted, the results are undefined. If the range contains multiple elements
 * with the specified value, there is no guarantee which one will be found. This
 * method considers all NaN values to be equivalent and equal.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static int binarySearch(Object[] a,
 * Object key)
 * Searches the specified array for the specified object using the binary search
 * algorithm. The array must be sorted into ascending order according to the
 * natural ordering of its elements (as by the sort(Object[]) method) prior to
 * making this call. If it is not sorted, the results are undefined. (If the
 * array contains elements that are not mutually comparable (for example,
 * strings and integers), it cannot be sorted according to the natural ordering
 * of its elements, hence results are undefined.) If the array contains multiple
 * elements equal to the specified object, there is no guarantee which one will
 * be found.
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * Throws:
 * ClassCastException - if the search key is not comparable to the elements of
 * the array.
 * binarySearch
 * public static int binarySearch(Object[] a,
 * int fromIndex,
 * int toIndex,
 * Object key)
 * Searches a range of the specified array for the specified object using the
 * binary search algorithm. The range must be sorted into ascending order
 * according to the natural ordering of its elements (as by the sort(Object[],
 * int, int) method) prior to making this call. If it is not sorted, the results
 * are undefined. (If the range contains elements that are not mutually
 * comparable (for example, strings and integers), it cannot be sorted according
 * to the natural ordering of its elements, hence results are undefined.) If the
 * range contains multiple elements equal to the specified object, there is no
 * guarantee which one will be found.
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * ClassCastException - if the search key is not comparable to the elements of
 * the array within the specified range.
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * binarySearch
 * public static <T> int binarySearch(T[] a,
 * T key,
 * Comparator<? super T> c)
 * Searches the specified array for the specified object using the binary search
 * algorithm. The array must be sorted into ascending order according to the
 * specified comparator (as by the sort(T[], Comparator) method) prior to making
 * this call. If it is not sorted, the results are undefined. If the array
 * contains multiple elements equal to the specified object, there is no
 * guarantee which one will be found.
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * a - the array to be searched
 * key - the value to be searched for
 * c - the comparator by which the array is ordered. A null value indicates that
 * the elements' natural ordering should be used.
 * Returns:
 * index of the search key, if it is contained in the array; otherwise,
 * (-(insertion point) - 1). The insertion point is defined as the point at
 * which the key would be inserted into the array: the index of the first
 * element greater than the key, or a.length if all elements in the array are
 * less than the specified key. Note that this guarantees that the return value
 * will be >= 0 if and only if the key is found.
 * Throws:
 * ClassCastException - if the array contains elements that are not mutually
 * comparable using the specified comparator, or the search key is not
 * comparable to the elements of the array using this comparator.
 * binarySearch
 * public static <T> int binarySearch(T[] a,
 * int fromIndex,
 * int toIndex,
 * T key,
 * Comparator<? super T> c)
 * Searches a range of the specified array for the specified object using the
 * binary search algorithm. The range must be sorted into ascending order
 * according to the specified comparator (as by the sort(T[], int, int,
 * Comparator) method) prior to making this call. If it is not sorted, the
 * results are undefined. If the range contains multiple elements equal to the
 * specified object, there is no guarantee which one will be found.
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * a - the array to be searched
 * fromIndex - the index of the first element (inclusive) to be searched
 * toIndex - the index of the last element (exclusive) to be searched
 * key - the value to be searched for
 * c - the comparator by which the array is ordered. A null value indicates that
 * the elements' natural ordering should be used.
 * Returns:
 * index of the search key, if it is contained in the array within the specified
 * range; otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of the
 * first element in the range greater than the key, or toIndex if all elements
 * in the range are less than the specified key. Note that this guarantees that
 * the return value will be >= 0 if and only if the key is found.
 * Throws:
 * ClassCastException - if the range contains elements that are not mutually
 * comparable using the specified comparator, or the search key is not
 * comparable to the elements in the range using this comparator.
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * Since:
 * 1.6
 * equals
 * public static boolean equals(long[] a,
 * long[] a2)
 * Returns true if the two specified arrays of longs are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * equals
 * public static boolean equals(int[] a,
 * int[] a2)
 * Returns true if the two specified arrays of ints are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * equals
 * public static boolean equals(short[] a,
 * short[] a2)
 * Returns true if the two specified arrays of shorts are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * equals
 * public static boolean equals(char[] a,
 * char[] a2)
 * Returns true if the two specified arrays of chars are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * equals
 * public static boolean equals(byte[] a,
 * byte[] a2)
 * Returns true if the two specified arrays of bytes are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * equals
 * public static boolean equals(boolean[] a,
 * boolean[] a2)
 * Returns true if the two specified arrays of booleans are equal to one
 * another. Two arrays are considered equal if both arrays contain the same
 * number of elements, and all corresponding pairs of elements in the two arrays
 * are equal. In other words, two arrays are equal if they contain the same
 * elements in the same order. Also, two array references are considered equal
 * if both are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * equals
 * public static boolean equals(double[] a,
 * double[] a2)
 * Returns true if the two specified arrays of doubles are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Two doubles d1 and d2 are considered equal if:
 * 
 * new Double(d1).equals(new Double(d2))
 * (Unlike the == operator, this method considers NaN equals to itself, and 0.0d
 * unequal to -0.0d.)
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * See Also:
 * Double.equals(Object)
 * equals
 * public static boolean equals(float[] a,
 * float[] a2)
 * Returns true if the two specified arrays of floats are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. In other words, two arrays are equal if they contain the same elements
 * in the same order. Also, two array references are considered equal if both
 * are null.
 * Two floats f1 and f2 are considered equal if:
 * 
 * new Float(f1).equals(new Float(f2))
 * (Unlike the == operator, this method considers NaN equals to itself, and 0.0f
 * unequal to -0.0f.)
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * See Also:
 * Float.equals(Object)
 * equals
 * public static boolean equals(Object[] a,
 * Object[] a2)
 * Returns true if the two specified arrays of Objects are equal to one another.
 * The two arrays are considered equal if both arrays contain the same number of
 * elements, and all corresponding pairs of elements in the two arrays are
 * equal. Two objects e1 and e2 are considered equal if (e1==null ? e2==null :
 * e1.equals(e2)). In other words, the two arrays are equal if they contain the
 * same elements in the same order. Also, two array references are considered
 * equal if both are null.
 * Parameters:
 * a - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * fill
 * public static void fill(long[] a,
 * long val)
 * Assigns the specified long value to each element of the specified array of
 * longs.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(long[] a,
 * int fromIndex,
 * int toIndex,
 * long val)
 * Assigns the specified long value to each element of the specified range of
 * the specified array of longs. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(int[] a,
 * int val)
 * Assigns the specified int value to each element of the specified array of
 * ints.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(int[] a,
 * int fromIndex,
 * int toIndex,
 * int val)
 * Assigns the specified int value to each element of the specified range of the
 * specified array of ints. The range to be filled extends from index fromIndex,
 * inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to
 * be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(short[] a,
 * short val)
 * Assigns the specified short value to each element of the specified array of
 * shorts.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(short[] a,
 * int fromIndex,
 * int toIndex,
 * short val)
 * Assigns the specified short value to each element of the specified range of
 * the specified array of shorts. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(char[] a,
 * char val)
 * Assigns the specified char value to each element of the specified array of
 * chars.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(char[] a,
 * int fromIndex,
 * int toIndex,
 * char val)
 * Assigns the specified char value to each element of the specified range of
 * the specified array of chars. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(byte[] a,
 * byte val)
 * Assigns the specified byte value to each element of the specified array of
 * bytes.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(byte[] a,
 * int fromIndex,
 * int toIndex,
 * byte val)
 * Assigns the specified byte value to each element of the specified range of
 * the specified array of bytes. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(boolean[] a,
 * boolean val)
 * Assigns the specified boolean value to each element of the specified array of
 * booleans.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(boolean[] a,
 * int fromIndex,
 * int toIndex,
 * boolean val)
 * Assigns the specified boolean value to each element of the specified range of
 * the specified array of booleans. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(double[] a,
 * double val)
 * Assigns the specified double value to each element of the specified array of
 * doubles.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(double[] a,
 * int fromIndex,
 * int toIndex,
 * double val)
 * Assigns the specified double value to each element of the specified range of
 * the specified array of doubles. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(float[] a,
 * float val)
 * Assigns the specified float value to each element of the specified array of
 * floats.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * fill
 * public static void fill(float[] a,
 * int fromIndex,
 * int toIndex,
 * float val)
 * Assigns the specified float value to each element of the specified range of
 * the specified array of floats. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * fill
 * public static void fill(Object[] a,
 * Object val)
 * Assigns the specified Object reference to each element of the specified array
 * of Objects.
 * Parameters:
 * a - the array to be filled
 * val - the value to be stored in all elements of the array
 * Throws:
 * ArrayStoreException - if the specified value is not of a runtime type that
 * can be stored in the specified array
 * fill
 * public static void fill(Object[] a,
 * int fromIndex,
 * int toIndex,
 * Object val)
 * Assigns the specified Object reference to each element of the specified range
 * of the specified array of Objects. The range to be filled extends from index
 * fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex,
 * the range to be filled is empty.)
 * Parameters:
 * a - the array to be filled
 * fromIndex - the index of the first element (inclusive) to be filled with the
 * specified value
 * toIndex - the index of the last element (exclusive) to be filled with the
 * specified value
 * val - the value to be stored in all elements of the array
 * Throws:
 * IllegalArgumentException - if fromIndex > toIndex
 * ArrayIndexOutOfBoundsException - if fromIndex < 0 or toIndex > a.length
 * ArrayStoreException - if the specified value is not of a runtime type that
 * can be stored in the specified array
 * copyOf
 * public static <T> T[] copyOf(T[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with nulls (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain null. Such indices will exist if and only if the specified
 * length is greater than that of the original array. The resulting array is of
 * exactly the same class as the original array.
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with nulls to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static <T,U> T[] copyOf(U[] original,
 * int newLength,
 * Class<? extends T[]> newType)
 * Copies the specified array, truncating or padding with nulls (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain null. Such indices will exist if and only if the specified
 * length is greater than that of the original array. The resulting array is of
 * the class newType.
 * Type Parameters:
 * U - the class of the objects in the original array
 * T - the class of the objects in the returned array
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * newType - the class of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with nulls to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * ArrayStoreException - if an element copied from original is not of a runtime
 * type that can be stored in an array of class newType
 * Since:
 * 1.6
 * copyOf
 * public static byte[] copyOf(byte[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain (byte)0. Such indices will exist if and only if the
 * specified length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with zeros to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static short[] copyOf(short[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain (short)0. Such indices will exist if and only if the
 * specified length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with zeros to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static int[] copyOf(int[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain 0. Such indices will exist if and only if the specified
 * length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with zeros to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static long[] copyOf(long[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain 0L. Such indices will exist if and only if the specified
 * length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with zeros to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static char[] copyOf(char[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with null characters (if
 * necessary) so the copy has the specified length. For all indices that are
 * valid in both the original array and the copy, the two arrays will contain
 * identical values. For any indices that are valid in the copy but not the
 * original, the copy will contain '\\u000'. Such indices will exist if and only
 * if the specified length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with null characters to
 * obtain the specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static float[] copyOf(float[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain 0f. Such indices will exist if and only if the specified
 * length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with zeros to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static double[] copyOf(double[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with zeros (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain 0d. Such indices will exist if and only if the specified
 * length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with zeros to obtain the
 * specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOf
 * public static boolean[] copyOf(boolean[] original,
 * int newLength)
 * Copies the specified array, truncating or padding with false (if necessary)
 * so the copy has the specified length. For all indices that are valid in both
 * the original array and the copy, the two arrays will contain identical
 * values. For any indices that are valid in the copy but not the original, the
 * copy will contain false. Such indices will exist if and only if the specified
 * length is greater than that of the original array.
 * Parameters:
 * original - the array to be copied
 * newLength - the length of the copy to be returned
 * Returns:
 * a copy of the original array, truncated or padded with false elements to
 * obtain the specified length
 * Throws:
 * NegativeArraySizeException - if newLength is negative
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static <T> T[] copyOfRange(T[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case null is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * The resulting array is of exactly the same class as the original array.
 * 
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with nulls to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static <T,U> T[] copyOfRange(U[] original,
 * int from,
 * int to,
 * Class<? extends T[]> newType)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case null is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * The resulting array is of the class newType.
 * Type Parameters:
 * U - the class of the objects in the original array
 * T - the class of the objects in the returned array
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * newType - the class of the copy to be returned
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with nulls to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * ArrayStoreException - if an element copied from original is not of a runtime
 * type that can be stored in an array of class newType.
 * Since:
 * 1.6
 * copyOfRange
 * public static byte[] copyOfRange(byte[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case (byte)0 is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with zeros to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static short[] copyOfRange(short[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case (short)0 is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with zeros to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static int[] copyOfRange(int[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case 0 is placed
 * in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with zeros to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static long[] copyOfRange(long[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case 0L is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with zeros to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static char[] copyOfRange(char[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case '\\u000' is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with null characters to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static float[] copyOfRange(float[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case 0f is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with zeros to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static double[] copyOfRange(double[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case 0d is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with zeros to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * copyOfRange
 * public static boolean[] copyOfRange(boolean[] original,
 * int from,
 * int to)
 * Copies the specified range of the specified array into a new array. The
 * initial index of the range (from) must lie between zero and original.length,
 * inclusive. The value at original[from] is placed into the initial element of
 * the copy (unless from == original.length or from == to). Values from
 * subsequent elements in the original array are placed into subsequent elements
 * in the copy. The final index of the range (to), which must be greater than or
 * equal to from, may be greater than original.length, in which case false is
 * placed in all elements of the copy whose index is greater than or equal to
 * original.length - from. The length of the returned array will be to - from.
 * Parameters:
 * original - the array from which a range is to be copied
 * from - the initial index of the range to be copied, inclusive
 * to - the final index of the range to be copied, exclusive. (This index may
 * lie outside the array.)
 * Returns:
 * a new array containing the specified range from the original array, truncated
 * or padded with false elements to obtain the required length
 * Throws:
 * ArrayIndexOutOfBoundsException - if from < 0 or from > original.length
 * IllegalArgumentException - if from > to
 * NullPointerException - if original is null
 * Since:
 * 1.6
 * asList
 * 
 * @SafeVarargs
 * public static <T> List<T> asList(T... a)
 * Returns a fixed-size list backed by the specified array. (Changes to the
 * returned list "write through" to the array.) This method acts as bridge
 * between array-based and collection-based APIs, in combination with
 * Collection.toArray(). The returned list is serializable and implements
 * RandomAccess.
 * This method also provides a convenient way to create a fixed-size list
 * initialized to contain several elements:
 * 
 * List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
 * 
 * Type Parameters:
 * T - the class of the objects in the array
 * Parameters:
 * a - the array by which the list will be backed
 * Returns:
 * a list view of the specified array
 * hashCode
 * public static int hashCode(long[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * long arrays a and b such that Arrays.equals(a, b), it is also the case that
 * Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Long
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(int[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * non-null int arrays a and b such that Arrays.equals(a, b), it is also the
 * case that Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Integer
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(short[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * short arrays a and b such that Arrays.equals(a, b), it is also the case that
 * Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Short
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(char[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * char arrays a and b such that Arrays.equals(a, b), it is also the case that
 * Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Character
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(byte[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * byte arrays a and b such that Arrays.equals(a, b), it is also the case that
 * Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Byte
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(boolean[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * boolean arrays a and b such that Arrays.equals(a, b), it is also the case
 * that Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Boolean
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(float[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * float arrays a and b such that Arrays.equals(a, b), it is also the case that
 * Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Float
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(double[] a)
 * Returns a hash code based on the contents of the specified array. For any two
 * double arrays a and b such that Arrays.equals(a, b), it is also the case that
 * Arrays.hashCode(a) == Arrays.hashCode(b).
 * The value returned by this method is the same value that would be obtained by
 * invoking the hashCode method on a List containing a sequence of Double
 * instances representing the elements of a in the same order. If a is null,
 * this method returns 0.
 * 
 * Parameters:
 * a - the array whose hash value to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * hashCode
 * public static int hashCode(Object[] a)
 * Returns a hash code based on the contents of the specified array. If the
 * array contains other arrays as elements, the hash code is based on their
 * identities rather than their contents. It is therefore acceptable to invoke
 * this method on an array that contains itself as an element, either directly
 * or indirectly through one or more levels of arrays.
 * For any two arrays a and b such that Arrays.equals(a, b), it is also the case
 * that Arrays.hashCode(a) == Arrays.hashCode(b).
 * 
 * The value returned by this method is equal to the value that would be
 * returned by Arrays.asList(a).hashCode(), unless a is null, in which case 0 is
 * returned.
 * 
 * Parameters:
 * a - the array whose content-based hash code to compute
 * Returns:
 * a content-based hash code for a
 * Since:
 * 1.5
 * See Also:
 * deepHashCode(Object[])
 * deepHashCode
 * public static int deepHashCode(Object[] a)
 * Returns a hash code based on the "deep contents" of the specified array. If
 * the array contains other arrays as elements, the hash code is based on their
 * contents and so on, ad infinitum. It is therefore unacceptable to invoke this
 * method on an array that contains itself as an element, either directly or
 * indirectly through one or more levels of arrays. The behavior of such an
 * invocation is undefined.
 * For any two arrays a and b such that Arrays.deepEquals(a, b), it is also the
 * case that Arrays.deepHashCode(a) == Arrays.deepHashCode(b).
 * 
 * The computation of the value returned by this method is similar to that of
 * the value returned by List.hashCode() on a list containing the same elements
 * as a in the same order, with one difference: If an element e of a is itself
 * an array, its hash code is computed not by calling e.hashCode(), but as by
 * calling the appropriate overloading of Arrays.hashCode(e) if e is an array of
 * a primitive type, or as by calling Arrays.deepHashCode(e) recursively if e is
 * an array of a reference type. If a is null, this method returns 0.
 * 
 * Parameters:
 * a - the array whose deep-content-based hash code to compute
 * Returns:
 * a deep-content-based hash code for a
 * Since:
 * 1.5
 * See Also:
 * hashCode(Object[])
 * deepEquals
 * public static boolean deepEquals(Object[] a1,
 * Object[] a2)
 * Returns true if the two specified arrays are deeply equal to one another.
 * Unlike the equals(Object[],Object[]) method, this method is appropriate for
 * use with nested arrays of arbitrary depth.
 * Two array references are considered deeply equal if both are null, or if they
 * refer to arrays that contain the same number of elements and all
 * corresponding pairs of elements in the two arrays are deeply equal.
 * 
 * Two possibly null elements e1 and e2 are deeply equal if any of the following
 * conditions hold:
 * 
 * e1 and e2 are both arrays of object reference types, and
 * Arrays.deepEquals(e1, e2) would return true
 * e1 and e2 are arrays of the same primitive type, and the appropriate
 * overloading of Arrays.equals(e1, e2) would return true.
 * e1 == e2
 * e1.equals(e2) would return true.
 * Note that this definition permits null elements at any depth.
 * If either of the specified arrays contain themselves as elements either
 * directly or indirectly through one or more levels of arrays, the behavior of
 * this method is undefined.
 * 
 * Parameters:
 * a1 - one array to be tested for equality
 * a2 - the other array to be tested for equality
 * Returns:
 * true if the two arrays are equal
 * Since:
 * 1.5
 * See Also:
 * equals(Object[],Object[]), Objects.deepEquals(Object, Object)
 * toString
 * public static String toString(long[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(long). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(int[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(int). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(short[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(short). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(char[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(char). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(byte[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(byte). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(boolean[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(boolean). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(float[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(float). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(double[] a)
 * Returns a string representation of the contents of the specified array. The
 * string representation consists of a list of the array's elements, enclosed in
 * square brackets ("[]"). Adjacent elements are separated by the characters
 * ", " (a comma followed by a space). Elements are converted to strings as by
 * String.valueOf(double). Returns "null" if a is null.
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * toString
 * public static String toString(Object[] a)
 * Returns a string representation of the contents of the specified array. If
 * the array contains other arrays as elements, they are converted to strings by
 * the Object.toString() method inherited from Object, which describes their
 * identities rather than their contents.
 * The value returned by this method is equal to the value that would be
 * returned by Arrays.asList(a).toString(), unless a is null, in which case
 * "null" is returned.
 * 
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * See Also:
 * deepToString(Object[])
 * deepToString
 * public static String deepToString(Object[] a)
 * Returns a string representation of the "deep contents" of the specified
 * array. If the array contains other arrays as elements, the string
 * representation contains their contents and so on. This method is designed for
 * converting multidimensional arrays to strings.
 * The string representation consists of a list of the array's elements,
 * enclosed in square brackets ("[]"). Adjacent elements are separated by the
 * characters ", " (a comma followed by a space). Elements are converted to
 * strings as by String.valueOf(Object), unless they are themselves arrays.
 * 
 * If an element e is an array of a primitive type, it is converted to a string
 * as by invoking the appropriate overloading of Arrays.toString(e). If an
 * element e is an array of a reference type, it is converted to a string as by
 * invoking this method recursively.
 * 
 * To avoid infinite recursion, if the specified array contains itself as an
 * element, or contains an indirect reference to itself through one or more
 * levels of arrays, the self-reference is converted to the string "[...]". For
 * example, an array containing only a reference to itself would be rendered as
 * "[[...]]".
 * 
 * This method returns "null" if the specified array is null.
 * 
 * Parameters:
 * a - the array whose string representation to return
 * Returns:
 * a string representation of a
 * Since:
 * 1.5
 * See Also:
 * toString(Object[])
 * setAll
 * public static <T> void setAll(T[] array,
 * IntFunction<? extends T> generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * If the generator function throws an exception, it is relayed to the caller
 * and the array is left in an indeterminate state.
 * 
 * Type Parameters:
 * T - type of elements of the array
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * parallelSetAll
 * public static <T> void parallelSetAll(T[] array,
 * IntFunction<? extends T> generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * If the generator function throws an exception, an unchecked exception is
 * thrown from parallelSetAll and the array is left in an indeterminate state.
 * 
 * Type Parameters:
 * T - type of elements of the array
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * setAll
 * public static void setAll(int[] array,
 * IntUnaryOperator generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * If the generator function throws an exception, it is relayed to the caller
 * and the array is left in an indeterminate state.
 * 
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * parallelSetAll
 * public static void parallelSetAll(int[] array,
 * IntUnaryOperator generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * If the generator function throws an exception, an unchecked exception is
 * thrown from parallelSetAll and the array is left in an indeterminate state.
 * 
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * setAll
 * public static void setAll(long[] array,
 * IntToLongFunction generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * If the generator function throws an exception, it is relayed to the caller
 * and the array is left in an indeterminate state.
 * 
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * parallelSetAll
 * public static void parallelSetAll(long[] array,
 * IntToLongFunction generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * If the generator function throws an exception, an unchecked exception is
 * thrown from parallelSetAll and the array is left in an indeterminate state.
 * 
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * setAll
 * public static void setAll(double[] array,
 * IntToDoubleFunction generator)
 * Set all elements of the specified array, using the provided generator
 * function to compute each element.
 * If the generator function throws an exception, it is relayed to the caller
 * and the array is left in an indeterminate state.
 * 
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * parallelSetAll
 * public static void parallelSetAll(double[] array,
 * IntToDoubleFunction generator)
 * Set all elements of the specified array, in parallel, using the provided
 * generator function to compute each element.
 * If the generator function throws an exception, an unchecked exception is
 * thrown from parallelSetAll and the array is left in an indeterminate state.
 * 
 * Parameters:
 * array - array to be initialized
 * generator - a function accepting an index and producing the desired value for
 * that position
 * Throws:
 * NullPointerException - if the generator is null
 * Since:
 * 1.8
 * spliterator
 * public static <T> Spliterator<T> spliterator(T[] array)
 * Returns a Spliterator covering all of the specified array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Type Parameters:
 * T - type of elements
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * a spliterator for the array elements
 * Since:
 * 1.8
 * spliterator
 * public static <T> Spliterator<T> spliterator(T[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a Spliterator covering the specified range of the specified array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Type Parameters:
 * T - type of elements
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a spliterator for the array elements
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * spliterator
 * public static Spliterator.OfInt spliterator(int[] array)
 * Returns a Spliterator.OfInt covering all of the specified array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * a spliterator for the array elements
 * Since:
 * 1.8
 * spliterator
 * public static Spliterator.OfInt spliterator(int[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a Spliterator.OfInt covering the specified range of the specified
 * array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a spliterator for the array elements
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * spliterator
 * public static Spliterator.OfLong spliterator(long[] array)
 * Returns a Spliterator.OfLong covering all of the specified array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * the spliterator for the array elements
 * Since:
 * 1.8
 * spliterator
 * public static Spliterator.OfLong spliterator(long[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a Spliterator.OfLong covering the specified range of the specified
 * array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a spliterator for the array elements
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * spliterator
 * public static Spliterator.OfDouble spliterator(double[] array)
 * Returns a Spliterator.OfDouble covering all of the specified array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * a spliterator for the array elements
 * Since:
 * 1.8
 * spliterator
 * public static Spliterator.OfDouble spliterator(double[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a Spliterator.OfDouble covering the specified range of the specified
 * array.
 * The spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED,
 * Spliterator.ORDERED, and Spliterator.IMMUTABLE.
 * 
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a spliterator for the array elements
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * stream
 * public static <T> Stream<T> stream(T[] array)
 * Returns a sequential Stream with the specified array as its source.
 * Type Parameters:
 * T - The type of the array elements
 * Parameters:
 * array - The array, assumed to be unmodified during use
 * Returns:
 * a Stream for the array
 * Since:
 * 1.8
 * stream
 * public static <T> Stream<T> stream(T[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a sequential Stream with the specified range of the specified array
 * as its source.
 * Type Parameters:
 * T - the type of the array elements
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a Stream for the array range
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * stream
 * public static IntStream stream(int[] array)
 * Returns a sequential IntStream with the specified array as its source.
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * an IntStream for the array
 * Since:
 * 1.8
 * stream
 * public static IntStream stream(int[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a sequential IntStream with the specified range of the specified
 * array as its source.
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * an IntStream for the array range
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * stream
 * public static LongStream stream(long[] array)
 * Returns a sequential LongStream with the specified array as its source.
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * a LongStream for the array
 * Since:
 * 1.8
 * stream
 * public static LongStream stream(long[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a sequential LongStream with the specified range of the specified
 * array as its source.
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a LongStream for the array range
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * stream
 * public static DoubleStream stream(double[] array)
 * Returns a sequential DoubleStream with the specified array as its source.
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * Returns:
 * a DoubleStream for the array
 * Since:
 * 1.8
 * stream
 * public static DoubleStream stream(double[] array,
 * int startInclusive,
 * int endExclusive)
 * Returns a sequential DoubleStream with the specified range of the specified
 * array as its source.
 * Parameters:
 * array - the array, assumed to be unmodified during use
 * startInclusive - the first index to cover, inclusive
 * endExclusive - index immediately past the last index to cover
 * Returns:
 * a DoubleStream for the array range
 * Throws:
 * ArrayIndexOutOfBoundsException - if startInclusive is negative, endExclusive
 * is less than startInclusive, or endExclusive is greater than the array size
 * Since:
 * 1.8
 * SKIP NAVIGATION LINKSOVERVIEWPACKAGECLASSUSETREEDEPRECATEDINDEXHELPJava™
 * Platform
 * Standard Ed. 8PREV CLASSNEXT CLASSFRAMESNO FRAMESALL CLASSESSUMMARY: NESTED |
 * FIELD | CONSTR | METHODDETAIL: FIELD | CONSTR | METHOD
 * Submit a bug or feature
 * For further API reference and developer documentation, see Java SE
 * Documentation. That documentation contains more detailed, developer-targeted
 * descriptions, with conceptual overviews, definitions of terms, workarounds,
 * and working code examples.
 * Copyright © 1993, 2023, Oracle and/or its affiliates. All rights reserved.
 * Use is subject to license terms. Also see the documentation redistribution
 * policy. Modify Préférences en matière de cookies. Modify Ad Choices.
 */